<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>计算机知识体系总览 | Leosocy's Blog</title><meta name="description" content="把知识看作是一颗语义树，在进入叶子（细节）之前，先确保自己理解了基本原理，也就是这颗树的树干和大的树枝，然后再深入到树叶，否则的话那些树叶和细节将会无处栖身，导致很快凋落（遗忘）。随着工作经验的增长，愈发觉得很多技术背后的基本原理都是相通的，所以基于这些原理构建自己的知识体系是尤为重要的，这样才能更好地做到接（学习）、化（理解）、发（创造）。"><meta name="keywords" content="基础知识,后端技能,编程语言,内功心法,大数据,云原生,效率工具"><meta name="author" content="Leosocy,leosocy@gmail.com"><meta name="copyright" content="Leosocy"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://cdn.leosocy.top/img/LEO-logo.jpg"><link rel="canonical" href="https://blog.leosocy.top/posts/133f/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin="crossorigin"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"><meta name="google-site-verification" content="oh1OfqVAIxCAFZ8w5KBBtK7tJK48Z0HuFl2XXbRiM-E"><meta name="baidu-site-verification" content="code-7jpxSWptMj"><meta property="og:type" content="article"><meta property="og:title" content="计算机知识体系总览"><meta property="og:url" content="https://blog.leosocy.top/posts/133f/"><meta property="og:site_name" content="Leosocy's Blog"><meta property="og:description" content="把知识看作是一颗语义树，在进入叶子（细节）之前，先确保自己理解了基本原理，也就是这颗树的树干和大的树枝，然后再深入到树叶，否则的话那些树叶和细节将会无处栖身，导致很快凋落（遗忘）。随着工作经验的增长，愈发觉得很多技术背后的基本原理都是相通的，所以基于这些原理构建自己的知识体系是尤为重要的，这样才能更好地做到接（学习）、化（理解）、发（创造）。"><meta property="og:image" content="https://blog.leosocy.top/img/computer-science.png"><meta property="article:published_time" content="2020-11-14T03:42:22.000Z"><meta property="article:modified_time" content="2023-11-05T07:26:20.240Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-8EGQPPW7GQ"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-8EGQPPW7GQ');
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>(function(win, export_obj) {
win['TeaAnalyticsObject'] = export_obj;
if (!win[export_obj]) {
function _collect() {
_collect.q.push(arguments);
}
_collect.q = _collect.q || [];
win[export_obj] = _collect;
}
win[export_obj].l = +new Date();
})(window, 'collectEvent');</script><script async src="https://sf1-scmcdn-tos.pstatp.com/goofy/log-sdk/collect/collect-autotrack-rangers.js"></script><script>window.collectEvent('init', {
app_id: 190292,//  必须替换成申请的 app_id
channel: 'cn',
log: true, // 开启调试日志
autotrack: true // 开启全埋点采集，默认关闭，需要热力图及圈选功能可开启
});
window.collectEvent('start');</script><script>var _wr = function(type) {
  var orig = history[type];
  return function() {
    var rv = orig.apply(this, arguments);
    var e = new Event(type);
    e.arguments = arguments;
    window.dispatchEvent(e);
    return rv;
  };
};
history.pushState = _wr('pushState');
history.replaceState = _wr('replaceState');
window.addEventListener("popstate", function(event) {
  window.collectEvent('predefinePageView');
});
window.addEventListener("pushState", function(event) {
  window.collectEvent('predefinePageView');
});</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2023-11-05 15:26:20'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LeosocyBlog/cdn@master/css/leosocy.min.css"><meta name="referrer" content="no-referrer-when-downgrade"><meta name="generator" content="Hexo 7.0.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="https://cdn.leosocy.top/img/avatar-leosocy.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">26</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">40</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">21</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-github"></i><span> 我的开源项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Leosocy/EDCC-Palmprint-Recognition"><i class="fa-fw fas fa-id-card"></i><span> EDCC高效、准确的掌纹识别算法</span></a></li><li><a class="site-page" target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Leosocy/RobustPalmRoi"><i class="fa-fw fas fa-hand-paper"></i><span> RobustPalmRoi鲁棒性好的掌纹ROI提取算法</span></a></li><li><a class="site-page" target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Leosocy/IntelliProxy"><i class="fa-fw fas fa-cloud"></i><span> Go实现的持久实时高质量的HTTP代理</span></a></li><li><a class="site-page" target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Leosocy/cacheorm"><i class="fa-fw fas fa-database"></i><span> 基于缓存的Python ORM框架</span></a></li><li><a class="site-page" target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Leosocy/SmartThreadPool"><i class="fa-fw fas fa-sitemap"></i><span> C++11实现的智能线程池库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/gossip/"><i class="fa-fw fas fa-book"></i><span> 随笔</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">计算机原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%AF%C2%B7%E8%AF%BA%E4%BE%9D%E6%9B%BC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">冯·诺依曼体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E7%BB%84%E6%88%90"><span class="toc-number">1.1.2.</span> <span class="toc-text">CPU组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">寄存器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E6%8C%87%E4%BB%A4"><span class="toc-number">1.1.3.</span> <span class="toc-text">CPU指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">指令分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E7%A0%81%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">机器码的生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E8%B7%B3%E8%BD%AC"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">指令跳转</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#if%E2%80%A6else-goto"><span class="toc-number">1.1.3.3.1.</span> <span class="toc-text">if…else + goto</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#while-amp-for"><span class="toc-number">1.1.3.3.2.</span> <span class="toc-text">while &amp; for</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#switch%E2%80%A6case"><span class="toc-number">1.1.3.3.3.</span> <span class="toc-text">switch…case</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%8F%8A%E6%A0%88%E5%B8%A7"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">函数调用及栈帧</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7%E8%B5%B7%E6%BA%90"><span class="toc-number">1.1.3.4.1.</span> <span class="toc-text">函数栈帧起源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.1.3.4.2.</span> <span class="toc-text">汇编代码分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#x86-64%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">1.1.3.4.3.</span> <span class="toc-text">x86_64常用指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%BB%B6%E5%B1%95"><span class="toc-number">1.1.3.4.4.</span> <span class="toc-text">相关知识延展</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%86%85%E8%81%94%E4%BC%98%E5%8A%A3"><span class="toc-number">1.1.3.4.4.1.</span> <span class="toc-text">函数内联优劣</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Stack-Overflow"><span class="toc-number">1.1.3.4.4.2.</span> <span class="toc-text">Stack Overflow</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB"><span class="toc-number">1.1.3.4.4.3.</span> <span class="toc-text">栈溢出攻击</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.3.4.4.4.</span> <span class="toc-text">尾递归优化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%87%BD%E6%95%B0%E6%A0%88%E5%88%87%E6%8D%A2"><span class="toc-number">1.1.3.4.4.5.</span> <span class="toc-text">协程的函数栈切换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8ECPU%E6%8C%87%E4%BB%A4%E5%B1%82%E9%9D%A2%E7%90%86%E8%A7%A3%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">从CPU指令层面理解一些问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LLVM"><span class="toc-number">1.1.3.5.1.</span> <span class="toc-text">LLVM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B7%E6%B7%86%E7%BC%96%E8%AF%91"><span class="toc-number">1.1.3.5.2.</span> <span class="toc-text">混淆编译</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Compare-And-Swap%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.3.5.3.</span> <span class="toc-text">Compare And Swap原子操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B6%85%E7%BA%BF%E7%A8%8B-hyperthreading"><span class="toc-number">1.1.3.5.4.</span> <span class="toc-text">超线程 hyperthreading</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.3.5.5.</span> <span class="toc-text">有趣的优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E8%BF%90%E7%AE%97"><span class="toc-number">1.1.4.</span> <span class="toc-text">CPU运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83%EF%BC%88ALU-Arithmetic-Logic-Unit%EF%BC%89"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">算术逻辑单元（ALU Arithmetic Logic Unit）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%A8%E7%94%B5%E8%B7%AF"><span class="toc-number">1.1.4.1.1.</span> <span class="toc-text">门电路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E6%B3%95%E5%99%A8"><span class="toc-number">1.1.4.1.2.</span> <span class="toc-text">加法器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8A%A0%E6%B3%95%E5%99%A8%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.4.1.2.1.</span> <span class="toc-text">加法器优化</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E5%99%A8"><span class="toc-number">1.1.4.1.3.</span> <span class="toc-text">乘法器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">1.1.4.1.4.</span> <span class="toc-text">减法运算</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%8F%E6%B3%95%E5%99%A8%E6%95%88%E7%8E%87%E4%BD%8E"><span class="toc-number">1.1.4.1.4.1.</span> <span class="toc-text">为什么减法器效率低</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B4%9F%E6%95%B0%E7%9A%84%E8%A1%A5%E7%A0%81%E8%A6%81%E6%8C%89%E4%BD%8D%E5%8F%96%E5%8F%8D%E5%B9%B6%E5%8A%A01%EF%BC%9F"><span class="toc-number">1.1.4.1.4.2.</span> <span class="toc-text">为什么负数的补码要按位取反并加1？</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97"><span class="toc-number">1.1.4.1.5.</span> <span class="toc-text">浮点运算</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E5%8D%87CPU%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">提升CPU利用率</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">1.1.4.2.1.</span> <span class="toc-text">流水线</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-number">1.1.4.2.2.</span> <span class="toc-text">乱序执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B"><span class="toc-number">1.1.4.2.3.</span> <span class="toc-text">分支预测</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Linux%E4%B8%AD%E7%9A%84likely-unlikely"><span class="toc-number">1.1.4.2.3.1.</span> <span class="toc-text">Linux中的likely&#x2F;unlikely</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%EF%BC%9ASIMD"><span class="toc-number">1.1.4.2.4.</span> <span class="toc-text">并行计算：SIMD</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E5%B0%8F%F0%9F%8C%B0"><span class="toc-number">1.1.4.2.5.</span> <span class="toc-text">一些有趣小🌰</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-number">1.1.5.</span> <span class="toc-text">内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MMU%E4%B8%8ETLB"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">MMU与TLB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#M-Modified-E-Exclusive-S-Shared-I-Invalid-%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">M(Modified) E(Exclusive) S(Shared) I(Invalid)协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CacheLine%E4%B8%8E%E4%BC%AA%E5%85%B1%E4%BA%AB"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">CacheLine与伪共享</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E4%B8%8EI-O%E8%AE%BE%E5%A4%87"><span class="toc-number">1.1.6.</span> <span class="toc-text">存储与I&#x2F;O设备</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DMA"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">DMA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#INT%E4%B8%AD%E6%96%AD"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">INT中断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88ARM%E6%9E%B6%E6%9E%84%E5%9C%A8%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E6%97%B6%E4%BB%A3%E5%A4%A7%E8%A1%8C%E5%85%B6%E9%81%93"><span class="toc-number">1.1.7.</span> <span class="toc-text">为什么ARM架构在移动互联网时代大行其道</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">物理内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.1.1.1.</span> <span class="toc-text">伙伴系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D"><span class="toc-number">1.2.1.1.2.</span> <span class="toc-text">小对象分配</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">虚拟内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E5%B8%83%E5%B1%80"><span class="toc-number">1.2.1.2.1.</span> <span class="toc-text">页表布局</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Page-Table-Entry-Flags"><span class="toc-number">1.2.1.2.2.</span> <span class="toc-text">Page Table Entry Flags</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PGD%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">1.2.1.2.3.</span> <span class="toc-text">PGD与进程切换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Huge-Page"><span class="toc-number">1.2.1.2.4.</span> <span class="toc-text">Huge Page</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">编译原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD"><span class="toc-number">1.4.</span> <span class="toc-text">程序链接与装载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%93%E6%89%93%E6%A1%A9%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.1.</span> <span class="toc-text">库打桩机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">1.4.2.</span> <span class="toc-text">链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E7%9A%84%E6%8E%A5%E5%8F%A3%E2%80%94%E2%80%94%E7%AC%A6%E5%8F%B7"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">链接的接口——符号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">动态链接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#GOT%E4%B8%8EC-%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="toc-number">1.4.2.2.1.</span> <span class="toc-text">GOT与C++中的虚函数表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%A5%E5%8F%A3%E4%B8%80%E5%AE%9A%E6%98%AFmain%E5%90%97"><span class="toc-number">1.4.2.2.2.</span> <span class="toc-text">函数的入口一定是main吗</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">1.5.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99"><span class="toc-number">1.5.1.</span> <span class="toc-text">相关资料</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-number">1.5.2.</span> <span class="toc-text">数据链路层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FDB-Fowarding-dataase"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">FDB(Fowarding dataase)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">1.5.3.</span> <span class="toc-text">网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ARP-Address-Resolution-Protocol"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">ARP(Address Resolution Protocol)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IP"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">IP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IPv6"><span class="toc-number">1.5.3.2.1.</span> <span class="toc-text">IPv6</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.3.2.1.1.</span> <span class="toc-text">一些小问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TUN-TAP%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">TUN&#x2F;TAP及其应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#socket"><span class="toc-number">1.5.4.</span> <span class="toc-text">socket</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UnixDomain-Socket"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">UnixDomain Socket</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">1.5.5.</span> <span class="toc-text">传输层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Packet-Filtering-amp-iptables"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">Packet Filtering &amp; iptables</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.5.6.</span> <span class="toc-text">应用层协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E5%AE%B6%E6%97%8F"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">HTTP家族</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTP2%E7%89%B9%E6%80%A7"><span class="toc-number">1.5.6.1.1.</span> <span class="toc-text">HTTP2特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#QUIC"><span class="toc-number">1.5.6.1.2.</span> <span class="toc-text">QUIC</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">DNS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSH"><span class="toc-number">1.5.6.3.</span> <span class="toc-text">SSH</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SSH%E4%BD%BF%E7%94%A8%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.6.3.1.</span> <span class="toc-text">SSH使用账号密码认证原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SSH%E4%BD%BF%E7%94%A8%E7%A7%98%E9%92%A5%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.6.3.2.</span> <span class="toc-text">SSH使用秘钥认证原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SSH-tunneling%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.6.3.3.</span> <span class="toc-text">SSH tunneling原理及使用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.</span> <span class="toc-text">数据结构与算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E6%8A%80%E8%83%BD"><span class="toc-number">2.</span> <span class="toc-text">后端技能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.1.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL"><span class="toc-number">2.1.1.</span> <span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E7%9A%84Page-Structure"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">InnoDB的Page Structure</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">2.1.2.</span> <span class="toc-text">分库分表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">一致性哈希</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.</span> <span class="toc-text">缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%E6%80%BB%E8%A7%88"><span class="toc-number">2.2.1.</span> <span class="toc-text">缓存技术总览</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">缓存淘汰策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TinyLFU"><span class="toc-number">2.2.1.1.1.</span> <span class="toc-text">TinyLFU</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#W-TinyLFU"><span class="toc-number">2.2.1.1.1.1.</span> <span class="toc-text">W-TinyLFU</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis"><span class="toc-number">2.2.2.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">Redis数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Redis%E7%BC%96%E7%A0%81"><span class="toc-number">2.2.2.1.1.</span> <span class="toc-text">Redis编码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Redis%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.2.1.2.</span> <span class="toc-text">Redis对象</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#String-Object"><span class="toc-number">2.2.2.1.2.1.</span> <span class="toc-text">String Object</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">Redis通信协议</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RESP%EF%BC%88REdis-Serialization-Protocol%EF%BC%89"><span class="toc-number">2.2.2.2.1.</span> <span class="toc-text">RESP（REdis Serialization Protocol）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">淘汰机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.3.</span> <span class="toc-text">内存缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">2.3.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81-amp-%E5%8E%8B%E7%BC%A9-amp-%E5%8A%A0%E5%AF%86"><span class="toc-number">2.4.</span> <span class="toc-text">编码 &amp; 压缩 &amp; 加密</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81"><span class="toc-number">2.4.1.</span> <span class="toc-text">编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">字符编码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-number">2.4.1.1.1.</span> <span class="toc-text">字符集与字符编码发展史</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#UTF-8%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99"><span class="toc-number">2.4.1.1.2.</span> <span class="toc-text">UTF-8编码规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%8B%E6%8C%81%E4%B8%A4%E6%8A%8A%E9%94%9F%E6%96%A4%E6%8B%B7%EF%BC%8C%E5%8F%A3%E4%B8%AD%E7%96%BE%E5%91%BC%E7%83%AB%E7%83%AB%E7%83%AB"><span class="toc-number">2.4.1.1.3.</span> <span class="toc-text">手持两把锟斤拷，口中疾呼烫烫烫</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MySQL%E4%B8%AD%E7%9A%84utf8mb4"><span class="toc-number">2.4.1.1.4.</span> <span class="toc-text">MySQL中的utf8mb4</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Python2%E4%B8%AD%E8%AE%A8%E5%8E%8C%E7%9A%84%E7%BC%96%E7%A0%81"><span class="toc-number">2.4.1.1.5.</span> <span class="toc-text">Python2中讨厌的编码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Protobuf"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">Protobuf</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#varint"><span class="toc-number">2.4.1.2.1.</span> <span class="toc-text">varint</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#zigzag"><span class="toc-number">2.4.1.2.2.</span> <span class="toc-text">zigzag</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">JSON</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#simdjson%E6%98%AF%E4%BD%95%E6%96%B9%E7%A5%9E%E5%9C%A3"><span class="toc-number">2.4.1.3.1.</span> <span class="toc-text">simdjson是何方神圣</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Base64%E5%AE%B6%E6%97%8F"><span class="toc-number">2.4.1.4.</span> <span class="toc-text">Base64家族</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9"><span class="toc-number">2.4.2.</span> <span class="toc-text">压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GZip"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">GZip</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LZ4"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">LZ4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Snappy"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">Snappy</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86"><span class="toc-number">2.4.3.</span> <span class="toc-text">加密</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">非对称加密</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RSA%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.3.1.1.</span> <span class="toc-text">RSA算法的数学原理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F"><span class="toc-number">2.5.</span> <span class="toc-text">分布式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC"><span class="toc-number">2.6.</span> <span class="toc-text">RPC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">2.7.</span> <span class="toc-text">内存分配与回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eBPF"><span class="toc-number">2.8.</span> <span class="toc-text">eBPF</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="toc-number">3.</span> <span class="toc-text">编程语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C"><span class="toc-number">3.1.</span> <span class="toc-text">C</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-1"><span class="toc-number">3.2.</span> <span class="toc-text">C++</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python"><span class="toc-number">3.3.</span> <span class="toc-text">Python</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.1.</span> <span class="toc-text">底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">一切皆对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#int"><span class="toc-number">3.3.1.1.1.</span> <span class="toc-text">int</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#import"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">import</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%87%E6%B7%AB%E5%B7%A7%E6%8A%80"><span class="toc-number">3.3.2.</span> <span class="toc-text">奇淫巧技</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#new-%E4%B8%8E-init"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">__new__与__init__</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95%E4%B8%8E%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">类方法与实例方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mock%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">mock的原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java"><span class="toc-number">3.4.</span> <span class="toc-text">Java</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM"><span class="toc-number">3.4.1.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-Header"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">Object Header</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scala"><span class="toc-number">3.5.</span> <span class="toc-text">Scala</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go"><span class="toc-number">3.6.</span> <span class="toc-text">Go</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Go%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%89%B9%E5%88%AB%E5%B0%8F%E8%BF%98%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BE%9D%E8%B5%96so"><span class="toc-number">3.6.1.</span> <span class="toc-text">为什么Go的可执行文件特别小还不需要依赖so</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">内功心法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3"><span class="toc-number">4.1.</span> <span class="toc-text">面向对象思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">4.2.</span> <span class="toc-text">设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83"><span class="toc-number">4.4.</span> <span class="toc-text">编码规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="toc-number">4.5.</span> <span class="toc-text">接口设计规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84"><span class="toc-number">4.6.</span> <span class="toc-text">代码重构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.7.</span> <span class="toc-text">领域驱动设计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE"><span class="toc-number">5.</span> <span class="toc-text">大数据</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%B9%E6%B5%81%E5%A4%84%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">批流处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8"><span class="toc-number">5.2.</span> <span class="toc-text">存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E5%88%86%E6%9E%90"><span class="toc-number">5.3.</span> <span class="toc-text">实时分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%91%E5%8E%9F%E7%94%9F"><span class="toc-number">6.</span> <span class="toc-text">云原生</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-number">6.1.</span> <span class="toc-text">虚拟化技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KVM"><span class="toc-number">6.1.1.</span> <span class="toc-text">KVM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">6.2.</span> <span class="toc-text">容器技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%BA%95%E5%B1%82%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF"><span class="toc-number">6.2.1.</span> <span class="toc-text">容器底层核心技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Namespace"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">Namespace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CGroup"><span class="toc-number">6.2.1.2.</span> <span class="toc-text">CGroup</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker"><span class="toc-number">6.2.2.</span> <span class="toc-text">Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker%E7%BD%91%E7%BB%9C"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">Docker网络</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Podman"><span class="toc-number">6.2.3.</span> <span class="toc-text">Podman</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernetes"><span class="toc-number">6.3.</span> <span class="toc-text">Kubernetes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#K8S%E7%BD%91%E7%BB%9C"><span class="toc-number">6.3.1.</span> <span class="toc-text">K8S网络</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Flannel%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86"><span class="toc-number">6.3.1.1.</span> <span class="toc-text">Flannel网络原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Helm"><span class="toc-number">6.3.2.</span> <span class="toc-text">Helm</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ServiceMesh"><span class="toc-number">6.4.</span> <span class="toc-text">ServiceMesh</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.</span> <span class="toc-text">系统设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E8%BD%AF%E6%8A%80%E8%83%BD"><span class="toc-number">8.</span> <span class="toc-text">代码之外的软技能</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7"><span class="toc-number">9.</span> <span class="toc-text">效率工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">9.1.</span> <span class="toc-text">性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%81%AB%E7%84%B0%E5%9B%BE"><span class="toc-number">9.1.1.</span> <span class="toc-text">火焰图</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.leosocy.top/img/computer-science.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Leosocy's Blog</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-github"></i><span> 我的开源项目</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Leosocy/EDCC-Palmprint-Recognition"><i class="fa-fw fas fa-id-card"></i><span> EDCC高效、准确的掌纹识别算法</span></a></li><li><a class="site-page" target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Leosocy/RobustPalmRoi"><i class="fa-fw fas fa-hand-paper"></i><span> RobustPalmRoi鲁棒性好的掌纹ROI提取算法</span></a></li><li><a class="site-page" target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Leosocy/IntelliProxy"><i class="fa-fw fas fa-cloud"></i><span> Go实现的持久实时高质量的HTTP代理</span></a></li><li><a class="site-page" target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Leosocy/cacheorm"><i class="fa-fw fas fa-database"></i><span> 基于缓存的Python ORM框架</span></a></li><li><a class="site-page" target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Leosocy/SmartThreadPool"><i class="fa-fw fas fa-sitemap"></i><span> C++11实现的智能线程池库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/gossip/"><i class="fa-fw fas fa-book"></i><span> 随笔</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">计算机知识体系总览</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2020-11-14T03:42:22.000Z" title="undefined 2020-11-14 11:42:22">2020-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%9E%84%E5%BB%BA/">计算机知识体系构建</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>92分钟</span></span><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/posts/133f/" data-flag-title="计算机知识体系总览"><i class="far fa-fire fa-fw post-meta-icon"></i><span class="post-meta-label">热度:</span><span class="leancloud-visitors-count"></span><span class="du"> °C</span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="计算机原理"><a href="#计算机原理" class="headerlink" title="计算机原理"></a>计算机原理</h2><h3 id="冯·诺依曼体系结构"><a href="#冯·诺依曼体系结构" class="headerlink" title="冯·诺依曼体系结构"></a>冯·诺依曼体系结构</h3><h3 id="CPU组成"><a href="#CPU组成" class="headerlink" title="CPU组成"></a>CPU组成</h3><ul>
<li>控制单元（Control Unit）：</li>
<li>数据单元</li>
<li>运算单元</li>
</ul>
<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果以及一些CPU运行需要的信息。</p>
<p>下面几个tabs描述了x86-64架构中涉及到的不同类别的寄存器</p>
<div class="tabs" id="寄存器"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#寄存器-1">通用寄存器</button></li><li class="tab"><button type="button" data-href="#寄存器-2">标志寄存器</button></li><li class="tab"><button type="button" data-href="#寄存器-3">指令寄存器</button></li><li class="tab"><button type="button" data-href="#寄存器-4">控制寄存器</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="寄存器-1"><p>通用寄存器是程序执行过程中最常用、最基础的寄存器，大部分时间都是在操作这些寄存器完成指令功能。“通用”指的是这些寄存器没有特殊的用途，可以交给程序<strong>按照一定的规则</strong>（通用不是乱用）去使用。</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>Callee Save</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>%rax(Accumulator)</td>
<td></td>
<td>结果寄存器，通常用执行加法，存储函数调用的返回值，也会用于<code>idiv</code>和<code>imul</code>指令</td>
</tr>
<tr>
<td>%rbx</td>
<td>是</td>
<td>miscellaneous register</td>
</tr>
<tr>
<td>%rdi, %rsi, %rdx, %rcx, %r8, %r9</td>
<td></td>
<td>用作传递整型或指针参数到被调用函数，依次对应第1个参数、第2个参数 …。rdx也会用于<code>idiv</code>和<code>imul</code> 指令</td>
</tr>
<tr>
<td>%rsp(Stack Pointer)</td>
<td></td>
<td>栈指针寄存器，通常会指向栈顶位置，堆栈的pop和push操作就是通过改变rsp的值即移动堆栈指针的位置来实现的</td>
</tr>
<tr>
<td>%rbp(Base Pointer)</td>
<td>是</td>
<td>栈底指针，用于标识当前栈帧的起始位置，通常用rbp+偏移量来存取函数栈中的局部变量</td>
</tr>
<tr>
<td>%r10, %r11</td>
<td></td>
<td>miscellaneous registers</td>
</tr>
<tr>
<td>%r12, %r13, %r14, %r15</td>
<td>是</td>
<td>miscellaneous registers</td>
</tr>
</tbody></table>
<p>从上表我们可以还得出如下结论</p>
<ol>
<li>每个寄存器的用途并不是单一的</li>
<li>在<code>imul</code>指令中，两个64位的乘法最多会产生128位的结果，乘法结果需要<code>%rdx</code>存储高64位<code>%rax</code>存储低64位；在<code>idiv</code>指令中被除数是128位的，同样需要<code>%rax</code>和<code>%rdx</code>共同存储被除数</li>
<li>被标识为”miscellaneous”的寄存器属于通用性更广泛的寄存器，编译器可以根据需要存储任何数据</li>
</ol>
<p><code>Caller Save</code>和<code>Callee Save</code>的区别在于寄存器的值是由<code>调用者负责保存</code>还是<code>被调用者负责保存</code>。当产生函数调用时，子函数内也会使用到通用寄存器进行数据存储，此时这些寄存器中之前保存的父函数的值就会被覆盖。为了避免数据覆盖导致函数返回时寄存器的数据无法恢复，CPU体系结构中就规定了通用寄存器的保存方式。</p>
<p>如果一个寄存器被标识为<code>Caller Save</code>，那么在进行子函数调用前，就需要由调用者提前保存好这些寄存器的值，保存方法通常是把寄存器的值push到堆栈中，调用者保存完成后，在子函数中就可以随意覆盖这些寄存器的值了。如果一个寄存器被标识为<code>Callee Save</code>，那么在函数调用时，调用者就不必保存这些寄存器的值而直接进行子函数调用，进入子函数后，子函数在覆盖这些寄存器之前，需要先保存这些寄存器的值，即这些寄存器的值是由被调用者来保存和恢复的。</p><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="寄存器-2"><p>用里面的一个一个标记bit位，存放CPU进行算术或逻辑计算的结果，这些标志大多由CPU自动设置和修改</p>
<ul>
<li>零标志(Zero Flag)：如果运算结果为0，ZF=1，否则ZF=0</li>
<li>符号标志(Sign Flag)：与运算结果的最高位bit值一致</li>
<li>进位标志(Carry Flag)：在无符号运算时，记录了运算结果的最高有效位向更高位的进位值或从更高位借位，产生进位或借位时CF=1，否则CF=0</li>
<li>溢出标志(Overflow Flag)：有符号运算的结果是否发生了溢出，如果发生溢出OF=1,如果没有OF=0。正数+正数，负数+负数有可能发生溢出；正数-正数不可能发生溢出</li>
<li>奇偶标志(Parity Flag)：如果运算结果bit位中有偶数个1，则其值为1，否则其值为0。此指令主要用于检查数据传输过程中是否产生错误，比如典型的<a target="_blank" rel="external nofollow noopener noreferrer" href="https://en.wikipedia.org/wiki/Parity_bit">奇偶校验</a></li>
</ul>
<blockquote>
<p>CF和OF的区别：CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位。比如：mov al, $7F; add al $01。add指令执行后CF=0，OF=1。</p>
</blockquote>
<p>举几个🌰</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">              <span class="built_in">al</span>                 CF    OF    SF    ZF    PF</span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">al</span>,<span class="built_in">al</span>     <span class="number">0x00</span>/<span class="number">0000</span> <span class="number">0000</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">1</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">10h</span>    <span class="number">0x10</span>/<span class="number">0001</span> <span class="number">0000</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">1</span>  <span class="comment">; mov不会改变任何标志寄存器的值</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">90h</span>    <span class="number">0xa0</span>/<span class="number">1010</span> <span class="number">0000</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">80h</span>    <span class="number">0x80</span>/<span class="number">1000</span> <span class="number">0000</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">80h</span>    <span class="number">0x00</span>/<span class="number">0000</span> <span class="number">0000</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">fch</span>    <span class="number">0xfc</span>/<span class="number">1111</span> <span class="number">1100</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">05h</span>    <span class="number">0x01</span>/<span class="number">0000</span> <span class="number">0001</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">7dh</span>    <span class="number">0x7d</span>/<span class="number">0111</span> <span class="number">1101</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">0bh</span>    <span class="number">0x88</span>/<span class="number">1000</span> <span class="number">1000</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="寄存器-3"><ul>
<li>%rip(Instruction Pointer)：指令指针寄存器，又叫PC(Program Counter)，存放下一条待执行指令的内存地址。CPU的工作其实就是不断取出它指向的指令，然后执行这条指令。</li>
</ul><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="寄存器-4"><p><img src="https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20201128172252.png"></p>
<ul>
<li>CR0：存储了CPU控制标记和工作状态。一些重要的标志位含义如下：<ul>
<li>PE(Protected Mode Enable)：1代表系统运行在保护模式下，否则为实模式</li>
<li>WP(Write Protect)：是否开启内存写保护，若开启，对只读页面进行写入会触发异常，这一机制常常被用于实现<a href="https://blog.leosocy.top/posts/6d47">写时复制COW</a>功能</li>
<li>AM(Alignment Mask)：是否启用内存对齐自动检查</li>
<li>CD(Cache Disable)：1代表关闭cache</li>
<li>PG(Paging)：1代表启用内存分页，同时使用CR3寄存器，否则不开启内存分页</li>
</ul>
</li>
<li>CR1：保留，访问它会导致CPU抛出未定义异常</li>
<li>CR2：发生缺页异常时保存导致异常的访问地址</li>
<li>CR3：用于存储页目录的物理内存基地址，比如Linux 64位中存储PGD的物理地址，在进程空间切换时，CR3也要同步切换</li>
<li>CR4：在保护模式下使用，存储了CPU工作相关以及当前任务的一些信息</li>
</ul><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h3 id="CPU指令"><a href="#CPU指令" class="headerlink" title="CPU指令"></a>CPU指令</h3><h4 id="指令分类"><a href="#指令分类" class="headerlink" title="指令分类"></a>指令分类</h4><table>
<thead>
<tr>
<th>指令类型</th>
<th>示例</th>
<th>示例汇编代码</th>
<th>含义</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>算术类指令</td>
<td>add</td>
<td>add $s1,$s2,$s3</td>
<td>$s1=$s2+$s3</td>
<td>将寄存器r2和r3中的数值相加后的结果放到寄存器r1中</td>
</tr>
<tr>
<td>数据传输类指令</td>
<td>load word</td>
<td>load $s1,10($s2)</td>
<td>$s1=memory[$s2+10]</td>
<td>取寄存器r2中的数，加上10字节偏移后，取出内存中对应的字(WORD 一般为4字节)，存入r1寄存器中</td>
</tr>
<tr>
<td>逻辑类指令</td>
<td>xor</td>
<td>xor $s1,$s2$s3</td>
<td>$s1=$s2 ^ $s3</td>
<td>将寄存器r2和r3中的数值按位取异或后的结果放到寄存器r1中</td>
</tr>
<tr>
<td>条件分支指令</td>
<td>branch on equal</td>
<td>beq $s1,$s2,10</td>
<td>if($s1==$s2) go to PC+10</td>
<td>如果r1和r2寄存器内的值相等，从程序计数器往后跳10</td>
</tr>
<tr>
<td>无条件跳转指令</td>
<td>jump</td>
<td>j 1000</td>
<td>go to 1000</td>
<td>跳转到1000这个目标地址</td>
</tr>
</tbody></table>
<h4 id="机器码的生成"><a href="#机器码的生成" class="headerlink" title="机器码的生成"></a>机器码的生成</h4><p>以最简单的<code>MIPS32</code>指令集为例<br><img src="https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20201117200420.png"></p>
<blockquote>
<p>R指令：用作算术和逻辑运算，rs/rt为读取数据寄存器，rd为写入数据寄存器。如果是逻辑位移操作，则对rs/rt中的数据根据位移量做位移操作，然后写入rd寄存器；否则偏移量为00000。最后的功能码，则是在前面的操作码不够的时候，扩展操作码表示对应的具体指令的。比如<code>add</code>和<code>xor</code>的opcode都是<code>000000</code>，而<code>add</code>的功能码为<code>100000</code>，<code>xor</code>的功能码为<code>100110</code></p>
</blockquote>
<blockquote>
<p>I指令：用作数据传输和条件分支，以及在运算时使用的并非变量而是常数。此时没有第三个寄存器、偏移量以及功能码，这三部分被合成了一个16Bit的<em>地址值</em>或<em>常数</em></p>
</blockquote>
<blockquote>
<p>J指令：用作跳转，除opcode外的26Bit都是一个跳转后的地址</p>
</blockquote>
<p>下面用一个简单的异或指令为例，看看一个机器码如何生成</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">xor $t0,$s2,$s1</span><br><span class="line"></span><br><span class="line">（为了方便，下面的数字都用10进制表示）对应MIPS32指令里，opcode为0，rs代表第一个寄存器s1，地址是17，rt代表第二个寄存器s2，地址是18，rd代表目标的临时寄存器t0，地址是8。因为不是位移操作，所以偏移量是0。功能码通过查表得到二进制为&#x27;100110&#x27;。</span><br><span class="line"></span><br><span class="line">| opcode |   rs  |   rt  |   rd  | shamt | funct  |</span><br><span class="line">| 000000 | 10001 | 10010 | 01000 | 00000 | 100110 |</span><br><span class="line"></span><br><span class="line">2进制表示为：0000 0010 0011 0010 0100 0000 0010 0110</span><br><span class="line">16进制表示为： 0x02324026</span><br></pre></td></tr></table></figure>

<h4 id="指令跳转"><a href="#指令跳转" class="headerlink" title="指令跳转"></a>指令跳转</h4><p>CPU如何执行指令的？</p>
<p>程序执行时，CPU会根据PC寄存器中的指令内存地址，从内存里把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令，这就要求指令必须是连续存储在内存空间中的。</p>
<p>而有些特殊的指令，比如<a href="#%E6%9C%BA%E5%99%A8%E7%A0%81%E7%9A%84%E7%94%9F%E6%88%90">上一小节</a>提到的J指令，也就是跳转指令，会修改PC寄存器里面的指令内存地址的值。这样下一条要执行的指令就不是顺序加载的了。正是因为有了跳转指令，我们才可以在程序中使用<code>if...else/switch...case</code>条件语句和<code>while/for</code>循环语句。</p>
<blockquote>
<p>注：本节汇编代码使用的编译器版本为：<code>Apple clang version 11.0.3 (clang-1103.0.32.59) </code></p>
</blockquote>
<h5 id="if…else-goto"><a href="#if…else-goto" class="headerlink" title="if…else + goto"></a>if…else + goto</h5><p><code>goto</code>属于指令跳转最简单的使用场景。<code>if else</code>通过<code>jne+jmp</code>实现分支跳转。</p>
<div class="tabs" id="ifelse"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ifelse-1">汇编代码</button></li><li class="tab"><button type="button" data-href="#ifelse-2">C代码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ifelse-1"><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; int main() &#123;</span></span><br><span class="line"> <span class="number">0</span>: <span class="number">55</span>                      pushq   %rbp            <span class="comment">; 将父函数栈帧的起始地址压入栈顶，即当前函数栈帧</span></span><br><span class="line"> <span class="number">1</span>: <span class="number">48</span> <span class="number">89</span> e5                <span class="keyword">movq</span>    %rsp, %rbp      <span class="comment">; 将栈指针的值复制到rbp里，而rsp始终会指向栈顶</span></span><br><span class="line"> <span class="number">4</span>: <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>             subq    <span class="number">$16</span>, %rsp       <span class="comment">; 栈顶向下扩展16个字节（栈是从高地址向低地址生长的），用于在发生函数调用时，存储当前函数内的局部变量</span></span><br><span class="line"> <span class="number">8</span>: <span class="number">31</span> c0                   xorl    %eax, %eax      <span class="comment">; rax的低4字节置0</span></span><br><span class="line"><span class="symbol"> a:</span> <span class="number">89</span> c7                   movl    %eax, %edi      <span class="comment">; 将rax的低4字节（即0）复制到rdi寄存器的低4字节。[寄存器](#寄存器)一节有学到rdi是用于存储函数调用的第1个参数值</span></span><br><span class="line"><span class="symbol"> c:</span> c7 <span class="number">45</span> fc <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl    <span class="number">$0</span>, -<span class="number">4</span>(%rbp)    <span class="comment">; 将[rbp-4, rbp]内存空间置0，暂时不知道用处</span></span><br><span class="line"><span class="comment">;  srand(time(NULL));</span></span><br><span class="line"><span class="number">13</span>: e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          callq   <span class="number">0</span> &lt;_main+<span class="number">0x18</span>&gt;  <span class="comment">; 调用time函数，参数的值存在edi寄存器，即0(NULL)</span></span><br><span class="line"><span class="number">18</span>: <span class="number">89</span> c7                   movl    %eax, %edi      <span class="comment">; 将time函数的返回值复制到rdi寄存器的低4字节，作为srand函数的第1个参数</span></span><br><span class="line">1a: e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          callq   <span class="number">0</span> &lt;_main+<span class="number">0x1f</span>&gt;  <span class="comment">; 调用srand函数</span></span><br><span class="line"><span class="comment">;  int r = rand() % 2;</span></span><br><span class="line">1f: e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          callq   <span class="number">0</span> &lt;_main+<span class="number">0x24</span>&gt;  <span class="comment">; 调用rand函数，返回值存到rax指针</span></span><br><span class="line"><span class="number">24</span>: <span class="number">99</span>                      cltd                    <span class="comment">; 将eax寄存器的值符号扩展32位到%edx寄存器，也就是说，如果eax寄存器的二进制序列的最高位为0，则cltd指令将把edx置为32个0，相反，如果%eax寄存器的二进制序列最高位为1，则cltd指令将会自从填充edx寄存器为32个1</span></span><br><span class="line"><span class="number">25</span>: b9 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          movl    <span class="number">$2</span>, %ecx        <span class="comment">; 将rcx的低4字节值置为2</span></span><br><span class="line">2a: f7 f9                   idivl   %ecx            <span class="comment">; 将edx（高32位和eax（低32位）中的64位数作为被除数，ecx值作为除数。指令将商存储在eax中，余数存储在edx中。</span></span><br><span class="line">2c: <span class="number">89</span> <span class="number">55</span> f8                movl    %edx, -<span class="number">8</span>(%rbp)  <span class="comment">; 将edx中存储的余数的值复制到[rbp-8, rpb-4]内存空间，即变量r的栈地址</span></span><br><span class="line"><span class="comment">;  if (r == 0) &#123;</span></span><br><span class="line">2f: <span class="number">83</span> <span class="number">7d</span> f8 <span class="number">00</span>             cmpl    <span class="number">$0</span>, -<span class="number">8</span>(%rbp)    <span class="comment">; 判断r的值是否为0，并根据结果更新ZF/OF/SF标志寄存器，如果r==0，则ZF=1</span></span><br><span class="line"><span class="number">33</span>: 0f <span class="number">85</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">jne</span>     <span class="number">5</span> &lt;_main+<span class="number">0x3e</span>&gt;  <span class="comment">; Jump if not equal，即当ZF!=1时，将PC寄存器值改为0x3e</span></span><br><span class="line"><span class="comment">;      goto label1;</span></span><br><span class="line"><span class="number">39</span>: e9 <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">jmp</span>     <span class="number">5</span> &lt;_main+<span class="number">0x43</span>&gt;  <span class="comment">; 如果r==0，将PC寄存器值改为0x43</span></span><br><span class="line"><span class="comment">;      goto label2;</span></span><br><span class="line">3e: e9 <span class="number">09</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">jmp</span>     <span class="number">9</span> &lt;_main+<span class="number">0x4c</span>&gt;  <span class="comment">; 将PC寄存器值改为0x4c</span></span><br><span class="line"><span class="comment">;  r += 1;</span></span><br><span class="line"><span class="number">43</span>: 8b <span class="number">45</span> f8                movl    -<span class="number">8</span>(%rbp), %eax  <span class="comment">; r==0会执行到这一条指令，将r的值复制到eax寄存器</span></span><br><span class="line"><span class="number">46</span>: <span class="number">83</span> c0 <span class="number">01</span>                addl    <span class="number">$1</span>, %eax        <span class="comment">; eax寄存器累加1</span></span><br><span class="line"><span class="number">49</span>: <span class="number">89</span> <span class="number">45</span> f8                movl    %eax, -<span class="number">8</span>(%rbp)  <span class="comment">; 将eax的值复制到变量r的栈地址空间</span></span><br><span class="line"><span class="comment">;  r += 2;</span></span><br><span class="line">4c: 8b <span class="number">45</span> f8                movl    -<span class="number">8</span>(%rbp), %eax  <span class="comment">; 将r的值复制到eax寄存器</span></span><br><span class="line">4f: <span class="number">83</span> c0 <span class="number">02</span>                addl    <span class="number">$2</span>, %eax        <span class="comment">; eax寄存器累加2</span></span><br><span class="line"><span class="number">52</span>: <span class="number">89</span> <span class="number">45</span> f8                movl    %eax, -<span class="number">8</span>(%rbp)  <span class="comment">; 将eax的值复制到变量r的栈地址空间</span></span><br><span class="line"><span class="comment">;  return r;</span></span><br><span class="line"><span class="number">55</span>: 8b <span class="number">45</span> f8                movl    -<span class="number">8</span>(%rbp), %eax  <span class="comment">; 将r的值复制到eax寄存器，作为函数的返回值</span></span><br><span class="line"><span class="number">58</span>: <span class="number">48</span> <span class="number">83</span> c4 <span class="number">10</span>             addq    <span class="number">$16</span>, %rsp       <span class="comment">; 栈顶向上缩减16个字节，即恢复刚开始开辟的16字节栈内存空间</span></span><br><span class="line">5c: <span class="number">5d</span>                      popq    %rbp            <span class="comment">; 将父函数栈帧的起始地址恢复到rbp寄存器</span></span><br><span class="line"><span class="number">5d</span>: c3                      retq                    <span class="comment">; 弹出当前栈顶元素（即父函数执行call指令时压入的PC寄存器的下一条指令地址），更新到PC寄存器中，将程序控制权返回到出栈后的栈顶</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ifelse-2"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="type">int</span> r = rand() % <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> label1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> label2;</span><br><span class="line">    &#125;</span><br><span class="line">label1:</span><br><span class="line">    r += <span class="number">1</span>;</span><br><span class="line">label2:</span><br><span class="line">    r += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h5 id="while-amp-for"><a href="#while-amp-for" class="headerlink" title="while &amp; for"></a>while &amp; for</h5><ul>
<li><code>for</code>： 先用<code>cmp+jg</code>判断是否满足if条件，不满足则跳出循环，否则执行if内代码，最后用<code>jmp</code>实现执行完if内代码后跳回<code>cmp+jg</code></li>
<li><code>while</code>： 和for一样</li>
<li><code>do...while</code>： 先执行do内代码，然后用<code>cmp+jle</code>判断是否满足while条件，满足则用<code>jmp</code>跳回do，否则结束循环</li>
</ul>
<div class="tabs" id="while"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#while-1">汇编代码</button></li><li class="tab"><button type="button" data-href="#while-2">C代码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="while-1"><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; int main() &#123;</span></span><br><span class="line"> <span class="number">0</span>: <span class="number">55</span>                      pushq   %rbp            </span><br><span class="line"> <span class="number">1</span>: <span class="number">48</span> <span class="number">89</span> e5                <span class="keyword">movq</span>    %rsp, %rbp</span><br><span class="line"> <span class="number">4</span>: c7 <span class="number">45</span> fc <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl    <span class="number">$0</span>, -<span class="number">4</span>(%rbp)      <span class="comment">; 这里发现了个有意思的现象，由于代码里没有调用其他函数，所以没有扩展栈顶的指令，具体原因下面的[函数调用及栈帧](#函数调用及栈帧)一节会分析</span></span><br><span class="line"><span class="comment">;  int a = 1;</span></span><br><span class="line"><span class="symbol"> b:</span> c7 <span class="number">45</span> f8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl    <span class="number">$1</span>, -<span class="number">8</span>(%rbp)      <span class="comment">; 将栈地址[rbp-8, rpb-4]内存空间，即变量a赋值为1</span></span><br><span class="line"><span class="comment">;  for (int i = 1; i &lt;= 3; ++i) &#123;                     ; 下面3条指令对应的是 i = 1; i &lt;= 3</span></span><br><span class="line"><span class="number">12</span>: c7 <span class="number">45</span> f4 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl    <span class="number">$1</span>, -<span class="number">12</span>(%rbp)     <span class="comment">; 将栈地址[rbp-12, rpb-8]内存空间，即变量i赋值为1</span></span><br><span class="line"><span class="number">19</span>: <span class="number">83</span> <span class="number">7d</span> f4 <span class="number">03</span>             cmpl    <span class="number">$3</span>, -<span class="number">12</span>(%rbp)     <span class="comment">; 比较i和3，并根据结果更新ZF/OF/SF标志寄存器，如果i&lt;=3，则ZF=1 SF!=OF</span></span><br><span class="line"><span class="number">1d</span>: 0f 8f <span class="number">17</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">jg</span>      <span class="number">23</span> &lt;_main+<span class="number">0x3a</span>&gt;   <span class="comment">; Jump if greater，即当i &gt; 3时，将PC寄存器值改为0x3a</span></span><br><span class="line"><span class="comment">;      a += i;</span></span><br><span class="line"><span class="number">23</span>: 8b <span class="number">45</span> f4                movl    -<span class="number">12</span>(%rbp), %eax   <span class="comment">; 将i的值复制到eax寄存器  </span></span><br><span class="line"><span class="number">26</span>: <span class="number">03</span> <span class="number">45</span> f8                addl    -<span class="number">8</span>(%rbp), %eax    <span class="comment">; 将a的值累加到eax寄存器</span></span><br><span class="line"><span class="number">29</span>: <span class="number">89</span> <span class="number">45</span> f8                movl    %eax, -<span class="number">8</span>(%rbp)    <span class="comment">; 将eax的值复制到变量a的栈地址空间</span></span><br><span class="line"><span class="comment">;  for (int i = 1; i &lt;= 3; ++i) &#123;                     ; 下面4条指令对应的是 ++i</span></span><br><span class="line">2c: 8b <span class="number">45</span> f4                movl    -<span class="number">12</span>(%rbp), %eax   <span class="comment">; 将i的值复制到eax寄存器</span></span><br><span class="line">2f: <span class="number">83</span> c0 <span class="number">01</span>                addl    <span class="number">$1</span>, %eax          <span class="comment">; eax寄存器累加1</span></span><br><span class="line"><span class="number">32</span>: <span class="number">89</span> <span class="number">45</span> f4                movl    %eax, -<span class="number">12</span>(%rbp)   <span class="comment">; 将eax的值复制到变量i的栈地址空间</span></span><br><span class="line"><span class="number">35</span>: e9 df ff ff ff          <span class="keyword">jmp</span>     -<span class="number">33</span> &lt;_main+<span class="number">0x19</span>&gt;  <span class="comment">; 将PC寄存器值改为0x19，即跳回判断 i &lt;= 3的逻辑</span></span><br><span class="line"><span class="comment">;  while (a &lt;= 10) &#123;</span></span><br><span class="line">3a: e9 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">jmp</span>     <span class="number">0</span> &lt;_main+<span class="number">0x3f</span>&gt;</span><br><span class="line">3f: <span class="number">83</span> <span class="number">7d</span> f8 0a             cmpl    <span class="number">$10</span>, -<span class="number">8</span>(%rbp)     <span class="comment">; 比较a和10</span></span><br><span class="line"><span class="number">43</span>: 0f 8f 0e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">jg</span>      <span class="number">14</span> &lt;_main+<span class="number">0x57</span>&gt;   <span class="comment">; 当 i &gt; 10时，将PC寄存器值改为0x57</span></span><br><span class="line"><span class="comment">;      ++a;</span></span><br><span class="line"><span class="number">49</span>: 8b <span class="number">45</span> f8                movl    -<span class="number">8</span>(%rbp), %eax    <span class="comment">; 将a的值复制到eax寄存器</span></span><br><span class="line">4c: <span class="number">83</span> c0 <span class="number">01</span>                addl    <span class="number">$1</span>, %eax          <span class="comment">; eax寄存器累加1</span></span><br><span class="line">4f: <span class="number">89</span> <span class="number">45</span> f8                movl    %eax, -<span class="number">8</span>(%rbp)    <span class="comment">; 将eax的值复制到变量a的栈地址空间</span></span><br><span class="line"><span class="comment">;  while (a &lt;= 10) &#123;</span></span><br><span class="line"><span class="number">52</span>: e9 e8 ff ff ff          <span class="keyword">jmp</span>     -<span class="number">24</span> &lt;_main+<span class="number">0x3f</span>&gt;  <span class="comment">; 将PC寄存器的值改为0x3f，即跳回判断 i &lt;= 10的逻辑</span></span><br><span class="line"><span class="comment">;  do &#123;</span></span><br><span class="line"><span class="number">57</span>: e9 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">jmp</span>     <span class="number">0</span> &lt;_main+<span class="number">0x5c</span>&gt;</span><br><span class="line"><span class="comment">;      a += 1;</span></span><br><span class="line">5c: 8b <span class="number">45</span> f8                movl    -<span class="number">8</span>(%rbp), %eax    <span class="comment">; 下面3句对应a+1，这里就不赘述了</span></span><br><span class="line">5f: <span class="number">83</span> c0 <span class="number">01</span>                addl    <span class="number">$1</span>, %eax</span><br><span class="line"><span class="number">62</span>: <span class="number">89</span> <span class="number">45</span> f8                movl    %eax, -<span class="number">8</span>(%rbp)</span><br><span class="line"><span class="comment">;  &#125; while (a &lt;= 10);</span></span><br><span class="line"><span class="number">65</span>: <span class="number">83</span> <span class="number">7d</span> f8 0a             cmpl    <span class="number">$10</span>, -<span class="number">8</span>(%rbp)     <span class="comment">; 比较a和10</span></span><br><span class="line"><span class="number">69</span>: 0f 8e ed ff ff ff       <span class="keyword">jle</span>     -<span class="number">19</span> &lt;_main+<span class="number">0x5c</span>&gt;  <span class="comment">; 当 a &lt;= 10时，将PC寄存器值改为0x5c，即跳回a+1操作</span></span><br><span class="line"><span class="comment">;  return a;</span></span><br><span class="line">6f: 8b <span class="number">45</span> f8                movl    -<span class="number">8</span>(%rbp), %eax    <span class="comment">; 将a的值复制到eax寄存器作为函数返回值</span></span><br><span class="line"><span class="number">72</span>: <span class="number">5d</span>                      popq    %rbp</span><br><span class="line"><span class="number">73</span>: c3                      retq</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="while-2"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        a += i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (a &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">        ++a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (a &lt;= <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h5 id="switch…case"><a href="#switch…case" class="headerlink" title="switch…case"></a>switch…case</h5><p>从逻辑上来讲，<code>switch...case</code>能实现的功能都可以用<code>if...else</code>替换。但是有一点区别在于，编译器会根据case的数量和值的稀疏程度，来编译优化switch语句生成不同的机器码，具体的规则为：</p>
<ul>
<li>如果<code>case分支数 &lt; 4</code>（default不算），或者<code>每两个case之间的差值 &gt; 阈值</code>，此时生成的汇编代码和if…else逻辑类似，都是对每一个条件进行<code>cmp</code>，然后<code>je/jne</code>进行跳转</li>
<li>否则，编译器会在目标文件的代码段中增加一个<code>jump table</code>。其本质上是一个数组，index对应<em>case值</em>与<em>case最小值</em>的差值，value对应<em>数组起始地址</em>与<em>case代码块起始地址</em>的差值（之所以要存相对值而非绝对值是因为指令的地址只有在加载到内存后才能确定）。通过计算switch值相对的index，取出跳转表对应的相对地址，然后jmp到代码块，实现<code>O(1)</code>时间复杂度的条件跳转，是典型的以空间换时间的优化方法。</li>
</ul>
<blockquote>
<p>switch语句适用场景</p>
<ol>
<li>判断的case条件针对<strong>同一个变量</strong>，且有确切值</li>
<li>分支较多，大于等于4个</li>
<li>case条件的值在一个较小的、连续的范围内，且跨度小于等于6</li>
</ol>
<p>if…else语句适用场景</p>
<ol>
<li>分支较少，小于4个</li>
<li>case条件值较为稀疏</li>
<li>判断的case条件<strong>不止有一个变量</strong>，或基于数值范围判断</li>
</ol>
</blockquote>
<div class="tabs" id="switch-case"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#switch-case-1">汇编代码</button></li><li class="tab"><button type="button" data-href="#switch-case-2">Jump Table</button></li><li class="tab"><button type="button" data-href="#switch-case-3">C代码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="switch-case-1"><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; void switch_demo(int x) &#123;</span></span><br><span class="line"> <span class="number">8</span>: <span class="number">89</span> <span class="number">7d</span> fc                movl    %edi, -<span class="number">4</span>(%rbp)          <span class="comment">; 将入参x的值复制到[rbp - 4, rbp]栈内存，因为rdi寄存器在调用其他函数时还要用到所以必须要把值保存到内存中</span></span><br><span class="line"><span class="comment">;  switch(x) &#123;</span></span><br><span class="line"><span class="symbol"> b:</span> 8b <span class="number">45</span> fc                movl    -<span class="number">4</span>(%rbp), %eax</span><br><span class="line"><span class="symbol"> e:</span> <span class="number">83</span> c0 fe                addl    $-<span class="number">2</span>, %eax               <span class="comment">; eax寄存器中的值-2，2为case最小值，这里是计算变量x对应跳转表的index</span></span><br><span class="line"><span class="number">11</span>: <span class="number">89</span> c1                   movl    %eax, %ecx              <span class="comment">; 将index的值写入ecx寄存器</span></span><br><span class="line"><span class="number">13</span>: <span class="number">83</span> e8 <span class="number">05</span>                subl    <span class="number">$5</span>, %eax                <span class="comment">; 将变量x减去case的最大值，如果大于0则跳转到default，无需查询跳转表</span></span><br><span class="line"><span class="number">16</span>: <span class="number">48</span> <span class="number">89</span> <span class="number">4d</span> f0             <span class="keyword">movq</span>    %rcx, -<span class="number">16</span>(%rbp)         <span class="comment">; 保存index的值到[rbp - 16, rbp - 8]栈内存</span></span><br><span class="line">1a: 0f <span class="number">87</span> 5b <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">ja</span>      <span class="number">91</span> &lt;_switch_demo+<span class="number">0x7b</span>&gt;  <span class="comment">; 无符号跳转，如果eax中的值大于0，即x - 2 - 5 &gt; 0，则修改PC寄存器的值为0x7b，即跳转到default分支</span></span><br><span class="line"><span class="number">20</span>: <span class="number">48</span> <span class="number">8d</span> <span class="number">05</span> <span class="number">69</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    leaq    <span class="number">105</span>(%rip), %rax         <span class="comment">; 将PC寄存器中的值加0x69并复制到rax寄存器，PC寄存器存的是下一条待执行指令的地址即0x27，所以rax中的值为0x90即跳转表首地址。leaq是对地址进行运算，并将计算出的地址存入目标寄存器中；movq是对地址中的数据进行计算</span></span><br><span class="line"><span class="number">27</span>: <span class="number">48</span> 8b <span class="number">4d</span> f0             <span class="keyword">movq</span>    -<span class="number">16</span>(%rbp), %rcx         <span class="comment">; 将index的值复制到rcx寄存器</span></span><br><span class="line">2b: <span class="number">48</span> <span class="number">63</span> <span class="number">14</span> <span class="number">88</span>             movslq  (%rax,%rcx,<span class="number">4</span>), %rdx     <span class="comment">; 跳转表首地址 + index * 4，这里是计算变量x对应的跳转表中的地址</span></span><br><span class="line">2f: <span class="number">48</span> <span class="number">01</span> c2                addq    %rax, %rdx              <span class="comment">; 跳转表中地址存储的值为`case代码块相对于跳转表首地址的差值`， 加上跳转表首地址后，rbx中存的即为变量x对应的case代码块首地址</span></span><br><span class="line"><span class="number">32</span>: ff e2                   jmpq    *%rdx                   <span class="comment">; 修改PC寄存器值为rdx中存的地址值</span></span><br><span class="line"><span class="comment">;          printf(&quot;Got 3&quot;);</span></span><br><span class="line"><span class="number">34</span>: <span class="number">48</span> <span class="number">8d</span> <span class="number">3d</span> <span class="number">6d</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    leaq    <span class="number">109</span>(%rip), %rdi         <span class="comment">; data段中&quot;Got 3&quot;常量对应的地址</span></span><br><span class="line">3b: b0 <span class="number">00</span>                   movb    <span class="number">$0</span>, %al</span><br><span class="line"><span class="number">3d</span>: e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          callq   <span class="number">0</span> &lt;_switch_demo+<span class="number">0x42</span>&gt;</span><br><span class="line"><span class="comment">;          break;</span></span><br><span class="line"><span class="number">42</span>: e9 <span class="number">42</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">jmp</span>     <span class="number">66</span> &lt;_switch_demo+<span class="number">0x89</span>&gt;  <span class="comment">; break跳出循环 </span></span><br><span class="line"><span class="comment">;          printf(&quot;Got 6&quot;);</span></span><br><span class="line"><span class="number">47</span>: <span class="number">48</span> <span class="number">8d</span> <span class="number">3d</span> <span class="number">60</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    leaq    <span class="number">96</span>(%rip), %rdi</span><br><span class="line">4e: b0 <span class="number">00</span>                   movb    <span class="number">$0</span>, %al</span><br><span class="line"><span class="number">50</span>: e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          callq   <span class="number">0</span> &lt;_switch_demo+<span class="number">0x55</span>&gt;</span><br><span class="line"><span class="comment">;          printf(&quot;Got 7&quot;);</span></span><br><span class="line"><span class="number">55</span>: <span class="number">48</span> <span class="number">8d</span> <span class="number">3d</span> <span class="number">58</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    leaq    <span class="number">88</span>(%rip), %rdi          <span class="comment">; go through</span></span><br><span class="line">5c: b0 <span class="number">00</span>                   movb    <span class="number">$0</span>, %al</span><br><span class="line">5e: e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          callq   <span class="number">0</span> &lt;_switch_demo+<span class="number">0x63</span>&gt;</span><br><span class="line"><span class="comment">;          break;</span></span><br><span class="line"><span class="number">63</span>: e9 <span class="number">21</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">jmp</span>     <span class="number">33</span> &lt;_switch_demo+<span class="number">0x89</span>&gt;</span><br><span class="line"><span class="comment">;          printf(&quot;Got 2 or 4&quot;);</span></span><br><span class="line"><span class="number">68</span>: <span class="number">48</span> <span class="number">8d</span> <span class="number">3d</span> 4b <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    leaq    <span class="number">75</span>(%rip), %rdi</span><br><span class="line">6f: b0 <span class="number">00</span>                   movb    <span class="number">$0</span>, %al</span><br><span class="line"><span class="number">71</span>: e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          callq   <span class="number">0</span> &lt;_switch_demo+<span class="number">0x76</span>&gt;</span><br><span class="line"><span class="comment">;          break;</span></span><br><span class="line"><span class="number">76</span>: e9 0e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">jmp</span>     <span class="number">14</span> &lt;_switch_demo+<span class="number">0x89</span>&gt;</span><br><span class="line"><span class="comment">;          printf(&quot;Got default&quot;);</span></span><br><span class="line">7b: <span class="number">48</span> <span class="number">8d</span> <span class="number">3d</span> <span class="number">43</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    leaq    <span class="number">67</span>(%rip), %rdi</span><br><span class="line"><span class="number">82</span>: b0 <span class="number">00</span>                   movb    <span class="number">$0</span>, %al</span><br><span class="line"><span class="number">84</span>: e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          callq   <span class="number">0</span> &lt;_switch_demo+<span class="number">0x89</span>&gt;</span><br><span class="line"><span class="comment">; &#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="switch-case-2"><p>小端模式，即低地址存低字节。值为补码。</p>
<table>
<thead>
<tr>
<th>index/switch值</th>
<th>asm</th>
<th>补码</th>
<th>原码</th>
<th>case代码块首地址</th>
<th>对应代码</th>
</tr>
</thead>
<tbody><tr>
<td>0/2</td>
<td>90: d8 ff ff ff</td>
<td>0xffffffd8</td>
<td>0x80000028</td>
<td>0x68</td>
<td>printf(“Got 2 or 4”);</td>
</tr>
<tr>
<td>1/3</td>
<td>94: a4 ff ff ff</td>
<td>0xffffffa4</td>
<td>0x8000005c</td>
<td>0x34</td>
<td>printf(“Got 3”);</td>
</tr>
<tr>
<td>2/4</td>
<td>98: d8 ff ff ff</td>
<td>0xffffffd8</td>
<td>0x80000028</td>
<td>0x68</td>
<td>printf(“Got 2 or 4”);</td>
</tr>
<tr>
<td>3/5</td>
<td>9c: eb ff ff ff</td>
<td>0xffffffeb</td>
<td>0x80000015</td>
<td>0x7b</td>
<td>printf(“Got default”);</td>
</tr>
<tr>
<td>4/6</td>
<td>a0: b7 ff ff ff</td>
<td>0xffffffb7</td>
<td>0x80000049</td>
<td>0x47</td>
<td>printf(“Got 6”);</td>
</tr>
<tr>
<td>5/7</td>
<td>a4: c5 ff ff ff</td>
<td>0xffffffc5</td>
<td>0x8000003b</td>
<td>0x55</td>
<td>printf(“Got 7”);</td>
</tr>
</tbody></table><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="switch-case-3"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switch_demo</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(x) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Got 3&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Got 6&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Got 7&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Got 2 or 4&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Got default&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h4 id="函数调用及栈帧"><a href="#函数调用及栈帧" class="headerlink" title="函数调用及栈帧"></a>函数调用及栈帧</h4><blockquote>
<p>上一小节分析指令跳转汇编代码时提到了函数调用、压栈相关知识，这一节重点学习下。首先思考个问题，函数A在调用函数B之前，需要保存哪些信息，保存到哪？需要传递哪些信息，如何传递？调用结束后如何恢复信息并继续执行呢？</p>
</blockquote>
<h5 id="函数栈帧起源"><a href="#函数栈帧起源" class="headerlink" title="函数栈帧起源"></a>函数栈帧起源</h5><p>如果让我来设计指令实现函数调用，最先想到的是什么方法呢？</p>
<ul>
<li>用goto能实现吗，函数B执行结束后利用goto回到函数A中调用函数B的下一条指令的地址。但是细想一下有诸多问题，如果依赖了第三方的库，我们没办法改它的源代码，也就没办法让Callee执行结束后goto回Caller继续执行，所以用goto实现不了函数调用。</li>
<li>那既然在这种场景下没办法跳回，能不能在编译时用函数B的指令替换掉函数A的call指令？这样无需跳转顺序执行即可。但是细想一下还是有问题，如果函数A调用函数B，函数B又调用了函数A，这样一直循环调用就会产生无穷无尽的替换。所以把Callee的指令直接插入到调用处这个方法也实现不了函数调用。</li>
<li>既然函数调用必须要跳回继续执行，但又不能修改被调用函数的指令，那能不能把要跳回执行的指令记录下来，然后大家约定下：比如函数调用结束后都从<code>r15</code>寄存器中取出跳回地址，继续执行就好了。但是在多层函数调用里，需要记录每一层函数的跳回地址，而CPU中的寄存器数量并不多（x86-64只有16个通用寄存器），调用层级一多就存不下了。</li>
<li>既然寄存器存不下跳回地址，那能不能把地址存到内存空间中呢？考虑到函数调用有递归的特性，即先调用的后返回，这和栈的数据结构（LIFO，Last In First Out）相同。这样我们在内存中开辟一段空间，每次函数调用之前把跳回后要继续执行的指令地址压栈，在被调用函数返回时将栈顶地址出栈，然后<code>jmp</code>跳转到对应指令地址。</li>
</ul>
<p>通过上面的推演，我们初步确定了函数调用的方法。当然在真实的程序里，需要压栈的不止有函数调用完成后的返回地址。</p>
<p>为了保证调用前后变量和函数在Caller中的相对地址不变，在函数返回时要能把Caller栈底的地址恢复到寄存器中，所以Caller的栈底地址（即<code>%rbp</code>寄存器中的值）也需要保存到栈空间。考虑到函数传参可以有很多，而寄存器个数有限，所以当参数超过6个（在<a href="#%E5%AF%84%E5%AD%98%E5%99%A8">寄存器</a>一节有讲过）后，多出的参数数据也要压入栈中（从右到左依次压入Caller栈）。那么函数的栈空间目前可以确定的结构如下：</p>
<img src="https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20210409011244.png" style="zoom:33%;">

<p>通过寄存器传递到Callee的参数值也需要保存到栈空间，以免寄存器参与之后的计算或函数调用导致其内的值被覆盖。同时局部变量在函数调用返回后还需要继续使用，所以局部变量的值也需要保存到栈空间，那么函数的栈帧空间最终就确定为：</p>
<img src="https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20210409011337.png" style="zoom:33%;">

<h5 id="汇编代码分析"><a href="#汇编代码分析" class="headerlink" title="汇编代码分析"></a>汇编代码分析</h5><blockquote>
<p>注：汇编代码使用的编译器版本为：<code>gcc version 6.3.0 20170516 (Debian 6.3.0-18+deb9u1)</code></p>
<p>汇编代码中涉及到的几个小知识，这里提前说明下</p>
<ol>
<li><code>lea</code>（Load Effective Address）是对地址进行运算，并将计算出的地址存入目标寄存器中；mov是对地址中的数据进行计算。举个例子：<code>%rbp=0x30</code>， <code>mov -0x10(%rbp),rax</code>将0x20~0x28内存地址中的数据复制到rax寄存器；<code>lea -0x10(%rbp),rax</code>将0x20这个值复制到rax寄存器</li>
<li><strong>栈地址对齐</strong>：某些型号的Intel和AMD处理器对于SSE指令，如果数据没有对齐的话，就无法正确执行。这些指令对16字节内存进行操作，在SSE单元和内存之间传送数据的指令要求内存地址必须是16的倍数。对齐的字节数可以通过gcc的<code>-mpreferred-stack-boundary</code>参数配置，取值范围为<code>4~12</code>即<code>64byte~4096byte</code></li>
</ol>
</blockquote>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000000072</span> &lt;main&gt;:</span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line"><span class="number">72</span>:  <span class="number">55</span>                <span class="keyword">push</span>   %rbp              <span class="comment">; 将上一栈帧的rbp值压栈。这里有一个疑惑：main函数不是整个函数的入口吗？难道说main也有父函数？这个谜题将在[程序链接与装载](#程序连接与装载)一节揭晓</span></span><br><span class="line"><span class="number">73</span>:  <span class="number">48</span> <span class="number">89</span> e5          <span class="keyword">mov</span>    %rsp,%rbp         <span class="comment">; 将rsp的值复制到rbp寄存器，即将rbp指向当前函数的栈底，而rsp始终会指向栈顶</span></span><br><span class="line"><span class="number">76</span>:  <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>       <span class="keyword">sub</span>    <span class="number">$0</span>x10,%rsp        <span class="comment">; 栈顶向下扩展16个字节（栈是从高地址向低地址生长的），用于存储局部变量</span></span><br><span class="line">		long x = <span class="number">10</span>, y = <span class="number">20</span><span class="comment">;</span></span><br><span class="line">7a:  <span class="number">48</span> c7 <span class="number">45</span> f8 0a <span class="number">00</span> <span class="keyword">movq</span>   <span class="number">$0</span>xa,-<span class="number">0x8</span>(%rbp)   <span class="comment">; 将栈地址[rbp-8, rbp]内存空间，即变量x赋值为10</span></span><br><span class="line"><span class="number">81</span>:  <span class="number">00</span> </span><br><span class="line"><span class="number">82</span>:  <span class="number">48</span> c7 <span class="number">45</span> f0 <span class="number">14</span> <span class="number">00</span> <span class="keyword">movq</span>   <span class="number">$0</span>x14,-<span class="number">0x10</span>(%rbp) <span class="comment">; 将栈地址[rbp-16, rbp-8]内存空间，即变量y赋值为20</span></span><br><span class="line"><span class="number">89</span>:  <span class="number">00</span> </span><br><span class="line">		x = calc(<span class="string">&#x27;l&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>, x, <span class="number">15</span>, y, y + <span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">8a:  <span class="number">48</span> 8b <span class="number">45</span> f0       <span class="keyword">mov</span>    -<span class="number">0x10</span>(%rbp),%rax  <span class="comment">; 将变量y的值复制到rax寄存器，用于后续计算y+1</span></span><br><span class="line">8e:  <span class="number">48</span> <span class="number">8d</span> <span class="number">48</span> <span class="number">01</span>       <span class="keyword">lea</span>    <span class="number">0x1</span>(%rax),%rcx    <span class="comment">; 将y+1的值复制到rcx寄存器，这里为什么用lea而不用add呢？因为rax中存储y的值还要用于后续传参，用add会改变rax中的值，这里用lea可以将运算后的值存到另一个寄存器中</span></span><br><span class="line"><span class="number">92</span>:  <span class="number">48</span> 8b <span class="number">55</span> f0       <span class="keyword">mov</span>    -<span class="number">0x10</span>(%rbp),%rdx  <span class="comment">; 将变量y的值复制到rbx寄存器</span></span><br><span class="line"><span class="number">96</span>:  <span class="number">48</span> 8b <span class="number">45</span> f8       <span class="keyword">mov</span>    -<span class="number">0x8</span>(%rbp),%rax   <span class="comment">; 将变量x的值复制到rax寄存器</span></span><br><span class="line">9a:  <span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>       <span class="keyword">sub</span>    <span class="number">$0</span>x8,%rsp         <span class="comment">; 栈顶向下扩展8个字节，用于保证栈帧的边界是16字节对齐的</span></span><br><span class="line">9e:  <span class="number">51</span>                <span class="keyword">push</span>   %rcx              <span class="comment">; 第七个参数压栈，</span></span><br><span class="line">9f:  <span class="number">49</span> <span class="number">89</span> d1          <span class="keyword">mov</span>    %rdx,%r9          <span class="comment">; r9寄存器，存第六个参数y，y的值在0x92指令中被复制到了rdx寄存器</span></span><br><span class="line"><span class="symbol">a2:</span>  <span class="number">41</span> b8 0f <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="keyword">mov</span>    <span class="number">$0</span>xf,%r8d         <span class="comment">; r8寄存器，存第五个参数15</span></span><br><span class="line"><span class="symbol">a8:</span>  <span class="number">48</span> <span class="number">89</span> c1          <span class="keyword">mov</span>    %rax,%rcx         <span class="comment">; rcx寄存器，存第四个参数x，x的值在0x96指令中被复制到了rax寄存器</span></span><br><span class="line"><span class="symbol">ab:</span>  ba <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    <span class="keyword">mov</span>    <span class="number">$0</span>x3,%edx         <span class="comment">; rdx寄存器，存第三个参数3</span></span><br><span class="line"><span class="symbol">b0:</span>  be <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    <span class="keyword">mov</span>    <span class="number">$0</span>x2,%esi         <span class="comment">; rsi寄存器，存第二个参数2</span></span><br><span class="line"><span class="symbol">b5:</span>  bf 6c <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    <span class="keyword">mov</span>    <span class="number">$0</span>x6c,%edi        <span class="comment">; rdi寄存器，存第一个参数&#x27;l&#x27;</span></span><br><span class="line"><span class="symbol">ba:</span>  e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    callq  bf &lt;main+<span class="number">0x4d</span>&gt;    <span class="comment">; 调用calc方法，call指令会把rip寄存器里的下一条指令的地址压栈，保留函数调用结束后要执行的指令地址，然后把被调函数的地址更新到rip寄存器中实现函数跳转</span></span><br><span class="line"><span class="symbol">bf:</span>  <span class="number">48</span> <span class="number">83</span> c4 <span class="number">10</span>       <span class="keyword">add</span>    <span class="number">$0</span>x10,%rsp        <span class="comment">; 栈顶向上缩减16个字节，即恢复push第七个参数+Padding的16个字节空间</span></span><br><span class="line"><span class="symbol">c3:</span>  <span class="number">48</span> <span class="number">89</span> <span class="number">45</span> f8       <span class="keyword">mov</span>    %rax,-<span class="number">0x8</span>(%rbp)   <span class="comment">; 将calc函数的返回值赋值给变量x</span></span><br><span class="line">		return x<span class="comment">;</span></span><br><span class="line"><span class="symbol">c7:</span>  <span class="number">48</span> 8b <span class="number">45</span> f8       <span class="keyword">mov</span>    -<span class="number">0x8</span>(%rbp),%rax   <span class="comment">; 将变量x的值复制到rax寄存器作为main函数的返回值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="symbol">cb:</span>  c9                leaveq                   <span class="comment">; 相当于 mov %rbp %rsp; pop %rbp，与函数开头的 push %rbp; mov %rsp, %rbp 对应。将rbp的值复制到rsp寄存器，即rsp和rbp此时都指向当前函数的栈底；将栈顶元素出栈，即上一栈帧的栈底地址赋值到rbp中，也就是将rbp指向caller的栈底</span></span><br><span class="line"><span class="symbol">cc:</span>  c3                retq                     <span class="comment">; 相当于 pop %rip，与call指令的 push %rip 对应。将栈顶元素出栈，即将返回地址的值复制到rip指令地址寄存器，以实现继续执行caller中的指令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;calc&gt;:</span><br><span class="line">long calc(char a, short b, <span class="keyword">int</span> c, long d, long e, long f, long g) &#123;</span><br><span class="line"> <span class="number">0</span>:  <span class="number">55</span>                <span class="keyword">push</span>   %rbp              <span class="comment">; 将main函数栈帧的rbp值压栈</span></span><br><span class="line"> <span class="number">1</span>:  <span class="number">48</span> <span class="number">89</span> e5          <span class="keyword">mov</span>    %rsp,%rbp         <span class="comment">; main函数解释过了</span></span><br><span class="line"> <span class="number">4</span>:  <span class="number">48</span> <span class="number">83</span> ec <span class="number">40</span>       <span class="keyword">sub</span>    <span class="number">$0</span>x40,%rsp        <span class="comment">;	栈顶向下扩展64个字节，用于存储局部变量和寄存器中的值</span></span><br><span class="line"> <span class="number">8</span>:  <span class="number">89</span> f0             <span class="keyword">mov</span>    %esi,%eax         <span class="comment">; 6个用于传参的寄存器值按顺序压栈</span></span><br><span class="line"><span class="symbol"> a:</span>  <span class="number">89</span> <span class="number">55</span> e4          <span class="keyword">mov</span>    %edx,-<span class="number">0x1c</span>(%rbp)</span><br><span class="line"><span class="symbol"> d:</span>  <span class="number">48</span> <span class="number">89</span> <span class="number">4d</span> d8       <span class="keyword">mov</span>    %rcx,-<span class="number">0x28</span>(%rbp)</span><br><span class="line"><span class="number">11</span>:  4c <span class="number">89</span> <span class="number">45</span> d0       <span class="keyword">mov</span>    %r8,-<span class="number">0x30</span>(%rbp)</span><br><span class="line"><span class="number">15</span>:  4c <span class="number">89</span> <span class="number">4d</span> c8       <span class="keyword">mov</span>    %r9,-<span class="number">0x38</span>(%rbp)</span><br><span class="line"><span class="number">19</span>:  <span class="number">40</span> <span class="number">88</span> <span class="number">7d</span> ec       <span class="keyword">mov</span>    %dil,-<span class="number">0x14</span>(%rbp)</span><br><span class="line"><span class="number">1d</span>:  <span class="number">66</span> <span class="number">89</span> <span class="number">45</span> e8       <span class="keyword">mov</span>    %ax,-<span class="number">0x18</span>(%rbp)</span><br><span class="line">		srand(time(NULL))<span class="comment">;</span></span><br><span class="line"><span class="number">21</span>:  bf <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    <span class="keyword">mov</span>    <span class="number">$0</span>x0,%edi         <span class="comment">; rdi寄存器赋值为0，对应NULL</span></span><br><span class="line"><span class="number">26</span>:  e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    callq  2b &lt;calc+<span class="number">0x2b</span>&gt;</span><br><span class="line">2b:  <span class="number">89</span> c7             <span class="keyword">mov</span>    %eax,%edi</span><br><span class="line"><span class="number">2d</span>:  e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    callq  <span class="number">32</span> &lt;calc+<span class="number">0x32</span>&gt;</span><br><span class="line">		<span class="keyword">int</span> h = rand()<span class="comment">;</span></span><br><span class="line"><span class="number">32</span>:  e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    callq  <span class="number">37</span> &lt;calc+<span class="number">0x37</span>&gt;</span><br><span class="line"><span class="number">37</span>:  <span class="number">89</span> <span class="number">45</span> fc          <span class="keyword">mov</span>    %eax,-<span class="number">0x4</span>(%rbp)   <span class="comment">; rand函数返回值赋值到栈地址[rbp - 4, rbp]</span></span><br><span class="line">		return a + b + c + d + e + f + g + h<span class="comment">;</span></span><br><span class="line">3a:  0f be <span class="number">55</span> ec       movsbl -<span class="number">0x14</span>(%rbp),%edx  <span class="comment">; 将变量a的值1字节带符号扩展成4字节，并存到rdx寄存器</span></span><br><span class="line">3e:  0f bf <span class="number">45</span> e8       movswl -<span class="number">0x18</span>(%rbp),%eax  <span class="comment">; 将变量b的值2字节带符号扩展成4字节，并存到rax寄存器</span></span><br><span class="line"><span class="number">42</span>:  <span class="number">01</span> c2             <span class="keyword">add</span>    %eax,%edx         <span class="comment">; rdx = rax + rdx</span></span><br><span class="line"><span class="number">44</span>:  8b <span class="number">45</span> e4          <span class="keyword">mov</span>    -<span class="number">0x1c</span>(%rbp),%eax  <span class="comment">; 将变量c的值复制到rax寄存器</span></span><br><span class="line"><span class="number">47</span>:  <span class="number">01</span> d0             <span class="keyword">add</span>    %edx,%eax         <span class="comment">; rax = rdx + rax</span></span><br><span class="line"><span class="number">49</span>:  <span class="number">48</span> <span class="number">63</span> d0          movslq %eax,%rdx         <span class="comment">; 将rax中的4字节带符号扩展成8字节，并存到rdx寄存器</span></span><br><span class="line">4c:  <span class="number">48</span> 8b <span class="number">45</span> d8       <span class="keyword">mov</span>    -<span class="number">0x28</span>(%rbp),%rax  <span class="comment">; 将变量d的值复制到rax寄存器</span></span><br><span class="line"><span class="number">50</span>:  <span class="number">48</span> <span class="number">01</span> c2          <span class="keyword">add</span>    %rax,%rdx         <span class="comment">; rdx = rax + rdx</span></span><br><span class="line"><span class="number">53</span>:  <span class="number">48</span> 8b <span class="number">45</span> d0       <span class="keyword">mov</span>    -<span class="number">0x30</span>(%rbp),%rax  <span class="comment">; 将变量e的值复制到rax寄存器</span></span><br><span class="line"><span class="number">57</span>:  <span class="number">48</span> <span class="number">01</span> c2          <span class="keyword">add</span>    %rax,%rdx         <span class="comment">; rdx = rax + rdx</span></span><br><span class="line">5a:  <span class="number">48</span> 8b <span class="number">45</span> c8       <span class="keyword">mov</span>    -<span class="number">0x38</span>(%rbp),%rax  <span class="comment">; 将变量f的值复制到rax寄存器</span></span><br><span class="line">5e:  <span class="number">48</span> <span class="number">01</span> c2          <span class="keyword">add</span>    %rax,%rdx         <span class="comment">; rdx = rax + rdx</span></span><br><span class="line"><span class="number">61</span>:  <span class="number">48</span> 8b <span class="number">45</span> <span class="number">10</span>       <span class="keyword">mov</span>    <span class="number">0x10</span>(%rbp),%rax   <span class="comment">; 将变量g的值（在caller的栈帧中）复制到rax寄存器</span></span><br><span class="line"><span class="number">65</span>:  <span class="number">48</span> <span class="number">01</span> c2          <span class="keyword">add</span>    %rax,%rdx         <span class="comment">; rdx = rax + rdx</span></span><br><span class="line"><span class="number">68</span>:  8b <span class="number">45</span> fc          <span class="keyword">mov</span>    -<span class="number">0x4</span>(%rbp),%eax   <span class="comment">; 将局部变量h的值复制到eax寄存器</span></span><br><span class="line">6b:  <span class="number">48</span> <span class="number">98</span>             cltq                     <span class="comment">; 将eax的值带符号扩展成8字节存到rax寄存器</span></span><br><span class="line"><span class="number">6d</span>:  <span class="number">48</span> <span class="number">01</span> d0          <span class="keyword">add</span>    %rdx,%rax         <span class="comment">; rax = rbx + rax</span></span><br><span class="line"></span><br><span class="line"><span class="number">70</span>:  c9                leaveq                   <span class="comment">; main函数解释过了</span></span><br><span class="line"><span class="number">71</span>:  c3                retq                     <span class="comment">; main函数解释过了</span></span><br></pre></td></tr></table></figure>

<h5 id="x86-64常用指令"><a href="#x86-64常用指令" class="headerlink" title="x86_64常用指令"></a>x86_64常用指令</h5><h5 id="相关知识延展"><a href="#相关知识延展" class="headerlink" title="相关知识延展"></a>相关知识延展</h5><h6 id="函数内联优劣"><a href="#函数内联优劣" class="headerlink" title="函数内联优劣"></a>函数内联优劣</h6><p>如果被调函数中没有再调用其他函数（这种函数通常被称为叶子函数），可以通过将被调函数指令直接替换到调用处来实现函数调用的。这也是常见的编译器自动优化的手段，叫做<strong>函数内联（Inline）</strong>。除了靠编译器自动优化，也可以在函数定义前加上inline关键字，来提示编译器对函数进行内联。</p>
<p>我们来看一段代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="type">int</span> x = rand() % <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> y = rand() % <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">return</span> add(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>gcc -O</code>编译出来的汇编代码，并没有把add函数单独编译成一段指令顺序，而是在调用<code>add(x, y)</code>的时候，直接替换成了一个add指令</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">      <span class="number">6d</span>: <span class="number">01</span> c8                         addl    %ecx, %eax</span><br><span class="line"><span class="comment">;     return a + b;</span></span><br><span class="line">      6f: <span class="number">01</span> d8                         addl    %ebx, %eax</span><br></pre></td></tr></table></figure>

<p>内联可以减少函数调用过程中保存寄存器值，数据压栈出栈等开销，提升调用性能。</p>
<p>不过这也是有代价的，内联把可以复用的指令在调用它的地方完全展开了，这就会导致程序的代码段指令数增加，占用空间变大。</p>
<h6 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a>Stack Overflow</h6><p>一般是由于递归调用，或调用链过深，或在栈空间里创建非常占内存的变量（比如一个巨大的数组）导致的。</p>
<ol>
<li>Linux：默认栈空间大小为8MiB，在task_struct创建时（Linux不区分进程和线程）alloc并memset为0，具体代码见<a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/kernel/fork.c.html#alloc_thread_stack_node">alloc_thread_stack_node</a>。</li>
<li>JVM：默认栈空间大小为1MiB，可以由<code>-Xss</code>指定</li>
<li>Go：goroutine初始栈空间大小为2Kib，上限取决于操作系统位数，<a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/golang/go/blob/f296b7a6f045325a230f77e9bda1470b1270f817/src/runtime/proc.go#L120">64位为1GiB，32位为250MiB</a></li>
<li>Python：没有限制栈空间，不过有最大递归调用次数限制，可以通过<code>sys.getrecursionlimit()</code>获取，默认为1000</li>
</ol>
<h6 id="栈溢出攻击"><a href="#栈溢出攻击" class="headerlink" title="栈溢出攻击"></a>栈溢出攻击</h6><blockquote>
<p>栈溢出利用程序的漏洞，通过构造精心设计的数据，来覆盖函数的返回地址，进而打乱原有函数执行流程，跳入黑客预先设计好的恶意代码中。</p>
</blockquote>
<p>栈溢出攻击基于以下几个原理：</p>
<ol>
<li>函数栈帧保存了函数调用返回后下一条待执行指令的内存地址</li>
<li>程序的代码和数据都在内存中，直接从内存的二进制形式上是无法区分哪些是数据哪些是代码</li>
<li>局部变量存储在栈中，如果局部变量是一个数组，那么通过构造一个溢出当前栈帧的数据，就有可能覆盖上一栈帧的函数返回地址，进而跳转执行恶意代码</li>
</ol>
<p>例如下面这段代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">counter</span><span class="params">(<span class="type">char</span> *data, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buffer[BUF_LEN];</span><br><span class="line">  <span class="built_in">strcpy</span>(buffer, data);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是一个典型的栈溢出代码，使用了不安全的<code>strcpy</code>函数，系统会盲目的将data的全部数据拷贝到栈空间的buffer上，而buffer的长度是有限的，一旦data的数据长度超过BUF_LEN，就会产生栈溢出。</p>
<img src="https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20210409011416.png" style="zoom: 33%;">

<p>基本原理就如上图所示，但实际上直接修改函数返回地址将其指向恶意代码是很难实现的，因为操作系统每次加载可执行文件到进程空间的位置都不是固定的，因此栈的位置实际是不固定的。为了解决这个问题，有了通过跳板(<code>jmp esp</code>)进行栈溢出的方式，这里就不展开了，感兴趣的可以看<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.jianshu.com/p/47d484b9227e">这篇文章</a>。</p>
<blockquote>
<p> 栈溢出攻击的防护</p>
</blockquote>
<ol>
<li>栈不可执行：利用cpu硬件的特性，将栈设置为不可执行，禁止执行栈上的数据</li>
<li>栈保护：编译时打开栈保护开关，则会在函数的进入和返回的地方增加一些检测指令，在数据被修改时终止程序运行</li>
<li>内存布局随机化：将程序的加载位置、堆栈位置以及动态链接库的映射位置随机化</li>
</ol>
<h6 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h6><p>尾递归是指在一个方法内部，递归调用后直接return，没有任何多余的指令。从函数栈帧角度来想，当前栈帧的所有数据在发生递归调用后都已经无用了，此时就无需将其保存到当前栈帧，只需将参数存入指定寄存器，goto到函数开始的指令继续执行就好了。</p>
<p>比如下面这种求阶乘的写法就不是一个尾递归，因为函数调用结束后还要拿到结果计算乘法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而改写成下面这种写法就可以进行尾递归优化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> sum + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, sum + n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="协程的函数栈切换"><a href="#协程的函数栈切换" class="headerlink" title="协程的函数栈切换"></a>协程的函数栈切换</h6><h4 id="从CPU指令层面理解一些问题"><a href="#从CPU指令层面理解一些问题" class="headerlink" title="从CPU指令层面理解一些问题"></a>从CPU指令层面理解一些问题</h4><h5 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h5><h5 id="混淆编译"><a href="#混淆编译" class="headerlink" title="混淆编译"></a>混淆编译</h5><h5 id="Compare-And-Swap原子操作"><a href="#Compare-And-Swap原子操作" class="headerlink" title="Compare And Swap原子操作"></a>Compare And Swap原子操作</h5><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://dslztx.github.io/blog/2020/01/14/CAS/">https://dslztx.github.io/blog/2020/01/14/CAS/</a></p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://dslztx.github.io/blog/2019/06/08/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%9A%84LOCK%E6%8C%87%E4%BB%A4%E5%89%8D%E7%BC%80/">https://dslztx.github.io/blog/2019/06/08/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%9A%84LOCK%E6%8C%87%E4%BB%A4%E5%89%8D%E7%BC%80/</a></p>
<h5 id="超线程-hyperthreading"><a href="#超线程-hyperthreading" class="headerlink" title="超线程 hyperthreading"></a>超线程 hyperthreading</h5><blockquote>
<p>现代CPU一般声称有4核8线程、8核16线程等，这是什么意思呢？</p>
</blockquote>
<p>考虑到CPU同内存、IO设备之间存取速度的严重不匹配，出现了乱序执行、分支预测等优化让CPU利用数据装载等待的时间，尽量多的执行后面的指令。但是某些指令必须要等到数据加载完成才能执行，比如数值求和比较等，此时CPU仍有大量空闲时间浪费。</p>
<p>为了提高CPU的利用率，聪明的工程师们想到了在CPU中额外增加一组寄存器，这样可以不覆盖当前线程的寄存器数据，同时执行另一个线程的指令，最大程度的利用计算单元，在可控的成本内（没有增加ALU等运算单元）提升了CPU利用率，这就是超线程。</p>
<h5 id="有趣的优化"><a href="#有趣的优化" class="headerlink" title="有趣的优化"></a>有趣的优化</h5><ol>
<li><p>为什么将循环求和的结果放到一个局部变量中，会比将其放到一个通过指针传递过来的参数中，运行起来更快呢？</p>
<ol>
<li>放到局部变量相当于将结果保存在<code>rax</code>寄存器中；而放到指针传递过来的参数相当于每次都要先根据内存地址读取上一个栈帧中的内存数据到寄存器，求和之后再把寄存器的值保存回内存中。CPU操作寄存器相比于内存耗时不在一个量级。</li>
</ol>
</li>
<li></li>
</ol>
<h3 id="CPU运算"><a href="#CPU运算" class="headerlink" title="CPU运算"></a>CPU运算</h3><h4 id="算术逻辑单元（ALU-Arithmetic-Logic-Unit）"><a href="#算术逻辑单元（ALU-Arithmetic-Logic-Unit）" class="headerlink" title="算术逻辑单元（ALU Arithmetic Logic Unit）"></a>算术逻辑单元（ALU Arithmetic Logic Unit）</h4><h5 id="门电路"><a href="#门电路" class="headerlink" title="门电路"></a>门电路</h5><img src="https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20210402014630.png" style="zoom: 33%;">

<p>异或：<code>A XOR B = (A &amp; ~B) | (~A &amp; B)</code></p>
<img src="https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20210402014901.png" style="zoom:33%;">

<h5 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h5><p>二进制的加法与十进制加法本质上并无差异，只不过二进制是逢2进1。拿个位举例，有4种组合，00/01/10/11，00和11个位相加的结果为0，01和10个位相加结果为1，这个输入和输出的关系就是<em>异或门</em>计算逻辑；同时对于11相加后需要向上一位进位，也就是<em>与门</em>计算逻辑。</p>
<p>所以通过一个异或门计算出个位，通过一个与门计算出是否进位，就通过电路算出了一个一位数的加法。</p>
<img src="https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20210409011059.png" style="zoom:33%;">

<p>之所以叫半加器是因为这里只能处理个位加法，对于二位的加法除了加数和被加数之外，还要加上来自个位的进位信号，一共需要3个bit进行相加。要想实现3个数相加，可以通过组合2个半加器和1个或门组成一个<em>全加器</em>。</p>
<img src="https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20210409014052.png" style="zoom:33%;">

<h6 id="加法器优化"><a href="#加法器优化" class="headerlink" title="加法器优化"></a>加法器优化</h6><h5 id="乘法器"><a href="#乘法器" class="headerlink" title="乘法器"></a>乘法器</h5><h5 id="减法运算"><a href="#减法运算" class="headerlink" title="减法运算"></a>减法运算</h5><h6 id="为什么减法器效率低"><a href="#为什么减法器效率低" class="headerlink" title="为什么减法器效率低"></a>为什么减法器效率低</h6><h6 id="为什么负数的补码要按位取反并加1？"><a href="#为什么负数的补码要按位取反并加1？" class="headerlink" title="为什么负数的补码要按位取反并加1？"></a>为什么负数的补码要按位取反并加1？</h6><h5 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h5><h4 id="提升CPU利用率"><a href="#提升CPU利用率" class="headerlink" title="提升CPU利用率"></a>提升CPU利用率</h4><h5 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h5><h5 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h5><p>好处：可以充分利用CPU，在等待内存操作返回的同时，执行其他指令</p>
<h5 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h5><h6 id="Linux中的likely-unlikely"><a href="#Linux中的likely-unlikely" class="headerlink" title="Linux中的likely/unlikely"></a>Linux中的<code>likely/unlikely</code></h6><h5 id="并行计算：SIMD"><a href="#并行计算：SIMD" class="headerlink" title="并行计算：SIMD"></a>并行计算：SIMD</h5><h5 id="一些有趣小🌰"><a href="#一些有趣小🌰" class="headerlink" title="一些有趣小🌰"></a>一些有趣小🌰</h5><ul>
<li>找出一个数组中小于某数x的个数。排序后的数组运行更快</li>
<li>两个for循环嵌套，循环次数多的写里面</li>
</ul>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h4 id="MMU与TLB"><a href="#MMU与TLB" class="headerlink" title="MMU与TLB"></a>MMU与TLB</h4><h4 id="M-Modified-E-Exclusive-S-Shared-I-Invalid-协议"><a href="#M-Modified-E-Exclusive-S-Shared-I-Invalid-协议" class="headerlink" title="M(Modified) E(Exclusive) S(Shared) I(Invalid)协议"></a>M(Modified) E(Exclusive) S(Shared) I(Invalid)协议</h4><p>缓存行有4种不同的状态</p>
<ol>
<li><strong>已修改Modified（M）：</strong>缓存行是脏的，与主存的值不同。如果别的CPU内核要读主存这块数据，该缓存行必须回写到主存，状态变为共享（S）</li>
<li><strong>独占Exclusive（E）：</strong>缓存行只在当前缓存中，而且与主存值相同。当别的缓存读取它时，状态变为共享；当前写数据时，变为已修改状态</li>
<li><strong>共享Shared（S）：</strong>缓存行也存在与其他缓存中且是干净的，缓存行可以在任意时刻抛弃</li>
<li><strong>无效Invalid（I）：</strong>缓存行是无效的</li>
</ol>
<p><img src="https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20211017180553.png"></p>
<p>上图为4中状态间的有限状态机转换，有两种场景会触发状态的转换：</p>
<ol>
<li>缓存所在CPU的读写（上图中左半部黑实线）<ol>
<li>PrRd：处理器请求读一个缓存块</li>
<li>PrWr：处理器请求写一个缓存块</li>
</ol>
</li>
<li>其他CPU的读写，通过总线发送信号，然后被其他总线snooper嗅探到（上图中右半部红虚线）<ol>
<li>BusRd：嗅探到其他处理器请求<strong>读</strong>一个缓存块</li>
<li>BusRdX：嗅探到其他处理器请求<strong>写</strong>一个该处理器<strong>不拥有</strong>的缓存块</li>
<li>BusUpgr：嗅探到其他处理器请求<strong>写</strong>一个该处理器<strong>拥有的</strong>缓存块</li>
<li>Flush：snooper请求<strong>回写</strong>整个缓存到主存</li>
<li>FlushOpt：snooper请求将整个缓存块发送到另一个处理器（缓存到缓存的赋复制）</li>
</ol>
</li>
</ol>
<h4 id="CacheLine与伪共享"><a href="#CacheLine与伪共享" class="headerlink" title="CacheLine与伪共享"></a>CacheLine与伪共享</h4><p>一个CacheLine包含：标识位、和内存匹配tag、数据块。其中标识位包含：V（Valid）表示这个缓存块是否被使用，M（Modified）表示这个缓存块是否被写过。数据块大小一般为64Byte。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># getconf -a | grep CACHE</span><br><span class="line"></span><br><span class="line">LEVEL1_ICACHE_SIZE                 32768</span><br><span class="line">LEVEL1_ICACHE_ASSOC                8</span><br><span class="line">LEVEL1_ICACHE_LINESIZE             64</span><br><span class="line">LEVEL1_DCACHE_SIZE                 32768</span><br><span class="line">LEVEL1_DCACHE_ASSOC                8</span><br><span class="line">LEVEL1_DCACHE_LINESIZE             64</span><br><span class="line">LEVEL2_CACHE_SIZE                  2097152</span><br><span class="line">LEVEL2_CACHE_ASSOC                 8</span><br><span class="line">LEVEL2_CACHE_LINESIZE              64</span><br><span class="line">LEVEL3_CACHE_SIZE                  16777216</span><br><span class="line">LEVEL3_CACHE_ASSOC                 16</span><br><span class="line">LEVEL3_CACHE_LINESIZE              64</span><br><span class="line">LEVEL4_CACHE_SIZE                  0</span><br><span class="line">LEVEL4_CACHE_ASSOC                 0</span><br><span class="line">LEVEL4_CACHE_LINESIZE              0</span><br></pre></td></tr></table></figure>

<p>L1 数据Cache大小为32K，包含32 * 1024 / 64 = 512个CacheLine，标识为和tag有专门的电路，不占用缓存块的空间。</p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://itimetraveler.github.io/2018/09/09/CPU%20Cache%E4%B8%8E%E7%BC%93%E5%AD%98%E8%A1%8C/">https://itimetraveler.github.io/2018/09/09/CPU%20Cache%E4%B8%8E%E7%BC%93%E5%AD%98%E8%A1%8C/</a></p>
<h3 id="存储与I-O设备"><a href="#存储与I-O设备" class="headerlink" title="存储与I/O设备"></a>存储与I/O设备</h3><h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><h4 id="INT中断"><a href="#INT中断" class="headerlink" title="INT中断"></a>INT中断</h4><ul>
<li>地址总线、数据总线  </li>
<li>ext3/ext4文件系统</li>
</ul>
<h3 id="为什么ARM架构在移动互联网时代大行其道"><a href="#为什么ARM架构在移动互联网时代大行其道" class="headerlink" title="为什么ARM架构在移动互联网时代大行其道"></a>为什么ARM架构在移动互联网时代大行其道</h3><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul>
<li>FUTEX(Fast Userspace muTEX)系统调用</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h4><h5 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h5><h5 id="小对象分配"><a href="#小对象分配" class="headerlink" title="小对象分配"></a>小对象分配</h5><h4 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h4><h5 id="页表布局"><a href="#页表布局" class="headerlink" title="页表布局"></a>页表布局</h5><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/lorenzo-stoakes/linux-vm-notes/blob/master/sections/page-tables.md">https://github.com/lorenzo-stoakes/linux-vm-notes/blob/master/sections/page-tables.md</a></p>
<p>Linux中有4级页表，每级由<code>pXXval_t</code>包装而成的 <code>pXX_t</code>类型的数组组成</p>
<ol>
<li>Page Global Directory (PGD)</li>
<li>Page Upper Directory (PUD)</li>
<li>Page Middle Directory (PMD)</li>
<li>Page Table Entry Directory (PTE)</li>
</ol>
<p>这些类型的具体定义取决于不同的arch，比如在x86架构下的定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>   <span class="type">pgdval_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>   <span class="type">pudval_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>   <span class="type">pmdval_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>   <span class="type">pteval_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">pgdval_t</span> pgd; &#125; <span class="type">pgd_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">pudval_t</span> pud; &#125; <span class="type">pud_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">pmdval_t</span> pmd; &#125; <span class="type">pmd_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">pteval_t</span> pte; &#125; <span class="type">pte_t</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>p[gum]d_t</code>结构定义在<a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/arch/x86/include/asm/pgtable_types.h.html">arch/x86/include/asm/pgtable_types.h</a>中，而<code>pte_t</code>和<code>pXXval_t</code>类型定义在<a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/arch/x86/include/asm/pgtable_64_types.h.html">arch/x86/include/asm/pgtable_64_types.h</a>中，通过宏定义在<code>pgtable_types</code>文件中被include，这样是为了尽量复用32和64位x86代码。</p>
</li>
<li><p>在64位x86架构，以及4KB页大小情况下，每个PGD/PUD/PMD/PTE页表均包含512个指针，指向下一级页表的地址，每个指针8byte，即每个页表占用4KB内存空间，刚好一个内存页。每个页表可包含的指针个数使用宏定义<code>PTRS_PER_XXX</code>，例如<a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/arch/x86/include/asm/pgtable_64_types.h.html#_M/PTRS_PER_PGD">PTRS_PER_PGD</a>，<a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/arch/x86/include/asm/pgtable_64_types.h.html#_M/PTRS_PER_PTE">PTRS_PER_PTE</a></p>
</li>
<li><p>虚拟地址对应的每个页表的下标需要先通过<code>&gt;&gt;</code>然后<code>&amp; MASK</code>计算得出</p>
<ul>
<li>右移位数：<code>PGDIR_SHIFT=39, PUD_SHIFT=30, PMD_SHIFT=21, PAGE_SHIFT=12</code></li>
<li>MASK：以<code>PTRS_PER_XXX - 1</code>为掩码，将所有高于第9位的位全部置0</li>
</ul>
</li>
<li><p>计算每个页表的index被定义成了inline函数，比如下面这个计算pte在pmd中的index的方法</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">pte_index</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (address &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过页表基地址+index可以获得下一级页表的基地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pte_t</span> *<span class="title function_">pte_offset_kernel</span><span class="params">(<span class="type">pmd_t</span> *pmd, <span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">pte_t</span> *)pmd_page_vaddr(*pmd) + pte_index(address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>PGD的虚拟基地址存储在每个进程的<a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/include/linux/mm_types.h.html#mm_struct::(anonymous)::pgd">struct mm_struct-&gt;pgd</a>字段中，对应的物理地址存储在CR3寄存器中，并随着进程切换而改变</li>
<li>依次调用<a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/arch/x86/include/asm/pgtable.h.html#1003">pgd_offset_k</a> -&gt; <a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/arch/x86/include/asm/pgtable.h.html#pud_offset">pud_offset</a> -&gt; <a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/arch/x86/include/asm/pgtable.h.html#pmd_offset">pmd_offset</a> -&gt; <a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/arch/x86/include/asm/pgtable.h.html#pte_offset_kernel">pte_offset_kernel</a>来查找页表项的虚拟地址，流程图如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000000000</span> <span class="number">000000010</span> <span class="number">000000101</span> <span class="number">000000110</span> <span class="number">100100101</span> <span class="number">000000100100</span></span><br><span class="line">[   RESERVED   ] [  PGD  ] [  PUD  ] [  PMD  ] [  PTE  ] [  OFFSET  ]</span><br><span class="line"></span><br><span class="line">PGD offset =    <span class="number">000000010</span> = <span class="number">2</span></span><br><span class="line">PUD offset =    <span class="number">000000101</span> = <span class="number">5</span></span><br><span class="line">PMD offset =    <span class="number">000000110</span> = <span class="number">6</span></span><br><span class="line">PTE offset =    <span class="number">100100101</span> = <span class="number">293</span></span><br><span class="line">phy offset = <span class="number">000000100100</span> = <span class="number">36</span></span><br><span class="line"></span><br><span class="line">         PGD</span><br><span class="line">        -----   </span><br><span class="line">      <span class="number">0</span> |   |         PUD</span><br><span class="line">      . |   |        -----   </span><br><span class="line">      <span class="number">2</span> |~~~|-----&gt;<span class="number">0</span> |   |   </span><br><span class="line">      . |   |      . |   |         PMD</span><br><span class="line">      . |   |      . |   |        -----   </span><br><span class="line">      . |   |      <span class="number">5</span> |~~~|-----&gt;<span class="number">0</span> |   |   </span><br><span class="line">      . |   |      . |   |      . |   |         PTE</span><br><span class="line">      . |   |      . |   |      . |   |        -----   </span><br><span class="line">    <span class="number">512</span> -----      . |   |      <span class="number">6</span> |~~~|-----&gt;<span class="number">0</span> |   |   </span><br><span class="line">                   . |   |      . |   |      . |   |   </span><br><span class="line">                 <span class="number">512</span> -----      . |   |      . |   |   </span><br><span class="line">                                . |   |      . |   |   </span><br><span class="line">                                . |   |      . |   |     physical page</span><br><span class="line">                              <span class="number">512</span> -----      . |   |        -----</span><br><span class="line">                                           <span class="number">293</span> |~~~|-----&gt;<span class="number">0</span> |   |</span><br><span class="line">                                             . |   |      . |   |</span><br><span class="line">                                           <span class="number">512</span> -----     <span class="number">36</span> | h |</span><br><span class="line">                                                          . | e |</span><br><span class="line">                                                          . | l |</span><br><span class="line">                                                          . | l |</span><br><span class="line">                                                          . | o |</span><br><span class="line">                                                         <span class="number">41</span> | ! |</span><br><span class="line">                                                          . |   |</span><br><span class="line">                                                        <span class="number">4096</span>-----</span><br></pre></td></tr></table></figure>

<h5 id="Page-Table-Entry-Flags"><a href="#Page-Table-Entry-Flags" class="headerlink" title="Page Table Entry Flags"></a>Page Table Entry Flags</h5><ul>
<li>由于每个页目录项是页对齐的，所以每个页表首地址的低<code>PAGE_SHIFT</code>位都是0，也就是说<code>PGD/PUD/PMD/PTE</code>中指针的值低<code>PAGE_SHIFT</code>位是没用到的，这样就可以将这些位作为标志位存储page的配置信息。另外在x86-64架构中，只有46个可寻址位，所以不参与寻址的高位也可以存储标志位</li>
<li>这样做的影响是：计算页目录index时需要忽略标志位。在页大小为4KB情况下，是通过<a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/arch/x86/include/asm/pgtable_types.h.html#_M/PTE_PFN_MASK">PTE_PFN_MASK</a>和<a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/arch/x86/include/asm/pgtable_types.h.html#_M/PTE_FLAGS_MASK">PTE_FLAGS_MASK</a>两个宏定义计算的。更大的页大小需要些特殊处理，这里先不赘述了，会在[Huge Page](#Huge Page)一节详述。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PAGE_MASK = ~((<span class="number">1UL</span> &lt;&lt; <span class="number">12</span>) - <span class="number">1</span>) = </span><br><span class="line"><span class="number">1111111111111111111111111111111111111111111111111111000000000000</span></span><br><span class="line"></span><br><span class="line">__PHYSICAL_MASK = ((<span class="number">1UL</span> &lt;&lt; <span class="number">52</span>) - <span class="number">1</span>) = </span><br><span class="line"><span class="number">0000000000001111111111111111111111111111111111111111111111111111</span></span><br><span class="line"></span><br><span class="line">PTE_PFN_MASK = PAGE_MASK &amp; __PHYSICAL_MASK = </span><br><span class="line"><span class="number">1111111111111111111111111111111111111111111111111111000000000000</span></span><br><span class="line"><span class="number">0000000000001111111111111111111111111111111111111111111111111111</span> = </span><br><span class="line"><span class="number">0000000000001111111111111111111111111111111111111111000000000000</span></span><br><span class="line"></span><br><span class="line">PTE_FLAGS_MASK = ~PTE_PFN_MASK =</span><br><span class="line"><span class="number">1111111111110000000000000000000000000000000000000000111111111111</span></span><br><span class="line">  </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pteval_t</span> pte_flags(<span class="type">pte_t</span> pte)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> native_pte_val(pte) &amp; PTE_FLAGS_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这些额外的标志位用于表示页表项中的页的各种状态，有一点需要弄清楚：PGD中的 <code>pdg_t</code>条目的标志位代表的是其指向的PUD页的状态，所以每一个<code>pXX_t</code>条目的标志位实际上表示的是下一级<code>PXX</code>页的状态</li>
<li>标志位的取值通过<code>(pXX_FLAGS_MASK &amp; pXX_val) &amp; (((pteval_t)1) &lt;&lt; FLAG_OFFSET)</code>计算，比如<code>pte_write = pte_flags(pte) &amp; (1UL &lt;&lt; 1)</code></li>
<li>一些常用的标志位含义（全部定义可见<a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/arch/">arch</a>/<a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/arch/x86/">x86</a>/<a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/arch/x86/include/">include</a>/<a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/arch/x86/include/asm/">asm</a>/<a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/arch/x86/include/asm/pgtable_types.h.html">pgtable_types.h</a>）<ul>
<li><code>_PAGE_PRESENT</code>: 用于确定页在内存中是否可用，还是由于页换出或其他原因导致不可用</li>
<li><code>_PAGE_RW</code>: 如果清除该标志，则内存页是只读的（常用语Copy On Write）</li>
<li><code>_PAGE_USER</code>: 如果清除该标志，则只有内核态能访问内存页</li>
<li><code>_PAGE_ACCESSED</code>: 页面已被访问，如果在创建页面时将其清除，则对该页面的首次访问将设置该标志，并且该标志将保持设置状态，直到手动清除为止</li>
<li><code>_PAGE_DIRTY</code>: 页面已被修改，如果在创建页面时将其清除，则对该页面的首次写入将设置该标志，并且该标志将保持设置状态，直到手动清除为止</li>
<li><code>_PAGE_PSE</code>: 为1则表示该页是一个Huge Page，即1GB或2MB而不是4KB</li>
<li><code>_PAGE_GLOBAL</code>: 为1则表示普通的TLB缓存刷新不会驱逐该页</li>
</ul>
</li>
</ul>
<h5 id="PGD与进程切换"><a href="#PGD与进程切换" class="headerlink" title="PGD与进程切换"></a>PGD与进程切换</h5><h5 id="Huge-Page"><a href="#Huge-Page" class="headerlink" title="Huge Page"></a>Huge Page</h5><h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><h2 id="程序链接与装载"><a href="#程序链接与装载" class="headerlink" title="程序链接与装载"></a>程序链接与装载</h2><ol>
<li>Preprocess -&gt; Compile -&gt; Assemble -&gt; Link</li>
</ol>
<h3 id="库打桩机制"><a href="#库打桩机制" class="headerlink" title="库打桩机制"></a>库打桩机制</h3><ul>
<li>编译时打桩：利用编译器的<code>-I</code>参数，以及宏定义，在编译时将目标函数的声明替换掉。典型的应用有：<ul>
<li>Redis中根据不同的编译参数选择使用不同的内存分配器，并将<code>malloc</code>, <code>free</code>等函数利用宏定义替换成不同内存分配器的函数声明，比如<code>je_malloc</code>, <code>je_free</code></li>
</ul>
</li>
<li>链接时打桩</li>
<li>运行时打桩</li>
</ul>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="链接的接口——符号"><a href="#链接的接口——符号" class="headerlink" title="链接的接口——符号"></a>链接的接口——符号</h4><ul>
<li><p>C++中namespace与函数重载在符号表中的体现：编译器根据函数签名中的函数名、参数类型以及所在类和命名空间生成修饰后名称，保证链接时不会出现函数重复定义。下面是GCC编译器生成修饰后名称，</p>
<table>
<thead>
<tr>
<th>函数签名</th>
<th>修饰后名称</th>
</tr>
</thead>
<tbody><tr>
<td>int func(int)</td>
<td>_Z4funci</td>
</tr>
<tr>
<td>float func(float)</td>
<td>_Z4funcf</td>
</tr>
<tr>
<td>int ClassA::func(int)</td>
<td>_ZN6ClassA4funcEi</td>
</tr>
<tr>
<td>int ClassA::ClassB::func(int)</td>
<td>_ZN6ClassA6ClassB4funcEi</td>
</tr>
<tr>
<td>int NamespaceA::ClassC::func(int)</td>
<td>_ZN10NamespaceA6ClassC4funcEi</td>
</tr>
</tbody></table>
</li>
<li><p>C++中<code>extern &quot;C&quot;</code>用途：告知C++编译器，对于其修饰的代码块，不要按照C++函数修饰规则生成符号。这在C++程序调用C库函数，或C++程序暴露C函数接口时是非常有必要的，否则在链接时会报<code>undefined reference</code>错误</p>
</li>
<li><p>弱符号：库中定义的弱符号可以被用户定义的强符号所覆盖，弱符号相当于函数的默认实现，用户可以在链接时使用自定义的实现覆盖它，进而使得依赖此函数的第三方在不改动代码的情况下替换函数的功能</p>
</li>
<li><p>弱引用：程序中声明的弱引用在链接时如果没有找到对应的符号，不会报链接错，其函数地址为0。利用此特性，程序可以选择性使用某些扩展功能模块，当链接扩展模块时则使用对应函数，否则也不影响程序正常运行</p>
</li>
</ul>
<h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><h5 id="GOT与C-中的虚函数表"><a href="#GOT与C-中的虚函数表" class="headerlink" title="GOT与C++中的虚函数表"></a>GOT与C++中的虚函数表</h5><ul>
<li>C++中的虚函数也是在运行时通过修改对象的虚函数表地址来实现多态的</li>
</ul>
<h5 id="函数的入口一定是main吗"><a href="#函数的入口一定是main吗" class="headerlink" title="函数的入口一定是main吗"></a>函数的入口一定是main吗</h5><p>还有一个衍生问题，为什么main函数在Java中一定要是static的？</p>
<p>程序真正执行的入口是main吗？（glibc中main函数地址并不是ELF中的entry）</p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://tonydeng.github.io/sdn-handbook/secure/vpn/">https://tonydeng.github.io/sdn-handbook/secure/vpn/</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://segmentfault.com/a/1190000008836467">https://segmentfault.com/a/1190000008836467</a></li>
</ul>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><h4 id="FDB-Fowarding-dataase"><a href="#FDB-Fowarding-dataase" class="headerlink" title="FDB(Fowarding dataase)"></a>FDB(Fowarding dataase)</h4><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="ARP-Address-Resolution-Protocol"><a href="#ARP-Address-Resolution-Protocol" class="headerlink" title="ARP(Address Resolution Protocol)"></a>ARP(Address Resolution Protocol)</h4><h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><h5 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h5><h6 id="一些小问题"><a href="#一些小问题" class="headerlink" title="一些小问题"></a>一些小问题</h6><ul>
<li>为什么IPv6在http请求的路径中需要加<code>[]</code>？<ul>
<li>IPv6可以使用双冒号<code>::</code>表示一组0或多组连续的0，但只能出现一次</li>
<li>http url可以使用<code>ip:port</code>作为domain，也可以省略port，此时http默认为80端口，https默认为443端口</li>
<li>如果不用<code>[]</code>扩起，则形如<code>https://2021:0216::1234:6789/path/to</code>的url就没办法区分请求的是<code>2021:0216:0000:0000:0000:0000:0000:1234</code>地址的6789端口还是<code>2021:0216:0000:0000:0000:0000:1234:6789</code>地址的443端口</li>
</ul>
</li>
</ul>
<h4 id="TUN-TAP及其应用"><a href="#TUN-TAP及其应用" class="headerlink" title="TUN/TAP及其应用"></a>TUN/TAP及其应用</h4><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><h4 id="UnixDomain-Socket"><a href="#UnixDomain-Socket" class="headerlink" title="UnixDomain Socket"></a>UnixDomain Socket</h4><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h4 id="Packet-Filtering-amp-iptables"><a href="#Packet-Filtering-amp-iptables" class="headerlink" title="Packet Filtering &amp; iptables"></a>Packet Filtering &amp; iptables</h4><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><h4 id="HTTP家族"><a href="#HTTP家族" class="headerlink" title="HTTP家族"></a>HTTP家族</h4><h5 id="HTTP2特性"><a href="#HTTP2特性" class="headerlink" title="HTTP2特性"></a>HTTP2特性</h5><ol>
<li>Headers压缩：HPACK算法</li>
<li>二进制分帧</li>
<li>多路复用，一个TCP连接能同时承载多个请求。每个流都有一个ID, 即可以同时发送多个请求，不再依赖多个 TCP 连接去实现多流并行了。</li>
<li>解决HTTP头部阻塞（仍未解决TCP头部阻塞）<ul>
<li>HTTP头部阻塞：前一个请求未收到响应时，不能使用该TCP连接发送下一个请求。根本原因还是请求和响应的每一个packet之间缺乏一个key进行关联，导致如果要支持同一个TCP连接同时发送多个请求，在收到不同请求的响应数据包后，无法找到它们对应的是哪个请求以及无法组装同一个响应的不同数据包。而HTTP2引入分帧后，在每个帧中增加了StreamID以串联同一个TCP连接中不同的流。</li>
<li>TCP头部阻塞：由于TCP需要保证消息的有序性，所以一个数据包丢包后，其后面的数据包就算接收到也不会回复ack。意味着后面的数据包都被这个丢失的数据包阻塞了。</li>
</ul>
</li>
<li>服务端推送：服务端可以在客户端的某个请求之后，主动向客户端推送其他资源。这也得益于二进制分帧，通过StreamID可以区分不同的流。而在HTTP中，没办法实现服务端推送，因为客户端区分不了是某个请求的响应还是服务端主动推送的。</li>
</ol>
<h5 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h5><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><p>SSH原理： <a target="_blank" rel="external nofollow noopener noreferrer" href="https://mp.weixin.qq.com/s/E05ZSzJQFc6efXtvs5sf1g">https://mp.weixin.qq.com/s/E05ZSzJQFc6efXtvs5sf1g</a></p>
<blockquote>
<p>更多内容详见<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.ietf.org/rfc/rfc4251.txt">RFC4251</a></p>
</blockquote>
<p>SSH(<code>Secure Shell</code>)是为了在<strong>不安全的网络上</strong>提供安全的远程登录和其他网络服务，用来替代不安全的终端访问方式，例如<code>telnet</code> 。</p>
<p>SSH协议可以理解为一组协议规范，主要包括3个部分：</p>
<ol>
<li>传输层协议<code>[SSH-TRANS]</code>：</li>
<li>用户认证协议<code>[SSH-USERAUTH]</code>：</li>
<li>会话连接协议<code>[SSH-CONNECT]</code>：</li>
</ol>
<p>在传输层依赖于TCP协议，采用非对称加密（非对称加密<a href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">详见</a>）实现身份认证</p>
<h5 id="SSH使用账号密码认证原理"><a href="#SSH使用账号密码认证原理" class="headerlink" title="SSH使用账号密码认证原理"></a>SSH使用账号密码认证原理</h5><h5 id="SSH使用秘钥认证原理"><a href="#SSH使用秘钥认证原理" class="headerlink" title="SSH使用秘钥认证原理"></a>SSH使用秘钥认证原理</h5><p>平常使用<code>ssh user@ip</code>默认使用当前用户的id_rsa秘钥文件，当然也可以通过<code>ssh -i rsa</code>指定私钥。</p>
<ol>
<li><p>私钥中包含了公钥，也就是说通过私钥可以计算出公钥，公私钥计算公式如下，具体可见 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://tools.ietf.org/html/rfc3447#appendix-A.1.1">RFC3447</a>。通过<code>ssh-keygen -yf ~/.ssh/id_rsa</code>可以提取公钥</p>
<blockquote>
<p>RSAPublicKey ::= SEQUENCE {</p>
<pre><code>      modulus           INTEGER,  -- n
      publicExponent    INTEGER   -- e
  &#125;
</code></pre>
<p>RSAPrivateKey ::= SEQUENCE {</p>
<pre><code>      version           Version,
      modulus           INTEGER,  -- n
      publicExponent    INTEGER,  -- e
      privateExponent   INTEGER,  -- d
      prime1            INTEGER,  -- p
      prime2            INTEGER,  -- q
      exponent1         INTEGER,  -- d mod (p-1)
      exponent2         INTEGER,  -- d mod (q-1)
      coefficient       INTEGER,  -- (inverse of q) mod p
      otherPrimeInfos   OtherPrimeInfos OPTIONAL
  &#125;
</code></pre>
</blockquote>
</li>
<li><p>公钥和私钥计算出的秘钥指纹是相同的。通过<code>ssh-keygen -lf ~/.ssh/id_rsa</code>可以计算fingerprint，秘钥指纹生成算法如下（bigendian）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 07  ssh-rsa 00 00 00 03 01 00 01 00 00 01 01 00 01 ... 63 25</span><br><span class="line">[tag length] [ tag ] [e length ] [   e  ] [n length ] [      n      ]</span><br><span class="line"></span><br><span class="line">*.pub文件中的第二段就是通过：先将公钥按照上面的算法生成的字节，再用base64编码</span><br><span class="line"></span><br><span class="line">ssh-keygen -lf ~/.ssh/id_rsa.pub生成的SHA256摘要指纹是通过：先将公钥按照上面的算法生成的字节，再用sha256算法生成digest，再用base64编码</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><code>ssh -i</code>鉴权流程：</p>
<ol>
<li>客户端与服务端协商产生会话密钥</li>
<li>客户端向服务端发送登录请求（如 <code>root@192.168.0.2</code>），发送的信息包括用户名root以及根据公/私钥计算的公钥指纹，且所有的数据都是经过会话秘钥加密过的</li>
<li>服务端收到数据后使用会话秘钥解密得到登录的用户名root以及秘钥指纹，然后读取<code>/root/.ssh/autorized_keys</code>文件中的所有公钥数据，通过上述算法生成指纹与客户端发送的指纹对比，从而找到客户端对应的公钥</li>
<li>服务端使用找到的客户端公钥对一个随机数进行加密然后发送到客户端</li>
<li>客户端使用私钥对服务的发送的随机数密文进行解密，然后把解密后的结果发给服务端</li>
<li>服务端验证客户端解密后的随机数与之前发送的数据一致，则对客户端的身份验证通过</li>
</ol>
<h5 id="SSH-tunneling原理及使用"><a href="#SSH-tunneling原理及使用" class="headerlink" title="SSH tunneling原理及使用"></a>SSH tunneling原理及使用</h5><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h1 id="后端技能"><a href="#后端技能" class="headerlink" title="后端技能"></a>后端技能</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="InnoDB的Page-Structure"><a href="#InnoDB的Page-Structure" class="headerlink" title="InnoDB的Page Structure"></a>InnoDB的Page Structure</h4><ul>
<li>为什么User Records要以单链表形式存储而非数组呢？<ul>
<li>插入记录O(1)时间复杂度，无需移动数据；而向数组中间插入记录必须挪动后面所有的记录，成本太高</li>
<li>每条记录的大小是不固定的</li>
</ul>
</li>
</ul>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><h4 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h4><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="缓存技术总览"><a href="#缓存技术总览" class="headerlink" title="缓存技术总览"></a>缓存技术总览</h3><h4 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h4><h5 id="TinyLFU"><a href="#TinyLFU" class="headerlink" title="TinyLFU"></a>TinyLFU</h5><h6 id="W-TinyLFU"><a href="#W-TinyLFU" class="headerlink" title="W-TinyLFU"></a>W-TinyLFU</h6><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h4><h5 id="Redis编码"><a href="#Redis编码" class="headerlink" title="Redis编码"></a>Redis编码</h5><h5 id="Redis对象"><a href="#Redis对象" class="headerlink" title="Redis对象"></a>Redis对象</h5><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">0            3 4                7 8          31 32              63 64         127</span><br><span class="line">|&lt;-- type --&gt;| |&lt;-- encoding --&gt;| |&lt;-- lru --&gt;| |&lt;-- refcount --&gt;| |&lt;-- prt --&gt;|</span><br><span class="line"></span><br><span class="line">type: Redis对象类型，String, List, Set, Sorted set, Hash</span><br><span class="line">encoding: 对象的编码类型，Raw, Integer, Hash table, Skiplist, Embstr等</span><br><span class="line">lru: 表示与lru_clock的相对值（用于LRU驱逐策略）；或LFU的数据，低8bit表示frequency，高16bit表示最后访问时间（以分钟为单位）</span><br><span class="line">refcount: 此对象的引用计数</span><br><span class="line">ptr: 指向对象值的指针</span><br></pre></td></tr></table></figure>

<h6 id="String-Object"><a href="#String-Object" class="headerlink" title="String Object"></a>String Object</h6><p>字符串长度<code>&lt;= 44</code>使用embstr，否则使用raw string。之所以根据字符串长度有不同的实现，是因为embstr只需要一次内存分配，而raw string需要2次内存分配，而且会产生内存碎片，另外重要的一点是String对象作为最基础的对象，通常长度不会太长（作为command、key等）。</p>
<p>而44这个数字，是因为String Object中一个<code>robj</code>对象占用16字节，<code>sdshdr8</code>占用3字节，<code>\0</code>占用1字节，也就是说就算是一个空字符串也要占用20字节。Redis使用的内存分配器默认是<code>jemalloc</code>，根据class_size向上取整理应要分配32字节，但是这样的话字符串最大长度只有12字节，没办法适用大部分场景。所以就扩大了限制以适配64字节这个size。</p>
<h4 id="Redis通信协议"><a href="#Redis通信协议" class="headerlink" title="Redis通信协议"></a>Redis通信协议</h4><h5 id="RESP（REdis-Serialization-Protocol）"><a href="#RESP（REdis-Serialization-Protocol）" class="headerlink" title="RESP（REdis Serialization Protocol）"></a>RESP（REdis Serialization Protocol）</h5><p>用于Redis Client和Server通信，RESP可以兼顾以下几个优点：1. 实现简单    2. 解析速度快    3. Human readable。</p>
<p>RESP尽量遵循简单的请求-响应模型，即Client发送不同参数组成的命令，Server接收到后处理并响应。但是有2个例外的场景：</p>
<ol>
<li><code>Pipeline</code>：客户端会一次性发送多个请求命令，然后等待批量的响应（多个请求之间用<code>\r\n</code>分隔）</li>
<li><code>Pub/Sub</code>：不再需要客户端主动请求，因为服务端会在Channel有新Message时主动通知客户端</li>
</ol>
<p>RESP支持多种数据类型并可以用一个字节枚举，请求和响应的数据由多种不同数据类型的part组成。每个part的数据以一个字节表示的数据类型开头，<code>\r\n(CRLF)</code>结尾。</p>
<p>RESP3在RESP2的基础上额外增加了多种数据类型，同时协议向后兼容。RESP3在Redis 6.0及以上版本引入，但是为了保证Client的兼容默认是关闭的，可以通过<code>HELLO 3</code>命令升级为RESP3，当然也可以通过<code>HELLO 2</code>降级回RESP2。</p>
<div class="tabs" id="resp数据类型说明"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#resp数据类型说明-1">RESP2</button></li><li class="tab"><button type="button" data-href="#resp数据类型说明-2">RESP3中引入</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="resp数据类型说明-1"><table>
<thead>
<tr>
<th>数据类型</th>
<th>first byte</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>Simple String</td>
<td>+</td>
<td><code>+&lt;string&gt;\r\n</code>。字符串中不能包含CR或LF，所以不是二进制安全的</td>
<td><code>+PONG\r\n</code></td>
</tr>
<tr>
<td>Simple Error</td>
<td>-</td>
<td>规则与Simple String相同。第一个大写单词代表错误码，客户端会把字符串当成异常信息来处理</td>
<td><code>-Error message\r\n</code></td>
</tr>
<tr>
<td>Number</td>
<td>:</td>
<td>64位有符号整数，<code>:&lt;number&gt;\r\n</code>。INCR, LLEN等命令会返回具体的数值，而SETNX, EXISTS等命令会返回1代表<code>true/实际执行了操作</code> 或 0代表<code>false/没有执行操作</code></td>
<td><code>:666\r\n</code></td>
</tr>
<tr>
<td>Blob String</td>
<td>$</td>
<td><code>$&lt;length&gt;\r\n&lt;bytes&gt;\r\n</code>，因为有字节长度，所以是二进制安全的。在RESP2中使用<code>$-1\r\n</code>表示Null，比如GET的key不存在</td>
<td><code>$3\r\nfoo\r\n</code></td>
</tr>
<tr>
<td>Array</td>
<td>*</td>
<td>Client使用数组来发送命令，某些命令Server也会返回数组，例如<code>SMEMBERS</code>。”*” 后面跟着数组长度N，随后是CRLF，接着是N个任何类型的元素（可以是不同类型）</td>
<td><code>*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n</code></td>
</tr>
</tbody></table><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="resp数据类型说明-2"><table>
<thead>
<tr>
<th>数据类型</th>
<th>first byte</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>Null</td>
<td>_</td>
<td><code>_\r\n</code></td>
<td><code>_\r\n</code></td>
</tr>
<tr>
<td>Double</td>
<td>,</td>
<td><code>,&lt;floating-point-number&gt;\r\n</code>，<code>inf</code>表示正无穷，<code>-inf</code>表示负无穷</td>
<td><code>,3.1415926\r\n</code></td>
</tr>
<tr>
<td>Boolean</td>
<td>#</td>
<td><code>#t\r\n</code>代表True，<code>#\f\r\n</code>代表False</td>
<td></td>
</tr>
<tr>
<td>Blob Error</td>
<td>!</td>
<td>规则与Blob String相同。第一个大写单词代表错误码，客户端会把字符串当成异常信息来处理</td>
<td><code>!21\r\nSYNTAX invalid syntax\r\n</code></td>
</tr>
<tr>
<td>Verbatim String</td>
<td>=</td>
<td>规则上与Blob String类似，前三个字节表示富文本类型，比如<code>txt</code>/<code>mkd</code>，第四个字节为<code>:</code>，然后是真正的字符串</td>
<td><code>=8\r\ntxt:test\r\n</code></td>
</tr>
<tr>
<td>Big Number</td>
<td>(</td>
<td>用来代表超过有符号64整数的数字，<code>(&lt;big number&gt;\r\n</code>。大数可以是正数或负数，但不能包含小数部分</td>
<td><code>(3492890328409238509324850943850943825024385\r\n</code></td>
</tr>
<tr>
<td>Map</td>
<td>%</td>
<td>与Array类似，”%”后跟着键值对的个数N，随后是CRLF，接着是N个任何类型的Key-Value对</td>
<td><code>%2\r\n+foo\r\n:1\r\n+bar\r\n#t\r\n</code></td>
</tr>
<tr>
<td>Set</td>
<td>~</td>
<td>与Array类似，不过语义上稍有不同，Set返回的元素是无序的。协议上并没有强制保证Set内的元素不重复，Client需要处理这种情况</td>
<td><code>~3\r\n+foo\r\n:1\r\n#f\r\n</code></td>
</tr>
</tbody></table><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div></div></div>

<blockquote>
<p> 下面我们通过nc命令，使用RESP协议尝试不同的请求命令，加深下理解。</p>
<p><strong><em>Tips：</em></strong>当我们需要在线上环境定位问题时，可能没有易用的redis-cli命令，此时可以使用nc命令按照RESP规范进行请求。当然Redis也提供了另一种简化的使用方式，叫做<code>内联命令(Inline Commands)</code>， 可以通过空格分隔的参数进行请求。</p>
</blockquote>
<div class="tabs" id="resp2协议使用"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#resp2协议使用-1">使用RESP2</button></li><li class="tab"><button type="button" data-href="#resp2协议使用-2">内联命令</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="resp2协议使用-1"><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;*1\r\n$7\r\nUNKNOWN\r\n&#x27; | nc redis 6379</span><br><span class="line">-ERR unknown command `UNKNOWN`, with args beginning with: </span><br><span class="line"></span><br><span class="line">echo &#x27;*2\r\n$3\r\nGET\r\n$3\r\nfoo\r\n&#x27; | nc redis 6379</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">-1</span></span><br><span class="line"></span><br><span class="line">echo &#x27;*3\r\n$3\r\nSET\r\n$3\r\nfoo\r\n$6\r\nfooval\r\n&#x27; | nc redis 6379</span><br><span class="line">+OK</span><br><span class="line"></span><br><span class="line">echo &#x27;*2\r\n$3\r\nGET\r\n$3\r\nfoo\r\n&#x27; | nc redis 6379</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">6</span></span><br><span class="line">fooval</span><br><span class="line"></span><br><span class="line">echo &#x27;*3\r\n$5\r\nSETNX\r\n$3\r\nfoo\r\n$6\r\nfooval\r\n&#x27; | nc redis 6379</span><br><span class="line">:0	# SETNX，此时foo已经存在，所以返回:0表示没有执行操作</span><br><span class="line"></span><br><span class="line">echo &#x27;*5\r\n$5\r\nLPUSH\r\n$3\r\nbar\r\n$2\r\nv1\r\n$2\r\nv2\r\n$2\r\nv3\r\n&#x27; | nc redis 6379</span><br><span class="line">:3</span><br><span class="line"></span><br><span class="line">echo &#x27;*4\r\n$6\r\nLRANGE\r\n$3\r\nbar\r\n$1\r\n0\r\n$2\r\n-1\r\n&#x27; | nc redis 6379 </span><br><span class="line">*3</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2</span></span><br><span class="line">v3</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2</span></span><br><span class="line">v2</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2</span></span><br><span class="line">v1</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="resp2协议使用-2"><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;UNKNOWN&#x27; | nc redis 6379</span><br><span class="line">-ERR unknown command `UNKNOWN`, with args beginning with:</span><br><span class="line"></span><br><span class="line">echo &#x27;GET foo&#x27; | nc redis 6379</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">-1</span></span><br><span class="line"></span><br><span class="line">echo &#x27;SET foo foovalue&#x27; | nc redis 6379</span><br><span class="line">+OK</span><br><span class="line"></span><br><span class="line">echo &#x27;SET foo foovalue NX&#x27; | nc redis 6379</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">-1</span></span><br><span class="line"></span><br><span class="line">echo &#x27;lpush bar v1 v2 v3&#x27; | nc redis 6379</span><br><span class="line">:3</span><br><span class="line"></span><br><span class="line">echo &#x27;lrange bar 0 -1&#x27; | nc redis 6379</span><br><span class="line">*3</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2</span></span><br><span class="line">v3</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2</span></span><br><span class="line">v2</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2</span></span><br><span class="line">v1</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h4 id="淘汰机制"><a href="#淘汰机制" class="headerlink" title="淘汰机制"></a>淘汰机制</h4><ul>
<li>每次lookupKey都会更新robj的lru值</li>
<li>LFU的低16位存储上次访问的时间戳对应的分钟数</li>
</ul>
<h3 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h3><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h2 id="编码-amp-压缩-amp-加密"><a href="#编码-amp-压缩-amp-加密" class="headerlink" title="编码 &amp; 压缩 &amp; 加密"></a>编码 &amp; 压缩 &amp; 加密</h2><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>编码的本质就是双方根据一定的规则对数据进行处理</p>
<h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><ul>
<li>字符：各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。 也就是说，它是一个信息单位，一个数字是一个字符，一个文字是一个字符，一个标点符号也是一个字符。</li>
<li>字符集：字符的集合，不同集合支持的字符范围自然也不一样，譬如ASCII只支持英文，GB18030支持中文等等。在字符集中存在一个码表，每个字符在各自字符集对应着唯一一个码。但是同一个字符在不同的字符集中对应的码不同，比如字符“世”在Unicode中为<code>U+4e16</code>，在GBK中为<code>0xcac0</code></li>
<li>字符编码：定义字符集中的字符如何编码为特定的二进制数，以便在计算机中存储。字符集与字符编码通常是一一对应的，比如GB18030既可以代表字符集也可以代表字符编码，它为了兼容ASCII码，编码方式为大于255采用两字节来代表一个字符，否则就是兼容模式，一个字节代表一个字符。当然也存在特例，比如Unicode字符集就有多种编码实现（UTF-8，UTF-16等）</li>
</ul>
<h5 id="字符集与字符编码发展史"><a href="#字符集与字符编码发展史" class="headerlink" title="字符集与字符编码发展史"></a>字符集与字符编码发展史</h5><ul>
<li>最早的计算机只需要使用英文符号，加上数字和一些特殊符号，然后用8位二进制映射到128个不同的字符串里，这样就能表示日常需要的所有字符了，这就是我们常说的ASCII码（American Standard Code for Information Interchange，美国信息交换标准代码）。在ASCII码中，0<del>31是控制字符如换行删除等，32</del>126是可打印字符可以通过键盘输出并显示出来。</li>
<li>后来计算机传入欧洲，一些欧洲国家决定对ASCII编码进行适当的“改造”：利用字节中闲置的最高位编入新的符号，这样一来可以表示最多256个符号。但是欧洲的语言体系有个特点：小国家特别多，每个国家可能都有自己的语言体系，因此即便有256个字符也没办法统一欧洲的语言环境。后来大家想了一个折中的方案：在256个字符中，前128字符和ASCII编码表示的字符完全一样，后128个字符每个国家或地区都有自己的编码标准。根据这个规则，形成了很多子标准：ISO-8859-1、ISO-8859-2。。。</li>
<li>计算机传入亚洲后，国际标准已被完全不够用，各个国家根据自己的地区特色，发明了适用自身的字符集与编码，譬如中国大陆的GB2312，日本的Shift JIS等等 这些编码都是用双字节来进行存储，它们对外有一个统称ANSI（American National Standards Institute），也就是说GB2312或Shift JIS等都是ANSI在各自地区的不同标准。</li>
<li>到了全球互联网时代，不同国家需要在互联网上进行信息交互，这时候由于各自编码标准都不一样，彼此之间都是乱码，无法良好的沟通交流。于是这时候ISO组织与统一码联盟整合推出了Unicode字符集，它使用4字节的数字来表达每个字符。每个数字代表唯一的至少在某种语言中使用的字符。这时候所有的字符都可以采用同一个字符集，有着相同的编码，可以愉快的进行交流了。</li>
</ul>
<h5 id="UTF-8编码规则"><a href="#UTF-8编码规则" class="headerlink" title="UTF-8编码规则"></a>UTF-8编码规则</h5><p><strong>UTF-8</strong>（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容。</p>
<p>UTF-8 的编码规则很简单：</p>
<ol>
<li>对于单字节字符，与ASCII编码完全相同</li>
<li>对于<code>n</code>字节的字符，第一个字节的前<code>n</code>个bit都置为1，第<code>n+1</code>个bit置为<code>0</code>，后面字节的前两位一律置为<code>10</code>，剩余的bit用于从左至右依次存储Unicode的码点</li>
</ol>
<p>Unicode与UTF-8转换关系表</p>
<table>
<thead>
<tr>
<th>Unicode码点位数</th>
<th>Unicode码点范围</th>
<th>UTF-8字节序</th>
</tr>
</thead>
<tbody><tr>
<td>[0, 7]</td>
<td>U+0000~U+007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>[8, 11]</td>
<td>U+0080~U+07FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>[12, 16]</td>
<td>U+0800~U+FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>[17, 21]</td>
<td>U+10000~U+1FFFFF</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>[22, 26]</td>
<td>U+200000~U+3FFFFFF</td>
<td>111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>[27, 31]</td>
<td>U+4000000~U+7FFFFFFF</td>
<td>1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<p>举几个例子</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>Unicode</th>
<th>UTF-8</th>
</tr>
</thead>
<tbody><tr>
<td>Ā</td>
<td>U+0100</td>
<td>11000100 10000000 = C4 80</td>
</tr>
<tr>
<td>世</td>
<td>U+4E16</td>
<td>11100100 10111000 10010110 = E4 B8 96</td>
</tr>
<tr>
<td>🎅</td>
<td>U+1F385</td>
<td>11110000 10011111 10001110 10000101 = F0 9F 8E 85</td>
</tr>
</tbody></table>
<h5 id="手持两把锟斤拷，口中疾呼烫烫烫"><a href="#手持两把锟斤拷，口中疾呼烫烫烫" class="headerlink" title="手持两把锟斤拷，口中疾呼烫烫烫"></a>手持两把锟斤拷，口中疾呼烫烫烫</h5><h5 id="MySQL中的utf8mb4"><a href="#MySQL中的utf8mb4" class="headerlink" title="MySQL中的utf8mb4"></a>MySQL中的utf8mb4</h5><p>utf8无法存储emoji，因为MySQL中的utf8最多只用3字节存储，而emoji使用4字节编码，比如🎅的16进制编码为<code>0xF09F8E85</code></p>
<h5 id="Python2中讨厌的编码"><a href="#Python2中讨厌的编码" class="headerlink" title="Python2中讨厌的编码"></a>Python2中讨厌的编码</h5><h4 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h4><h5 id="varint"><a href="#varint" class="headerlink" title="varint"></a>varint</h5><h5 id="zigzag"><a href="#zigzag" class="headerlink" title="zigzag"></a>zigzag</h5><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><h5 id="simdjson是何方神圣"><a href="#simdjson是何方神圣" class="headerlink" title="simdjson是何方神圣"></a>simdjson是何方神圣</h5><h4 id="Base64家族"><a href="#Base64家族" class="headerlink" title="Base64家族"></a>Base64家族</h4><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><h4 id="GZip"><a href="#GZip" class="headerlink" title="GZip"></a>GZip</h4><h4 id="LZ4"><a href="#LZ4" class="headerlink" title="LZ4"></a>LZ4</h4><h4 id="Snappy"><a href="#Snappy" class="headerlink" title="Snappy"></a>Snappy</h4><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><h5 id="RSA算法的数学原理"><a href="#RSA算法的数学原理" class="headerlink" title="RSA算法的数学原理"></a>RSA算法的数学原理</h5><ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://segmentfault.com/a/1190000014871852">https://segmentfault.com/a/1190000014871852</a></li>
</ul>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p><a target="_blank" rel="external nofollow noopener noreferrer" href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><h2 id="内存分配与回收"><a href="#内存分配与回收" class="headerlink" title="内存分配与回收"></a>内存分配与回收</h2><p>分配器多种多样，比如通用的jemalloc、tcmalloc，或者各个语言自己实现的比如pymalloc，但是他们的目标是一样的：</p>
<ol>
<li>基本功能：将一块内存根据固定单位的页定义出来，然后区分对象大小分别管理内存，小内存分成若干类，专门用来分配固定大小的内存块，并用一个表管理起来，降低内部碎片，减少Page Fault，提升内存分配速度。大内存则以页为单位管理，配合小对象所在页， 降低碎片。</li>
<li>回收：当释放内存时，要能够合并小内存为大内存，根据一些条件，该保留的就保留下来，在下次使用时可以快速响应</li>
<li>多线程下性能优化：每个线程独占一段内存，被称为TLS，这样线程内操作时可以不加锁，提高性能。当独占的内存不够用时再从全局的内存中分配。但随之而来的也有些待解决的问题：<ol>
<li>如何尽量减少到全局内存池中分配导致锁冲突</li>
<li>如何解决不同线程内存利用率不一致导致的overhead</li>
<li>如何在空闲时将线程独占内存释放回全局内存中以便其他线程使用</li>
</ol>
</li>
</ol>
<p>当占用内存的对象不再可能被使用的时候，需要对其使用的内存进行回收，常见的回收算法有<em>引用计数法</em>，<em>标记清除法</em>，它们的目标是：</p>
<ol>
<li>尽可能多的识别出不使用的内存空间</li>
<li>减少内存回收导致的外部碎片</li>
<li>降低内存回收对程序运行的影响，耗时尽量短</li>
</ol>
<h2 id="eBPF"><a href="#eBPF" class="headerlink" title="eBPF"></a>eBPF</h2><h1 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h1><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h2 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h2><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><ul>
<li>内存管理</li>
</ul>
<h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><h4 id="一切皆对象"><a href="#一切皆对象" class="headerlink" title="一切皆对象"></a>一切皆对象</h4><h5 id="int"><a href="#int" class="headerlink" title="int"></a>int</h5><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.dongwm.com/post/python-memory-usage-1/">https://www.dongwm.com/post/python-memory-usage-1/</a></p>
<h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://juejin.cn/post/6924192092902146055#heading-12">import原理详细解读</a></p>
<h3 id="奇淫巧技"><a href="#奇淫巧技" class="headerlink" title="奇淫巧技"></a>奇淫巧技</h3><h4 id="new-与-init"><a href="#new-与-init" class="headerlink" title="__new__与__init__"></a><code>__new__</code>与<code>__init__</code></h4><p><code>__new__</code>用于创建对象；<code>__init__</code>用于初始化对象。</p>
<p><code>__new__</code>会在使用<code>ClassName()</code>创建对象时自动调用，<code>__init__</code>会在new返回创建的实例后被调用，并把返回的实例传入<code>__init__</code>，对应入参<code>self</code>。</p>
<p>如果重写了父类的<code>__new__</code>但是并没有返回实例，则不会调用<code>__init__</code></p>
<h4 id="类方法与实例方法"><a href="#类方法与实例方法" class="headerlink" title="类方法与实例方法"></a>类方法与实例方法</h4><p>类方法对应的地址全局唯一，不同的对象对应的类方法id都是相同的。</p>
<p>不同的对象对应的实例方法id是不同的，实例方法也可以通过<code>Class.method(object)</code>调用，实例方法第一个参数是<code>self</code>也就是实例，我们平常用的<code>object.method(args)</code>本质上就是在对象创建时通过<code>Class.method</code>生成一个新的<code>偏函数(partial)</code>，将第一个参数绑定成实例，然后重新<code>setattr(object,  method, partialed_method)</code>。</p>
<h4 id="mock的原理"><a href="#mock的原理" class="headerlink" title="mock的原理"></a>mock的原理</h4><ol>
<li>Python中一切都是对象，module是对象，class是对象，function也是对象</li>
<li>globals() 和 locals()</li>
<li>setattr()</li>
</ol>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h4 id="Object-Header"><a href="#Object-Header" class="headerlink" title="Object Header"></a>Object Header</h4><ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://juejin.cn/post/6844904113306615822">https://juejin.cn/post/6844904113306615822</a></li>
</ul>
<h2 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h2><ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="http://twitter.github.io/scala_school/index.html">Twitter Scala School</a></li>
</ul>
<h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><h3 id="为什么Go的可执行文件特别小还不需要依赖so"><a href="#为什么Go的可执行文件特别小还不需要依赖so" class="headerlink" title="为什么Go的可执行文件特别小还不需要依赖so"></a>为什么Go的可执行文件特别小还不需要依赖so</h3><h1 id="内功心法"><a href="#内功心法" class="headerlink" title="内功心法"></a>内功心法</h1><p><strong>可维护性 = 当依赖变化时，有多少代码需要随之改变</strong></p>
<p><strong>可扩展性 = 做新需求或改逻辑时，需要新增/修改多少代码</strong></p>
<p><strong>可测试性 = 运行每个测试用例所花费的时间 * 每个需求所需要增加的测试用例数量 * 编写测试用例的难易程度</strong> </p>
<h2 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h2><ul>
<li>四大特性：封装、抽象、继承、多态</li>
<li>与面向过程的区别于联系</li>
<li>接口与抽象类</li>
<li>基于接口而非实现编程</li>
<li>多用组合少用继承</li>
<li>面向过程的贫血模型与面向对象的充血模型</li>
</ul>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ul>
<li>S(Single Responsibility Principle)：单一职责原则</li>
<li>O(Open Close Principle)：开闭原则</li>
<li>L(Liskov Substitution Principle)：里氏替换原则</li>
<li>I(Interface Segregation Principle)：接口隔离原则</li>
<li>D(Dependency Inversion Principle)：依赖导致原则</li>
<li>DRY(Don’t Repeat Yourself)</li>
<li>KISS(Keep It Simple, Silly)</li>
<li>YAGNI(You Aren’t Gonna Need It)</li>
<li>LOD(Law Of Demeter): 迪米特法则，又叫做最少知识原则</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li><p>创建型</p>
<ul>
<li>常用：单例模式、建造者模式、工厂模式（简单工厂、工厂方法）</li>
<li>不常用：抽象工厂、原型模式</li>
</ul>
</li>
<li><p>结构型</p>
<ul>
<li>常用：代理模式、桥接模式、装饰器模式、适配器模式</li>
<li>不常用：门面模式、组合模式、享元模式</li>
</ul>
</li>
<li><p>行为型</p>
<ul>
<li>常用：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、空对象模式</li>
<li>状态：访问者模式、备忘录模式、命令模式、解释器模式、中介模式</li>
</ul>
<h2 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h2></li>
<li><p>命名，命名，还是命名</p>
</li>
<li><p>函数</p>
</li>
<li><p>对象和数据结构</p>
</li>
<li><p>错误处理</p>
</li>
<li><p>类</p>
</li>
</ul>
<h2 id="接口设计规范"><a href="#接口设计规范" class="headerlink" title="接口设计规范"></a>接口设计规范</h2><p>RESTful接口设计可以参照Google的这篇指南</p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://cloud.google.com/apis/design">https://cloud.google.com/apis/design</a></p>
<p>具体应用可以参考K8S的接口设计</p>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#-strong-api-overview-strong-">https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#-strong-api-overview-strong-</a></p>
<h2 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h2><ul>
<li>重构的目的（Why）、对象（What）、时机（When）、方法（How）</li>
<li>保证重构不出错的技术手段：单元测试、代码可测试性</li>
</ul>
<h2 id="领域驱动设计"><a href="#领域驱动设计" class="headerlink" title="领域驱动设计"></a>领域驱动设计</h2><h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><h2 id="批流处理"><a href="#批流处理" class="headerlink" title="批流处理"></a>批流处理</h2><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h2 id="实时分析"><a href="#实时分析" class="headerlink" title="实时分析"></a>实时分析</h2><h1 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h1><h2 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h2><h3 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h3><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/fs/ioctl.c.html#718">ioctl syscall</a> -&gt; <a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/fs/ioctl.c.html#ksys_ioctl">ksys_ioctl</a> -&gt; <a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/fs/ioctl.c.html#do_vfs_ioctl">do_vfs_ioctl</a> -&gt; <a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/fs/ioctl.c.html#vfs_ioctl">vfs_ioctl</a> -&gt; <a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/virt/kvm/kvm_main.c.html#3321">unlocked_ioctl</a> -&gt; <a target="_blank" rel="external nofollow noopener noreferrer" href="https://code.woboq.org/linux/linux/virt/kvm/kvm_main.c.html#kvm_vm_ioctl">kvm_vm_ioctl</a> -&gt; </p>
<h2 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h2><h3 id="容器底层核心技术"><a href="#容器底层核心技术" class="headerlink" title="容器底层核心技术"></a>容器底层核心技术</h3><h4 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h4><h4 id="CGroup"><a href="#CGroup" class="headerlink" title="CGroup"></a>CGroup</h4><ul>
<li>OOM Kill进程的日志可以在<code>/var/log/kern.log</code>中查看，</li>
</ul>
<p><img src="https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20201203000045.png"></p>
<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><h4 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h4><ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://segmentfault.com/a/1190000007898437">https://segmentfault.com/a/1190000007898437</a></li>
</ul>
<h3 id="Podman"><a href="#Podman" class="headerlink" title="Podman"></a>Podman</h3><h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><h3 id="K8S网络"><a href="#K8S网络" class="headerlink" title="K8S网络"></a>K8S网络</h3><h4 id="Flannel网络原理"><a href="#Flannel网络原理" class="headerlink" title="Flannel网络原理"></a>Flannel网络原理</h4><p><a target="_blank" rel="external nofollow noopener noreferrer" href="https://blog.laputa.io/kubernetes-flannel-networking-6a1cb1f8ec7c">https://blog.laputa.io/kubernetes-flannel-networking-6a1cb1f8ec7c</a></p>
<ul>
<li>node的annotation中有flannel相关的信息，比如Vtep MAC、PublicIP、podCIDR等</li>
<li>flannel会通过IndexerInformer watch k8s node的变更</li>
<li>对于node的变更，flannel会调用netlink包中的FDB、ARP接口，更新fdb表和路由表</li>
</ul>
<p><a target="_blank" rel="external nofollow noopener noreferrer" href="http://just4coding.com/2020/04/20/vxlan-fdb/">http://just4coding.com/2020/04/20/vxlan-fdb/</a></p>
<h3 id="Helm"><a href="#Helm" class="headerlink" title="Helm"></a>Helm</h3><p>三大概念</p>
<ol>
<li>Chart：代表一个helm包，包含了运行一个应用/工具/服务所需要的所有资源定义，比如在k8s中部署MySQL需要<a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/helm/charts/blob/master/stable/mysql/templates/deployment.yaml">Deployment定义</a>、<a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/helm/charts/blob/master/stable/mysql/templates/svc.yaml">Service定义</a>、<a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/helm/charts/blob/master/stable/mysql/templates/pvc.yaml">PVC定义</a>等</li>
<li>Repository：存储共享各种Charts的地方</li>
<li>Release：在k8s集群中运行Chart实例，一个Chart可以多次安装到同一集群中，每次安装时都会创建一个新版本。比如在一个集群中运行两个不同版本的MySQL实例</li>
</ol>
<p>常用操作</p>
<ol>
<li><code>helm repo add NAME URL</code>，可以到<a target="_blank" rel="external nofollow noopener noreferrer" href="https://artifacthub.io搜索各种chart对应的repo.`helm/">https://artifacthub.io搜索各种Chart对应的repo。`helm</a> search repo NAME`，在已经添加的repo中<strong>模糊</strong>搜索Chart</li>
<li><code>helm install NAME CHART Flags</code>，部署Chart到k8s集群，可以指定<code>-f config.yaml</code>或<code>--set key=value</code>覆盖Chart中的配置值。<code>helm upgrade RELEASE CHART</code>，更新Release的配置，一般用于更新配置值</li>
<li><code>helm rollback RELEASE REVISION</code>，回滚Release到指定版本，可以通过<code>helm history RELEASE</code>查看发布历史</li>
<li><code>helm list</code>查看部署的releases，<code>helm uninstall RELEASE</code>将release从集群中卸载</li>
<li><code>helm create NAME</code>创建一个新的Chart，你可以定义自己的Chart，<code>helm lint PATH</code>用于校验写的chart是不是合法的</li>
</ol>
<h2 id="ServiceMesh"><a href="#ServiceMesh" class="headerlink" title="ServiceMesh"></a>ServiceMesh</h2><h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><h1 id="代码之外的软技能"><a href="#代码之外的软技能" class="headerlink" title="代码之外的软技能"></a>代码之外的软技能</h1><h1 id="效率工具"><a href="#效率工具" class="headerlink" title="效率工具"></a>效率工具</h1><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h3></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:leosocy@gmail.com" rel="external nofollow noopener noreferrer" target="_blank">Leosocy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.leosocy.top/posts/133f/">https://blog.leosocy.top/posts/133f/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external nofollow noopener noreferrer">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.leosocy.top" target="_blank">Leosocy's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a><a class="post-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF%E6%8A%80%E8%83%BD/">后端技能</a><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><a class="post-meta__tags" href="/tags/%E5%86%85%E5%8A%9F%E5%BF%83%E6%B3%95/">内功心法</a><a class="post-meta__tags" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a><a class="post-meta__tags" href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a><a class="post-meta__tags" href="/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/">效率工具</a></div><div class="post_share"><div class="social-share" data-image="/img/computer-science.png" data-sites="wechat,weibo,qq,facebook,twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/9e84/"><img class="prev-cover" data-lazy-src="https://cdn.leosocy.top/img/20210703000745.png" onerror="onerror=null;src='https://cdn.leosocy.top/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Docker容器的日志是如何存储的</div></div></a></div><div class="next-post pull-right"><a href="/posts/6d47/"><img class="next-cover" data-lazy-src="https://cdn.leosocy.top/img/linux-toy-cowsay.png" onerror="onerror=null;src='https://cdn.leosocy.top/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">深入了解Linux - COW写时拷贝实现原理</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><label><input id="switch-comments-btn" type="checkbox"><span class="slider"></span></label><span class="second-comment">Gitalk</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="gitalk-container"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2023   <i id="heartbeat" class="fa fas fa-heartbeat"></i>  Leosocy</div><div class="icp"><a target="_blank" rel="external nofollow noopener noreferrer" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=32011302320676"><span>苏ICP备19003706号-1</span></a></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/LeosocyBlog/cdn@master/css/heartbeat.min.css"></head></footer><script>var bg_index = Math.floor(Math.random() * 21);
if (true === true)
  var res = 'background-image: url("https://cdn.leosocy.top/img/background/' + bg_index + '-bg.jpg");'
else
  var res = 'background-image: url("https://cdn.jsdelivr.net/gh/LeosocyBlog/cdn/img/background/' + bg_index + '-bg.jpg");'
document.getElementById('web_bg').style = res
</script></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.spacingElementById('content-inner')
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js', () => {
      pangu.spacingElementById('content-inner')
    })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguFn)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'HrxT0ob97kYUTuWuUo08mkqc-gzGzoHsz',
      appKey: 'oeKW9UqjBpN6MNv7ENaikdwP',
      placeholder: '请输入内容',
      avatar: 'retro',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: 'https://lcapi.leosocy.top',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      visitor: true
    });
    if ('nick') { valine.config.requiredFields= 'nick'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true && !true) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk({
      clientID: '32b06a1ce1ba2d645bb5',
      clientSecret: 'c4e9c93c5a16234ecb67a9b83b9315f763436cdd',
      repo: 'comments',
      owner: 'LeosocyBlog',
      admin: ['Leosocy'],
      id: 'a358fabc5f4106a986d34e38bc55c3fc',
      language: 'zh-CN',
      perPage: 10,
      distractionFreeMode: true,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    })
    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    $.getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js', initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Valine' === 'Gitalk' || !true) {
  if (true) loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script>cdn_url = "https://cdn.leosocy.top"</script><script src="/"></script></div><script src="https://cdn.jsdelivr.net/gh/LeosocyBlog/cdn@master/js/leosocy.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>$(function () {
  var pjax = new Pjax({
    selectors: [
      'title',
      'meta[name=description]',
      '#config_change',
      '#body-wrap',
      '#rightside-config-hide',
      '#rightside-config-show',
      '.js-pjax'
    ],
    cacheBust: false,
  })

  document.addEventListener('pjax:complete', function () {
    refreshFn()

    $('script[data-pjax]').each(function () {
      $(this).parent().append($(this).remove())
    })

    GLOBAL_CONFIG.islazyload && lazyLoadInstance.update()

    typeof chatBtnFn === 'function' && chatBtnFn()
    typeof panguInit === 'function' && panguInit()

    if (typeof gtag === 'function') {
      gtag('config', 'G-8EGQPPW7GQ', {'page_path': window.location.pathname});
    }

    if (document.getElementsByClassName('aplayer').length){
      typeof loadMeting === 'function' && loadMeting()
    }
  })

  document.addEventListener('pjax:send', function () {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }

    typeof typed === 'object' && typed.destroy()

    $(window).off('scroll')

    //reset readmode
    $('body').hasClass('read-mode') && $('body').removeClass('read-mode')

    //reset font-size
    $('body').css('font-size') !== originFontSize && $('body').css('font-size', parseFloat(originFontSize))
  })
})</script></div></body></html>