<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CMake语言和语法</title>
    <url>/posts/5096/</url>
    <content><![CDATA[<p>在项目或者工作中，会不可避免的使用到cmake来构建我们的项目，所以掌握cmake的基本语法，以及常用的和进阶的使用方法是非常重要的。</p>
<p>下面我们将从一个简单的<code>hello cmake</code>示例开始，一步步的深入了解cmake的用法。</p>
<span id="more"></span>

<p><strong><em>Let’s Go!</em></strong></p>
<h3 id="初探CMake，hello-cmake"><a href="#初探CMake，hello-cmake" class="headerlink" title="初探CMake，hello cmake"></a>初探CMake，hello cmake</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>创建目录 /home/workspace/cmake_practice，我们之后的练习都放到这个目录的子目录下</p>
<p>在cmake_practice目录下创建test1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /home/workspace/cmake_practice</span><br><span class="line">mkdir test1</span><br><span class="line">cd test1</span><br></pre></td></tr></table></figure>

<p>创建main.c以及CMakeLists.txt</p>
<p>main.c内容如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello CMake!\n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CMakeLists.txt内容如下</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span>(hello-cmake)</span><br><span class="line"><span class="keyword">SET</span>(SRC_LIST main.c)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;This is BINARY dir&quot;</span> <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;This is SOURCE dir&quot;</span> <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello-cmake <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="开始构建"><a href="#开始构建" class="headerlink" title="开始构建"></a>开始构建</h4><p>在test1目录下执行<code>cmake .</code>(. 代表当前目录)</p>
<p>这时会在当前目录生成<code>CMakeFiles</code>、<code>cmake_install.cmake</code>、<code>Makefile</code>等文件</p>
<p>我们只要关心Makefile就可以了，此时执行<code>make</code>，我们就得到了可执行文件<code>hello-cmake</code></p>
<p>运行<code>./hello-cmake</code></p>
<p>得到输出</p>
<p><code>Hello CMake!</code></p>
<h4 id="示例的语法解释"><a href="#示例的语法解释" class="headerlink" title="示例的语法解释"></a>示例的语法解释</h4><p>cmake的函数可以通过<code>cmake --help-command cmd</code>来查看具体的语法及使用方法</p>
<ul>
<li><p>PROJECT</p>
<p>  语法：</p>
  <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">project</span>(&lt;projectname&gt; [languageName1 languageName2 ... ] )</span><br></pre></td></tr></table></figure>
<p>  设置项目名称并可指定工程支持的语言，支持的语言列表是可以忽略的，默认情况表示支持所有语言。这个指令隐式的定义了两个cmake变量:</p>
<pre><code>  - &lt;projectname&gt;_BINARY_DIR
  - &lt;projectname&gt;_SOURCE_DIR
</code></pre>
<p>  因为采用的是内部编译，两个变量目前指的都是工程所在路径/home/workspace/cmake_practice/test1，后面我们会讲到外部编译，两者所指代的内容会有所不同。</p>
<p>  同时 cmake 系统也帮助我们预定义了 <code>PROJECT_BINARY_DIR</code> 和 <code>PROJECT_SOURCE_DIR</code><br>  变量，他们的值分别跟 <code>&lt;projectname&gt;_BINARY_DIR</code> 与 <code>&lt;projectname&gt;_SOURCE_DIR</code> 一致。</p>
<p>  为了统一起见，建议以后直接使用 <code>PROJECT_BINARY_DIR</code>，<code>PROJECT_SOURCE_DIR</code>，即<br>  使修改了工程名称，也不会影响这两个变量。如果使用了<br>  <code>&lt;projectname&gt;_SOURCE_DIR</code>，修改工程名称后，需要同时修改这些变量。</p>
</li>
<li><p>SET</p>
<p>  语法：</p>
  <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span>(&lt;variable&gt; &lt;value&gt;</span><br><span class="line">    [[CACHE &lt;type&gt; &lt;docstring&gt; [FORCE]] | PARENT_SCOPE])</span><br></pre></td></tr></table></figure>
<p>  在初探阶段，我们只需要知道<code>SET</code>命令可以用来显示的定义一个变量。<br>  比如在这个例子中<code>SET(SRC_LIST main.c)</code>，即定义了一个变量<code>SRC_LIST</code>，此变量的值为<code>main.c</code>。当然如果有多个源文件，可以定义为<code>SET(SRC_LIST main.c test1.c test2.c)</code>。</p>
</li>
<li><p>MESSAGE</p>
<p>  语法：</p>
  <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR]</span><br><span class="line">        <span class="string">&quot;message to display&quot;</span> ...)</span><br></pre></td></tr></table></figure>
<p>  可选关键字决定消息的类型：</p>
<ul>
<li>none          = 重要信息</li>
<li>STATUS        = 附带信息</li>
<li>WARNING       = CMake警告，继续处理</li>
<li>AUTHOR_WARNING= CMake警告（dev），继续处理</li>
<li>SEND_ERROR    = CMake错误，继续处理，但跳过生成</li>
<li>FATAL_ERROR   = CMake错误，停止处理和生成</li>
</ul>
</li>
<li><p>ADD_EXECUTABLE</p>
<p>  语法：</p>
  <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(&lt;name&gt; [WIN32] [MACOSX_BUNDLE]</span><br><span class="line">                [EXCLUDE_FROM_ALL]</span><br><span class="line">                source1 source2 ... sourceN)</span><br></pre></td></tr></table></figure>
<p>  用于生成可执行的文件，源文件列表为<code>SRC_LIST</code>定义的源文件。在本例中我们使用<code>$&#123;&#125;</code>来引用变量，这个cmake的变量使用方式。</p>
</li>
</ul>
<h4 id="基本语法规则"><a href="#基本语法规则" class="headerlink" title="基本语法规则"></a>基本语法规则</h4><p>本例中使用的基本语法规则有：</p>
<ol>
<li><p>变量使用<code>$&#123;&#125;</code>方式取值，但是在<code>IF</code>控制语句中是直接使用变量名</p>
</li>
<li><p>COMMAND(param1 param2 …)，参数间用<em>空格</em>或者<em>分号</em>分隔</p>
<p> e.g.</p>
<ul>
<li>ADD(hello-cmake main.c func.c)</li>
<li>ADD(hello-cmake main.c;func.c)</li>
</ul>
</li>
<li><p>command是大小写无关的，但是参数和变量是大小写敏感的</p>
</li>
</ol>
<h4 id="内部构建与外部构建"><a href="#内部构建与外部构建" class="headerlink" title="内部构建与外部构建"></a>内部构建与外部构建</h4><p>在本例中我们使用的是内部构建，即在<code>CMakeLists.txt</code>同级的目录下执行<code>cmake .</code>。内部构建会在SOURCE_DIR下生成很多临时的中间文件，不方便删除，也影响的源代码的阅读。</p>
<p>所以我们推荐外部构建，所谓外部构建就是在一个单独的文件夹下面执行cmake，生成的中间文件和结果都在此文件夹下。</p>
<p>对于本例，使用外部构建过程如下：</p>
<ol>
<li>首先清除test1目录下除<code>main.c</code>、<code>CMakeLists.txt</code>外的所有文件及文件夹，最关键的是CMakeCache.txt，如果不清除cache，还是会构建到之前的构建目录下。</li>
<li>在test1目录下创建build文件夹</li>
<li>进入build文件夹，执行<code>cmake ..</code>(<code>..</code>代表上一层目录，即CMakeLists所在的文件夹)</li>
<li>运行make，即可在build文件夹下生成对应的可执行文件</li>
</ol>
<p>上述过程即为out-of-source外部编译。一个最大的好处是，对于原有的工程没有任何影响，所有动作全部发生在编译目录。</p>
<p>通过外部编译进行工程构建，<code>PROJECT_SOURCE_DIR</code>仍然指代工程路径，即CMakeLists所在路径，<br>而<code>PROJECT_BINARY_DIR</code>则指代编译路径，即<code>/home/workspace/cmake_practice/test1/build</code>。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>本结我们通过一个简单的hello cmake示例，介绍了最基本的CMakeLists编写，以及一些基本的语法和命令用法。同时介绍了内部编译和外部编译，及外部编译的好处。</p>
<p>下一节我们将丰富我们的hello cmake示例，使其看起来更像一个项目。</p>
<h2 id="更像一个项目的hello-cmake"><a href="#更像一个项目的hello-cmake" class="headerlink" title="更像一个项目的hello cmake"></a>更像一个项目的hello cmake</h2><p>本节的目标是让上一节的hello cmake更像一个项目，我们接下来要做的是:</p>
<ol>
<li>为工程添加一个子目录，用来放置项目的源代码</li>
<li>添加一个子目录doc，用来工程文档<code>hello.txt</code></li>
<li>在工程目录添加COPYRIGHT和README</li>
<li>在工程目录添加一个run_hello_cmake.sh脚本，用来调用<code>hello_cmake</code>可执行文件</li>
<li>将构建的结果放置构建目录的bin子目录</li>
<li>最终安装这些文件，将<code>hello_cmake</code>二进制文件以及<code>run_hello_cmake.sh</code>安装至<code>/usr/bin</code>目录下，将doc目录下的文件以及COPYRIGHT、README安装至<code>/usr/share/doc/cmake_practice/test1</code>目录下</li>
</ol>
<h4 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h4><p>在<code>/home/workspace/cmake_practice</code>目录下建立<code>test2</code>目录，将上一节中的<code>main.c CMakeLists.txt</code>拷贝到test2目录</p>
<h4 id="添加子目录src"><a href="#添加子目录src" class="headerlink" title="添加子目录src"></a>添加子目录src</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir src</span><br><span class="line">mv main.c src</span><br></pre></td></tr></table></figure>

<p>现在工程中有一个子目录<code>src</code>以及<code>CMakeLists.txt</code>。进入子目录，添加CMakeList如下</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(hello_cmake main.c)</span><br></pre></td></tr></table></figure>

<p>将test2工程的CMakeLists修改为</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span>(hello-cmake)</span><br><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(src bin)</span><br></pre></td></tr></table></figure>

<p>然后建立build目录，进入build，执行<code>cmake .. &amp; make</code>，构建完成后，目标文件hello-cmake位于<code>build/bin</code>目录下。</p>
<h4 id="语法解释"><a href="#语法解释" class="headerlink" title="语法解释"></a>语法解释</h4><ul>
<li><p>ADD_SUBDIRECTORY</p>
<p>  语法：</p>
  <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(source_dir [binary_dir]</span><br><span class="line">                [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure>
<p>  用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置。</p>
<p>  <code>EXCLUDE_FROM_ALL</code>参数的含义是将这个目录从编译过程中排除，比如，工程的<code>example</code>，可能需要工程构建完成之后，再进入<code>example</code>目录单独进行构建。</p>
</li>
</ul>
<p>上面的例子定义了将src子目录加入工程，并指定了编译输出路径为bin目录。如果不指定bin目录，那么编译的结果都将存放在build/src目录</p>
<h4 id="换个地方保存目标二进制"><a href="#换个地方保存目标二进制" class="headerlink" title="换个地方保存目标二进制"></a>换个地方保存目标二进制</h4><p>我们可以通过SET指令重新定义<code>EXECUTABLE_OUTPUT_PATH</code>和<code>LIBRARY_OUTPUT_PATH</code>变量，来指定最终的目标二进制的位置(指最终生成的 hello_cmake或者最终的共享库，不包含编译生成的中间文件)</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_PATH&#125;</span>/bin)</span><br><span class="line"><span class="keyword">SET</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_BINARY_PATH&#125;</span>/lib)</span><br></pre></td></tr></table></figure>

<p>在第一节我们提到了<code>&lt;projectname&gt;_BINARY_DIR</code>和<code>PROJECT_BINARY_DIR</code>变量，他们指的编译发生的当前目录，如果是内部编译，就相当于<code>PROJECT_SOURCE_DIR</code>也就是工程代码所在目录，如果是外部编译，指的是外部编译所在目录，也就是本例中的<code>build</code>目录。</p>
<p>所以，上面两个指令分别定义了：可执行二进制的输出路径为<code>build/bin</code>和库的输出路径为<code>build/lib</code>。</p>
<p>至于将这两条指令写在工程的CMakeLists中还是src目录下的CMakeList，只需要按照一个原则：在哪里<code>ADD_EXECUTABLE</code>或<code>ADD_LIBRARY</code>，如果需要改变目标存放的路径，就在其上加入上述定义。</p>
<h4 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h4><p>安装的需要有两种，一种是从代码编译后直接<code>make install</code>安装，一种是打包时的指定目录安装。</p>
<p>那我们的hello_cmake应该怎么进行安装呢？</p>
<p>这里我们要用到一个新的cmake指令<code>INSTALL</code>和一个非常有用的变量<code>CMAKE_INSTALL_PREFIX</code></p>
<ul>
<li><p><code>CMAKE_INSTALL_PREFIX</code>变量类似于configure脚本的–prefix，常见的使用方法形如：</p>
<p>  <code>cmake -DCMAKE_INSTALL_PREFIX=/usr .</code></p>
</li>
<li><p><code>INSTALL</code>指令用于定义安装规则，安装的内容可以包括</p>
<ol>
<li>目标二进制</li>
<li>动态库</li>
<li>静态库</li>
<li>文件、目录、脚本</li>
</ol>
</li>
</ul>
<p>INSTALL指令包含了各种安装类型，我们需要一个个分开解释</p>
<ul>
<li><p>目标文件的安装</p>
<p>  语法：</p>
  <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS targets...</span><br><span class="line">        [[ARCHIVE|LIBRARY|RUNTIME]</span><br><span class="line">        [DESTINATION &lt;dir&gt;]</span><br><span class="line">        [PERMISSIONS permissions...]</span><br><span class="line">        [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">        [COMPONENT &lt;component&gt;]</span><br><span class="line">        [OPTIONAL]</span><br><span class="line">        ] [...])</span><br></pre></td></tr></table></figure>
<p>  参数中的<code>TARGETS</code>后面跟的就是我们通过<code>ADD_EXECUTABLE</code>或者<code>ADD_LIBRARY</code>定义的目标文件，可能是可执行二进制、动态库、静态库。</p>
<p>  目标类型也就相对应的有三种，<code>ARCHIVE</code>特指静态库，<code>LIBRARY</code>特指动态库，<code>RUNTIME</code>特指可执行目标二进制。</p>
<p>  <code>DESTINATION</code>定义了安装的路径，如果路径以/开头，那么指的是绝对路径，这时候<code>CMAKE_INSTALL_PREFIX</code>其实就无效了。如果你希望使用<code>CMAKE_INSTALL_PREFIX</code>来定义安装路径，就要写成相对路径，即不要以/开头，那么安装后的路径就是<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/&lt;DESTINATION 定义的路径&gt;</code></p>
<p>  e.g.</p>
  <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS myExe mySharedLib myStaticLib</span><br><span class="line">        RUNTIME DESTINATION bin</span><br><span class="line">        LIBRARY DESTINATION lib</span><br><span class="line">        ARCHIVE DESTINATION lib/static)</span><br></pre></td></tr></table></figure>

<p>  将会把</p>
<p>  <code>myExe</code>安装到<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/bin</code><br>  <code>mySharedLib</code>安装到<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/lib</code><br>  <code>myStaticLib</code>安装到<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/lib/static</code></p>
</li>
<li><p>普通文件的安装</p>
<p>  语法：</p>
  <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(FILES files... DESTINATION &lt;dir&gt;</span><br><span class="line">        [PERMISSIONS permissions...]</span><br><span class="line">        [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">        [COMPONENT &lt;component&gt;]</span><br><span class="line">        [RENAME &lt;name&gt;] [OPTIONAL])</span><br></pre></td></tr></table></figure>

<p>  可用于安装一般文件，并可以指定访问权限，文件名是此指令所在路径下的相对路径。如果默认不定义权限<code>PERMISSIONS</code>，安装后的权限为：</p>
<p>  <code>OWNER_WRITE</code>, <code>OWNER_READ</code>, <code>GROUP_READ</code>,和 <code>WORLD_READ</code>，即 644 权限</p>
</li>
<li><p>非目标文件的</p>
<p>  语法：</p>
  <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(PROGRAMS files... DESTINATION &lt;dir&gt;</span><br><span class="line">        [PERMISSIONS permissions...]</span><br><span class="line">        [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">        [COMPONENT &lt;component&gt;]</span><br><span class="line">        [RENAME &lt;name&gt;] [OPTIONAL])</span><br></pre></td></tr></table></figure>

<p>  跟上面的 FILES 指令使用方法一样，唯一的不同是安装后权限为:<br><code>OWNER_EXECUTE</code>, <code>GROUP_EXECUTE</code>, 和 <code>WORLD_EXECUTE</code>，即 755 权限</p>
</li>
<li><p>目录的安装</p>
<p>  语法：</p>
  <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(DIRECTORY dirs... DESTINATION &lt;dir&gt;</span><br><span class="line">        [FILE_PERMISSIONS permissions...]</span><br><span class="line">        [DIRECTORY_PERMISSIONS permissions...]</span><br><span class="line">        [USE_SOURCE_PERMISSIONS] [OPTIONAL]</span><br><span class="line">        [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">        [COMPONENT &lt;component&gt;] [FILES_MATCHING]</span><br><span class="line">        [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]</span><br><span class="line">        [EXCLUDE] [PERMISSIONS permissions...]] [...])</span><br></pre></td></tr></table></figure>

<p>  这里主要介绍其中的<code>DIRECTORY</code>、<code>PATTERN</code>、<code>PERMISSIONS</code>参数。</p>
<ul>
<li><p>DIRECTORY：后面链接的是所在source目录的相对路径。但是abc和abc/有很大区别。如果目录名不以/结尾，那么这个目录将被安装为目标路径下的abc；如果目录名以/结尾，代表将这个目录中的内容安装到目标路径，但不包括这个目录本身。</p>
</li>
<li><p>PATTERN：用于使用正则表达式进行过滤，<code>PERMISSIONS</code>用于指定PATTERN过滤后的文件权限。</p>
<p>e.g.</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSTALL</span>(DIRECTORY icons scripts/ DESTINATION share/myproj</span><br><span class="line">        PATTERN <span class="string">&quot;CVS&quot;</span> EXCLUDE</span><br><span class="line">        PATTERN <span class="string">&quot;scripts/*&quot;</span></span><br><span class="line">        PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ</span><br><span class="line">            GROUP_EXECUTE GROUP_READ)</span><br></pre></td></tr></table></figure>
<p>这条指令的执行结果是：<br>将<code>icons </code>目录安装到<code>&lt;prefix&gt;/share/myproj</code>，将<code>scripts/</code>中的内容安装到<code>&lt;prefix&gt;/share/myproj</code>不包含目录名为 CVS 的目录，对于 <code>scripts/*</code>文件指定权限为OWNER_EXECUTE OWNER_WRITE OWNER_READ GROUP_EXECUTE GROUP_READ.</p>
</li>
</ul>
</li>
<li><p>安装时CMAKE脚本的执行</p>
<p>  语法：</p>
  <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>([[SCRIPT &lt;<span class="keyword">file</span>&gt;] [CODE &lt;code&gt;]] [...])</span><br></pre></td></tr></table></figure>

<p>  SCRIPT参数用于在安装时调用cmake脚本文件（<code>也就是&lt;abc&gt;.cmake</code>文件）CODE 参数用于执行CMAKE指令，必须以双引号括起来。比如：<br>  <code>INSTALL(CODE &quot;MESSAGE(\&quot;Sample install message.\&quot;)&quot;)</code></p>
</li>
</ul>
<h4 id="让我们的hello-cmake支持安装"><a href="#让我们的hello-cmake支持安装" class="headerlink" title="让我们的hello cmake支持安装"></a>让我们的hello cmake支持安装</h4><p>安装本节开始的要求，下面改写各个目录的CMakeLists</p>
<ol>
<li>安装COPYRIGHT/README，直接修改主工程文件CMakeLists.txt，加入以下指令：<code>INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake_practice/test2)</code></li>
<li>安装<code>hello_cmake</code>、<code>run_hello_cmake.sh</code>，修改主工程文件CMakeLists.txt，加入以下指令：<code>INSTALL(PROGRAMS run_hello_cmake.sh DESTINATION bin)</code>；修改src目录下CMakeLists.txt，加入以下命令：<code>INSTALL(PROGRAMS $&#123;PROJECT_BINARY_DIR&#125;/bin/hello_cmake DESTINATION bin)</code></li>
<li>安装doc中的hello.txt，这里有两种方式：一是通过在 doc 目录建立CMakeLists.txt并将<code>doc</code>目录通过<code>ADD_SUBDIRECTORY</code>加入工程来完成。另一种方法是直接在工程目录通过<code>INSTALL(DIRECTORY 来完成)</code>。我们来尝试后者，顺便演示一下<code>DIRECTORY</code>的安装。因为<code>hello.txt</code>要安装到<code>/&lt;prefix&gt;/share/doc/cmake_practice/test2</code>，所以我们不能直接安装整个doc目录，这里采用的方式是安装doc目录中的内容，也就是使用”doc/“在工程文件中添加<code>INSTALL(DIRECTORY doc/hello.txt DESTINATION share/doc/cmake_practice/test2)</code></li>
</ol>
<p>如果没有定义<code>CMAKE_INSTALL_PREFIX</code>，会默认安装到/usr/local下</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>本小节主要描述了如何在工程中使用多目录、各种安装指令以及<code>CMAKE_INSTALL_PREFIX</code>变量。</p>
<p>在下一小节，我们将探讨如何在cmake中构建动态库和静态库，以及如何使用外部头文件和外部共享库。</p>
<h2 id="静态库与动态库"><a href="#静态库与动态库" class="headerlink" title="静态库与动态库"></a>静态库与动态库</h2><p>静态库与动态库的创建知识点并不多，主要新引入了一个新的命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD_LIBRARY</span>(&lt;name&gt; [STATIC | SHARED | MODULE]</span><br><span class="line">            [EXCLUDE_FROM_ALL]</span><br><span class="line">            source1 source2 ... sourceN)</span><br></pre></td></tr></table></figure>

<p>类型有三种：</p>
<ol>
<li><code>SHARED</code> : 动态库</li>
<li><code>STATIC</code> : 静态库</li>
<li><code>MODULE</code> : 在使用dyld的系统有效，如果不支持dyld，则被当作SHARED对待</li>
</ol>
<p><code>EXCLUDE_FROM_ALL</code>参数的意思是这个库不会被默认构建，除非有其他的组建依赖或者手工构建</p>
<h4 id="名字相同的动态库和静态库同时存在"><a href="#名字相同的动态库和静态库同时存在" class="headerlink" title="名字相同的动态库和静态库同时存在"></a>名字相同的动态库和静态库同时存在</h4><p>在同一个CMake中，如果<code>ADD_LIBRARY</code>的target名称相同，则后一个目标会覆盖前一个目标。如果我们想让名字相同的静态库和动态库同时存在，需要用到另外一个命令：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(target1 target2 ...</span><br><span class="line">                      PROPERTIES prop1 value1</span><br><span class="line">                      prop2 value2 ...)</span><br></pre></td></tr></table></figure>

<p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定<code>动态库版本</code>和<code>API版本</code>。</p>
<p>只需要在CMakeLists.txt中加如<code>SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME &quot;hello&quot;)</code>，就可以同时得到libhello.a/libhello.so两个库了。</p>
<h4 id="动态库版本号"><a href="#动态库版本号" class="headerlink" title="动态库版本号"></a>动态库版本号</h4><p>为了实现动态库版本号，我们仍然需要使用<code>SET_TARGET_PROPERTIES</code>指令。具体使用方法：<code>SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)</code></p>
<p><code>VERSION</code>指代动态库版本，<code>SOVERSION</code>指代 API 版本。</p>
<p>加如CMakeLists重新构建，在build目录下会生成：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">libhello.so.1.2</span><br><span class="line">libhello.so.1-&gt;libhello.so.1.2</span><br><span class="line">libhello.so -&gt;libhello.so.1</span><br></pre></td></tr></table></figure>

<h4 id="安装共享库和头文件"><a href="#安装共享库和头文件" class="headerlink" title="安装共享库和头文件"></a>安装共享库和头文件</h4><p>利用上一节提到的<code>INSTALL</code>指令，我们将动态库以及静态库安装到指定的目录</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSTALL</span>(TARGETS hello hello_static</span><br><span class="line">        LIBRARY DESTINATION lib</span><br><span class="line">        ARCHIVE DESTINATION lib)</span><br></pre></td></tr></table></figure>

<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>本小节，我们谈到了：</p>
<ol>
<li>如何通过<code>ADD_LIBRARY</code>指令构建动态库和静态库。</li>
<li>如何通过<code>SET_TARGET_PROPERTIES</code>同时构建同名的动态库和静态库。</li>
<li>如何通过<code>SET_TARGET_PROPERTIES</code>控制动态库版本</li>
<li>最终使用上一节谈到的<code>INSTALL</code>指令来安装动态、静态库。</li>
</ol>
<h2 id="如何使用外部共享库和头文件"><a href="#如何使用外部共享库和头文件" class="headerlink" title="如何使用外部共享库和头文件"></a>如何使用外部共享库和头文件</h2><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>在<code>/home/workspace/cmake_practice</code>目录下建立test4目录，按照上一节，编写CMakeLists，生成自己的hello动态库静态库以及头文件，并安装到/usr/local下。</p>
<h4 id="源文件和CMakeLists"><a href="#源文件和CMakeLists" class="headerlink" title="源文件和CMakeLists"></a>源文件和CMakeLists</h4><p>重复以前的步骤，建立<code>src</code>目录，编写源文件<code>main.c</code>，内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hello.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    print_hello();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写工程主文件<code>CMakeLists.txt</code></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PROJECT</span>(NEWHELLO)</span><br><span class="line"><span class="keyword">ADD_SUBDIRECTORY</span>(src)</span><br></pre></td></tr></table></figure>

<p>编写<code>src/CMakeLists.txt</code></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(main main.c)</span><br></pre></td></tr></table></figure>

<h4 id="外部构建"><a href="#外部构建" class="headerlink" title="外部构建"></a>外部构建</h4><p>按照习惯，仍然建立 build 目录，使用 cmake ..方式构建。<br>过程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>构建失败，如果需要查看细节，可以用<code>make VERBOSE=1</code>来构建</p>
<p>错误输出是：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">/home/workspace/cmake_practice/test4/src/main.c:1:19: fatal error: hello.h: No such file or directory</span><br></pre></td></tr></table></figure>

<h4 id="引入头文件搜索路径"><a href="#引入头文件搜索路径" class="headerlink" title="引入头文件搜索路径"></a>引入头文件搜索路径</h4><p>hello.h位于<code>/usr/local/include/hello</code>目录中，并没有位于系统标准的头文件路径。</p>
<p>为了让我们的工程能够找到<code>hello.h</code>头文件，我们需要引入一个新的指令<br><code>INCLUDE_DIRECTORIES</code>，其完整语法为：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...)</span><br></pre></td></tr></table></figure>

<p>这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割，如果路径中包含了空格，可以使用双引号将它括起来，默认的行为是追加到当前的头文件搜索路径的后面。</p>
<p>现在我们在<code>src/CMakeLists.txt</code>中添加一个头文件搜索路径，方式很简单，加入：<code>INCLUDE_DIRECTORIES(/usr/local/include/hello)</code></p>
<p>进入build目录，重新进行构建，这时找不到hello.h的错误已经消失，但是出现了一个新的错误：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">main.c:(.text+0xa): undefined reference to `print_hello&#x27;</span><br></pre></td></tr></table></figure>

<p>因为我们并没有link到共享库libhello上</p>
<h4 id="为target添加共享库"><a href="#为target添加共享库" class="headerlink" title="为target添加共享库"></a>为target添加共享库</h4><p>我们现在需要完成的任务是将目标文件链接到libhello，这里我们需要引入两个新的指令：</p>
<p><code>LINK_DIRECTORIES</code>和<code>TARGET_LINK_LIBRARIES</code></p>
<p>LINK_DIRECTORIES的语法是：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(directory1 directory2 ...)</span><br></pre></td></tr></table></figure>

<p>这个指令非常简单，添加非标准的共享库搜索路径，比如，在工程内部同时存在共享库和可执行二进制，在编译时就需要指定一下这些共享库的路径。这个例子中我们没有用到这个指令。</p>
<p>TARGET_LINK_LIBRARIES的语法是:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(<span class="keyword">target</span> library1</span><br><span class="line">                      &lt;debug | optimized&gt; library2</span><br><span class="line">                      ...)</span><br></pre></td></tr></table></figure>

<p>这个指令可以用来为<code>target</code>添加需要链接的共享库，本例中是一个可执行文件，但是同样可以用于为自己编写的共享库添加共享库链接。</p>
<p>为了解决我们前面遇到的<code>print_hello</code>未定义错误，我们需要作的是向<br>src/CMakeLists.txt中添加如下指令：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LINK_DIRECTORIES</span>(/usr/local/lib)</span><br><span class="line"><span class="keyword">TARGET_LINK_LIBRARIES</span>(main hello)</span><br></pre></td></tr></table></figure>

<p>这里的hello指的是我们上一节构建的共享库libhello。</p>
<p>进入build目录重新进行构建。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>这是我们就得到了一个连接到libhello的可执行程序 main，位于 build/src目录，运行main的结果是输出：</p>
<p><code>Hello CMake!</code></p>
<p>让我们来检查一下<code>main</code>的链接情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost src]# ldd main</span><br><span class="line">        linux-vdso.so.1 =&gt;  (0x00007ffdb59ea000)</span><br><span class="line">        libhello.so.1 =&gt; /usr/local/lib/libhello.so.1 (0x00007fe24b577000)</span><br><span class="line">        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fe24b18e000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007fe24b77a000)</span><br></pre></td></tr></table></figure>

<p>可以清楚的看到<code>main</code>确实链接了共享库<code>libhello</code>，而且链接的是动态库<br><code>libhello.so.1</code></p>
<p>那如何链接到静态库呢？方法很简单：将<code>TARGET_LINK_LIBRRARIES</code>指令修改为:</p>
<p><code>TARGET_LINK_LIBRARIES(main libhello.a)</code></p>
<p>重新构建后再来看一下<code>main</code>的链接情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost src]# ldd main</span><br><span class="line">        linux-vdso.so.1 =&gt;  (0x00007fffa2597000)</span><br><span class="line">        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fb216c97000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007fb217080000)</span><br></pre></td></tr></table></figure>

<p>说明<code>main</code>确实链接到了静态库<code>libhello.a</code>。</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>本节我们探讨了:</p>
<ul>
<li>如何通过<code>INCLUDE_DIRECTORIES</code>指令加入非标准的头文件搜索路径。</li>
<li>如何通过<code>LINK_DIRECTORIES</code>指令加入非标准的库文件搜索路径。</li>
<li>如果通过<code>TARGET_LINK_LIBRARIES</code>为库或可执行二进制加入库链接。</li>
</ul>
<p>到这里为止，您应该基本可以使用<code>cmake</code>工作了，但是还有很多高级的话题没有探讨，比如<strong>编译条件检查</strong>、<strong>编译器定义</strong>、<strong>平台判断</strong>等等。</p>
<p>到这里，或许你可以理解前面讲到的“cmake的使用过程其实就是学习cmake语言并编写cmake程序的过程”，既然是“cmake语言”，自然涉及到变量、语法等。</p>
<p>下一节，我们将抛开程序的话题，看看常用的CMAKE变量以及一些基本的控制语法规则。</p>
<h2 id="CMake常用变量和常用环境变量"><a href="#CMake常用变量和常用环境变量" class="headerlink" title="CMake常用变量和常用环境变量"></a>CMake常用变量和常用环境变量</h2><p>使用<code>$&#123;&#125;</code>进行变量的引用。在IF等语句中，是直接使用变量名而不通过<code>$&#123;&#125;</code>取值。</p>
<h4 id="CMake常用变量"><a href="#CMake常用变量" class="headerlink" title="CMake常用变量"></a>CMake常用变量</h4><ul>
<li><p><code>CMAKE_BINARY_DIR</code></p>
<p>  <code>PROJECT_BINARY_DIR</code></p>
<p>  <code>&lt;projectname&gt;_BINARY_DIR</code></p>
<p>  这三个变量指代的内容是一致的，如果是<code>in source</code>编译，指得就是工程顶层目录，如果是<code>out-of-source</code>编译，指的是工程编译发生的目录。<code>PROJECT_BINARY_DIR</code>跟其他指令稍有区别，现在，你可以理解为他们是一致的。</p>
</li>
<li><p><code>CMAKE_SOURCE_DIR</code></p>
<p>  <code>PROJECT_SOURCE_DIR</code></p>
<p>  <code>&lt;projectname&gt;_SOURCE_DIR</code></p>
<p>  这三个变量指代的内容是一致的，不论采用何种编译方式，都是工程顶层目录。也就是在<code>in source</code>编译时，他跟<code>CMAKE_BINARY_DIR</code>等变量一致。<code>PROJECT_SOURCE_DIR</code>跟其他指令稍有区别，现在，你可以理解为他们是一致的。</p>
</li>
<li><p><code>CMAKE_CURRENT_SOURCE_DIR</code></p>
</li>
</ul>
<p>指的是当前处理的<code>CMakeLists.txt</code>所在的路径，比如上面我们提到的src子目录。</p>
<ul>
<li><code>CMAKE_CURRRENT_BINARY_DIR</code></li>
</ul>
<p>如果是<code>in-source</code>编译，它跟<code>CMAKE_CURRENT_SOURCE_DIR</code>一致，如果是<code>out-ofsource</code>编译，他指的是<code>target</code>编译目录。使用我们上面提到的<code>ADD_SUBDIRECTORY(src bin)</code>可以更改这个变量的值。<br>使用<code>SET(EXECUTABLE_OUTPUT_PATH &lt;新路径&gt;)</code>并不会对这个变量造成影响，它仅仅修改了最终目标文件存放的路径。</p>
<ul>
<li><code>CMAKE_MODULE_PATH</code></li>
</ul>
<p>这个变量用来定义自己的 cmake 模块所在的路径。如果你的工程比较复杂，有可能会自己编写一些 cmake 模块，这些 cmake 模块是随你的工程发布的，为了让 cmake 在处理CMakeLists.txt 时找到这些模块，你需要通过 SET 指令，将自己的 cmake 模块路径设置一下。<br>比如</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span>(CMAKE_MODULE_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/cmake)</span><br></pre></td></tr></table></figure>

<p>这时候你就可以通过<code>INCLUDE</code>指令来调用自己的模块了。</p>
<h4 id="CMake调用环境变量"><a href="#CMake调用环境变量" class="headerlink" title="CMake调用环境变量"></a>CMake调用环境变量</h4><p>使用<code>$ENV&#123;NAME&#125;</code>指令就可以调用系统的环境变量了。</p>
<p>比如</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;HOME dir: $ENV&#123;HOME&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>设置环境变量的方式是：</p>
<p><code>SET(ENV&#123;KEY&#125; VALUE)</code></p>
<h4 id="主要开关选项"><a href="#主要开关选项" class="headerlink" title="主要开关选项"></a>主要开关选项</h4><ul>
<li><code>BUILD_SHARED_LIBS</code></li>
</ul>
<p>这个开关用来控制默认的库编译方式，如果不进行设置，使用 ADD_LIBRARY并没有指定库类型的情况下，默认编译生成的库都是静态库。<br>如果<code>SET(BUILD_SHARED_LIBS ON)</code>后，默认生成的为动态库。</p>
<ul>
<li><code>CMAKE_C_FLAGS</code></li>
</ul>
<p>设置C编译选项，也可以通过指令<code>ADD_DEFINITIONS()</code>添加。</p>
<ul>
<li><code>CMAKE_CXX_FLAGS</code></li>
</ul>
<p>设置C++编译选项，也可以通过指令<code>ADD_DEFINITIONS()</code>添加。</p>
<h2 id="CMake常用指令"><a href="#CMake常用指令" class="headerlink" title="CMake常用指令"></a>CMake常用指令</h2><h4 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h4><ul>
<li><code>ADD_DEFINITIONS</code></li>
</ul>
<p>向C/C++编译器添加-D定义，比如:<code>ADD_DEFINITIONS(-DENABLE_DEBUG -DABC)</code>，参数之间用空格分割。如果你的代码中定义了<code>#ifdef ENABLE_DEBUG #endif</code>，这个代码块就会生效。如果要添加其他的编译器开关，可以通过<code>CMAKE_C_FLAGS</code>变量和<code>CMAKE_CXX_FLAGS</code>变量设置</p>
<ul>
<li><code>ADD_DEPENDENCIES</code></li>
</ul>
<p>定义target依赖的其他target，确保在编译本target之前，其他的 target 已经被构建。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD_DEPENDENCIES</span>(<span class="keyword">target</span>-name depend-target1</span><br><span class="line">                 depend-target2 ...)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ADD_TEST</code>与<code>ENABLE_TESTING</code></li>
</ul>
<p><code>ENABLE_TESTING</code>指令用来控制Makefile是否构建test目标，涉及工程所有目录。语法很简单，没有任何参数，ENABLE_TESTING()，一般情况这个指令放在工程的主CMakeLists.txt中。</p>
<p><code>ADD_TEST</code>指令的语法是:<code>ADD_TEST(testname Exename arg1 arg2 ...)</code></p>
<p>testname是自定义的test名称，Exename可以是构建的目标文件也可以是外部脚本等等。后面连接传递给可执行文件的参数。如果没有在同一个CMakeLists.txt 中打开<code>ENABLE_TESTING()</code>指令，任何<code>ADD_TEST</code>都是无效的。</p>
<p>比如我们前面的Helloworld例子，可以在工程主CMakeLists.txt 中添加</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD_TEST</span>(mytest <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/bin/main)</span><br><span class="line"><span class="keyword">ENABLE_TESTING</span>()</span><br></pre></td></tr></table></figure>

<p>生成<code>Makefile</code>后，就可以运行<code>make test</code>来执行测试了。</p>
<ul>
<li><code>AUX_SOURCE_DIRECTORY</code></li>
</ul>
<p>基本语法：<code>AUX_SOURCE_DIRECTORY(dir VARIABLE)</code></p>
<p>作用是发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表。因为目前 cmake 还不能自动发现新添加的源文件。</p>
<p>比如</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span>(. SRC_LIST)</span><br><span class="line"><span class="keyword">ADD_EXECUTABLE</span>(main <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>你也可以通过后面提到的<code>FOREACH</code>指令来处理这个<code>LIST</code></p>
<ul>
<li><code>CMAKE_MINIMUM_REQUIRED</code></li>
</ul>
<p>其语法为<code>CMAKE_MINIMUM_REQUIRED(VERSION versionNumber [FATAL_ERROR])</code> 比如 <code>CMAKE_MINIMUM_REQUIRED(VERSION 2.5 FATAL_ERROR)</code> 如果cmake版本小与 2.5，则出现严重错误，整个过程中止。</p>
<ul>
<li><code>EXEC_PROGRAM</code></li>
</ul>
<p>在CMakeLists.txt处理过程中执行命令，并不会在生成的Makefile中执行。具体语法为：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC_PROGRAM</span>(Executable [directory in which to run]</span><br><span class="line">            [ARGS &lt;arguments to executable&gt;]</span><br><span class="line">            [OUTPUT_VARIABLE &lt;var&gt;]</span><br><span class="line">            [RETURN_VALUE &lt;var&gt;])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用于在指定的目录运行某个程序，通过ARGS添加参数，如果要获取输出和返回值，可通过<code>OUTPUT_VARIABLE</code>和<code>RETURN_VALUE</code>分别定义两个变量。</p>
<p>这个指令可以帮助你在<code>CMakeLists.txt</code>处理过程中支持任何命令，比如根据系统情况去修改代码文件等等。</p>
<p>举个简单的例子，我们要在src目录执行ls命令，并把结果和返回值存下来。</p>
<p>可以直接在src/CMakeLists.txt中添加：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC_PROGRAM</span>(ls ARGS <span class="string">&quot;*.c&quot;</span> OUTPUT_VARIABLE LS_OUTPUT RETURN_VALUE LS_RVALUE)</span><br><span class="line"><span class="keyword">IF</span>(<span class="keyword">not</span> LS_RVALUE)</span><br><span class="line">    <span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;ls result: &quot;</span> <span class="variable">$&#123;LS_OUTPUT&#125;</span>)</span><br><span class="line"><span class="keyword">ENDIF</span>(<span class="keyword">not</span> LS_RVALUE)</span><br></pre></td></tr></table></figure>

<p>在cmake生成Makefile的过程中，就会执行ls命令，如果返回0，则说明成功执行，那么就输出 ls *.c 的结果。关于IF语句，后面的控制指令会提到。</p>
<ul>
<li><p><code>FILE</code></p>
<ul>
<li>FILE(WRITE filename “message to write”… )</li>
<li>FILE(APPEND filename “message to write”… )</li>
<li>FILE(READ filename variable)</li>
<li>FILE(GLOB variable [RELATIVE path] [globbing expressions]…)</li>
<li>FILE(GLOB_RECURSE variable [RELATIVE path] [globbing expressions]…)</li>
<li>FILE(REMOVE [directory]…)</li>
<li>FILE(REMOVE_RECURSE [directory]…)</li>
<li>FILE(MAKE_DIRECTORY [directory]…)</li>
<li>FILE(RELATIVE_PATH variable directory file)</li>
<li>FILE(TO_CMAKE_PATH path result)</li>
<li>FILE(TO_NATIVE_PATH path result)</li>
</ul>
</li>
</ul>
<p>这里的语法都比较简单，不在展开介绍了。</p>
<ul>
<li><code>INCLUDE</code></li>
</ul>
<p>用来载入CMakeLists.txt文件，也用于载入预定义的cmake模块。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INCLUDE</span>(file1 [OPTIONAL])</span><br><span class="line"><span class="keyword">INCLUDE</span>(module [OPTIONAL])</span><br></pre></td></tr></table></figure>

<p>OPTIONAL参数的作用是文件不存在也不会产生错误。你可以指定载入一个文件，如果定义的是一个模块，那么将在<code>CMAKE_MODULE_PATH</code>中搜索这个模块并载入。载入的内容将在处理到INCLUDE语句是直接执行。</p>
<ul>
<li><p><code>FILE_</code>指令</p>
<ul>
<li><p>FIND_FILE(<VAR> name1 path1 path2 …)</p>
<p>  VAR 变量代表找到的文件全路径，包含文件名</p>
</li>
<li><p>FIND_LIBRARY(<VAR> name1 path1 path2 …)</p>
<p>  VAR 变量表示找到的库全路径，包含库文件名</p>
</li>
<li><p>FIND_PATH(<VAR> name1 path1 path2 …)</p>
<p>  VAR 变量代表包含这个文件的路径。</p>
</li>
<li><p>FIND_PROGRAM(<VAR> name1 path1 path2 …)</p>
<p>  VAR 变量代表包含这个程序的全路径。</p>
</li>
<li><p>FIND_PACKAGE(<name> [major.minor] [QUIET] [NO_MODULE] [[REQUIRED|COMPONENTS] [componets…]])</p>
<p>  用来调用预定义在 CMAKE_MODULE_PATH 下的 Find<name>.cmake 模块，你也可以自己定义<code>Find&lt;name&gt;</code>模块，通过<code>SET(CMAKE_MODULE_PATH dir)</code>将其放入工程的某个目录中供工程使用，我们在后面的章节会详细介绍<code>FIND_PACKAGE</code>的使用方法和<code>Find</code>模块的编写。</p>
<p>  FIND_LIBRARY 示例：</p>
  <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FIND_LIBRARY</span>(libX X11 /usr/lib)</span><br><span class="line"><span class="keyword">IF</span>(<span class="keyword">NOT</span> libX)</span><br><span class="line">    <span class="keyword">MESSAGE</span>(FATAL_ERROR “libX <span class="keyword">not</span> found”)</span><br><span class="line"><span class="keyword">ENDIF</span>(<span class="keyword">NOT</span> libX)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="控制命令"><a href="#控制命令" class="headerlink" title="控制命令"></a>控制命令</h4><ul>
<li><code>IF</code></li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">IF</span>(expression)</span><br><span class="line">    <span class="comment"># THEN section.</span></span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">ELSE</span>(expression)</span><br><span class="line">    <span class="comment"># ELSE section.</span></span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">ENDIF</span>(expression)</span><br></pre></td></tr></table></figure>

<p>另外一个指令是<code>ELSEIF</code>，总体把握一个原则，凡是出现IF的地方一定要有对应的ENDIF。出现 ELSEIF 的地方，ENDIF是可选的。</p>
<p>表达式的使用方法如下:</p>
<p>IF(var)，如果变量不是：空，0，N, NO, OFF, FALSE, NOTFOUND 或<br><var>_NOTFOUND 时，表达式为真。</p>
<p>IF(NOT var )，与上述条件相反。</p>
<p>IF(var1 AND var2)，当两个变量都为真是为真。</p>
<p>IF(var1 OR var2)，当两个变量其中一个为真时为真。</p>
<p>IF(COMMAND cmd)，当给定的 cmd 确实是命令并可以调用是为真。</p>
<p>IF(EXISTS dir)或者 IF(EXISTS file)，当目录名或者文件名存在时为真。</p>
<p>IF(file1 IS_NEWER_THAN file2)，当 file1 比 file2 新，或者 file1/file2 其中有一个不存在时为真，文件名请使用完整路径。</p>
<p>IF(IS_DIRECTORY dirname)，当 dirname 是目录时，为真。</p>
<p>IF(variable MATCHES regex)</p>
<p>IF(string MATCHES regex)<br>当给定的变量或者字符串能够匹配正则表达式 regex 时为真。比如：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">IF</span>(<span class="string">&quot;hello&quot;</span> <span class="keyword">MATCHES</span> <span class="string">&quot;ell&quot;</span>)</span><br><span class="line">    <span class="keyword">MESSAGE</span>(<span class="string">&quot;true&quot;</span>)</span><br><span class="line"><span class="keyword">ENDIF</span>(<span class="string">&quot;hello&quot;</span> <span class="keyword">MATCHES</span> <span class="string">&quot;ell&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>数字比较表达式:</p>
<ul>
<li>IF(variable LESS number)</li>
<li>IF(string LESS number)</li>
<li>IF(variable GREATER number)</li>
<li>IF(string GREATER number)</li>
<li>IF(variable EQUAL number)</li>
<li>IF(string EQUAL number)</li>
</ul>
<p>按照字母序的排列进行比较:</p>
<ul>
<li>IF(variable STRLESS string)</li>
<li>IF(string STRLESS string)</li>
<li>IF(variable STRGREATER string)</li>
<li>IF(string STRGREATER string)</li>
<li>IF(variable STREQUAL string)</li>
<li>IF(string STREQUAL string)</li>
</ul>
<p>IF(DEFINED variable)，如果变量被定义，为真。</p>
<p>一个小例子，用来判断平台差异：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">IF</span>(WIN32)</span><br><span class="line">    <span class="keyword">MESSAGE</span>(STATUS “This is windows.”)</span><br><span class="line">    <span class="comment">#作一些 Windows 相关的操作</span></span><br><span class="line"><span class="keyword">ELSE</span>(WIN32)</span><br><span class="line">    <span class="keyword">MESSAGE</span>(STATUS “This is <span class="keyword">not</span> windows”)</span><br><span class="line">    <span class="comment">#作一些非 Windows 相关的操作</span></span><br><span class="line"><span class="keyword">ENDIF</span>(WIN32)</span><br></pre></td></tr></table></figure>

<p>上述代码用来控制在不同的平台进行不同的控制，但是，阅读起来却并不是那么舒服，ELSE(WIN32)之类的语句很容易引起歧义。</p>
<p>这就用到了我们在“常用变量”一节提到的<code>CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS</code>开<br>关。可以<code>SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)</code><br>这时候就可以写成:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">IF</span>(WIN32)</span><br><span class="line"><span class="keyword">ELSE</span>()</span><br><span class="line"><span class="keyword">ENDIF</span>()</span><br></pre></td></tr></table></figure>

<p>如果配合 ELSEIF 使用，可能的写法是这样:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">IF</span>(WIN32)</span><br><span class="line">    <span class="comment">#do something related to WIN32</span></span><br><span class="line"><span class="keyword">ELSEIF</span>(UNIX)</span><br><span class="line">    <span class="comment">#do something related to UNIX</span></span><br><span class="line"><span class="keyword">ELSEIF</span>(APPLE)</span><br><span class="line">    <span class="comment">#do something related to APPLE</span></span><br><span class="line"><span class="keyword">ENDIF</span>(WIN32)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>WHILE</code></li>
</ul>
<p>WHILE 指令的语法是：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WHILE</span>(condition)</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">ENDWHILE</span>(condition)</span><br></pre></td></tr></table></figure>

<p>其真假判断条件可以参考 IF 指令。</p>
<ul>
<li><code>FOREACH</code></li>
</ul>
<p>FOREACH 指令的使用方法有三种形式：</p>
<ol>
<li><p>列表</p>
 <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FOREACH</span>(loop_var arg1 arg2 ...)</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">ENDFOREACH</span>(loop_var)</span><br></pre></td></tr></table></figure>

<p> 像我们前面使用的<code>AUX_SOURCE_DIRECTORY</code>的例子</p>
 <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span>(. SRC_LIST)</span><br><span class="line"><span class="keyword">FOREACH</span>(F <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line">    <span class="keyword">MESSAGE</span>(<span class="variable">$&#123;F&#125;</span>)</span><br><span class="line"><span class="keyword">ENDFOREACH</span>(F)</span><br></pre></td></tr></table></figure>
</li>
<li><p>范围</p>
 <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FOREACH</span>(loop_var RANGE total)</span><br><span class="line"><span class="keyword">ENDFOREACH</span>(loop_var)</span><br></pre></td></tr></table></figure>

<p> 从 0 到 total 以1为步进</p>
<p> 举例如下：</p>
 <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FOREACH</span>(VAR RANGE <span class="number">10</span>)</span><br><span class="line"><span class="keyword">MESSAGE</span>(<span class="variable">$&#123;VAR&#125;</span>)</span><br><span class="line"><span class="keyword">ENDFOREACH</span>(VAR)</span><br><span class="line">最终得到的输出是：</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>范围和步进</p>
</li>
</ol>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FOREACH</span>(loop_var RANGE start stop [step])</span><br><span class="line"><span class="keyword">ENDFOREACH</span>(loop_var)</span><br></pre></td></tr></table></figure>

<p>从start开始到stop结束，以step为步进，举例如下:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FOREACH</span>(A RANGE <span class="number">5</span> <span class="number">15</span> <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">MESSAGE</span>(<span class="variable">$&#123;A&#125;</span>)</span><br><span class="line"><span class="keyword">ENDFOREACH</span>(A)</span><br></pre></td></tr></table></figure>

<p>最终得到的结果是：5 8 11 14</p>
<p>这个指令需要注意的是，知道遇到<code>ENDFOREACH</code>指令，整个语句块才会得到真正的执行。</p>
<h2 id="模块的使用和自定义模块"><a href="#模块的使用和自定义模块" class="headerlink" title="模块的使用和自定义模块"></a>模块的使用和自定义模块</h2><p>本章我们将着重介绍系统预定义的<code>Find</code>模块的使用以及自己编写<code>Find</code>模块，系统中提供了其他各种模块，一般情况需要使用<code>INCLUDE</code>指令显式的调用，<code>FIND_PACKAGE</code>指令是一个特例，可以直接调用预定义的模块。</p>
<p>在本章，我们基于我们前面的libhello共享库，编写一个FindHello.cmake模块。</p>
<p>对于系统预定义的<code>Find&lt;name&gt;.cmake</code>模块，每一个模块都会定义以下几个变量：</p>
<ul>
<li><code>&lt;name&gt;_FOUND</code></li>
<li><code>&lt;name&gt;_INCLUDE_DIR</code> or <code>&lt;name&gt;_INCLUDES</code></li>
<li><code>&lt;name&gt;_LIBRARY</code> or <code>&lt;name&gt;_LIBRARIES</code></li>
</ul>
<p>你可以通过<code>&lt;name&gt;_FOUND</code>来判断模块是否被找到，如果没有找到，按照工程的需要关闭某些特性、给出提醒或者中止编译。</p>
<p>如果<code>&lt;name&gt;_FOUND</code>为真，则将<code>&lt;name&gt;_INCLUDE_DIR</code>加入<code>INCLUDE_DIRECTORIES</code>，将<code>&lt;name&gt;_LIBRARY</code>加入 <code>TARGET_LINK_LIBRARIES</code>中。</p>
<h4 id="编写FindHello模块"><a href="#编写FindHello模块" class="headerlink" title="编写FindHello模块"></a>编写FindHello模块</h4><p>我们在此前的test3实例中，演示了构建动态库、静态库的过程并进行了安装。接下来，我们在test6示例中演示如何自定义<code>FindHello</code>模块并使用这个模块构建工程：</p>
<p>请在建立<code>/home/workspace/cmake_practice</code>中建立test6目录，并在其中建立cmake目录用于存放我们自己定义的<code>FindHello.cmake</code>模块，同时建立<code>src</code>目录，用于存放我们的源文件。</p>
<p>定义<code>cmake/FindHello.cmake</code>模块</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FIND_PATH</span>(HELLO_INCLUDE_DIR hello.h /usr/local/<span class="keyword">include</span>/hello /usr/<span class="keyword">include</span>/hello)</span><br><span class="line"><span class="keyword">FIND_LIBRARY</span>(HELLO_LIBRARY NAMES hello PATH /usr/local/lib /usr/lib)</span><br><span class="line"><span class="keyword">IF</span>(HELLO_INCLUDE_DIR <span class="keyword">AND</span> HELLO_LIBRARY)</span><br><span class="line">        <span class="keyword">SET</span>(HELLO_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">ENDIF</span>()</span><br><span class="line"><span class="keyword">IF</span>(HELLO_FOUND)</span><br><span class="line">        <span class="keyword">IF</span>(<span class="keyword">NOT</span> Hello_FIND_QUIETLY)</span><br><span class="line">                <span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;Found Hello: $&#123;HELLO_LIBRARY&#125;&quot;</span>)</span><br><span class="line">        <span class="keyword">ENDIF</span>()</span><br><span class="line"><span class="keyword">ELSE</span>()</span><br><span class="line">        <span class="keyword">IF</span>(Hello_FIND_REQUIRED)</span><br><span class="line">                <span class="keyword">MESSAGE</span>(FATAL_ERROR <span class="string">&quot;Cound not find hello library&quot;</span>)</span><br><span class="line">        <span class="keyword">ENDIF</span>()</span><br><span class="line"><span class="keyword">ENDIF</span>()</span><br></pre></td></tr></table></figure>

<p><code>QUIET</code>参数，对应与我们编写的<code>FindHello</code>中的 <code>HELLO_FIND_QUIETLY</code>，如果不指定这个参数，就会执行：<br><code>MESSAGE(STATUS &quot;Found Hello: $&#123;HELLO_LIBRARY&#125;&quot;)</code></p>
<p><code>REQUIRED</code>参数，其含义是指这个共享库是否是工程必须的，如果使用了这个参数，说明这个链接库是必备库，如果找不到这个链接库，则工程不能编译。对应于<code>FindHello.cmake</code>模块中的<code>HELLO_FIND_REQUIRED</code>变量。<br>同样，我们在上面的模块中定义了<code>HELLO_FOUND</code>,<code>HELLO_INCLUDE_DIR</code>,<code>HELLO_LIBRARY</code>变量供开发者在<code>FIND_PACKAGE</code>指令中使用。</p>
<p>在src/main.c中写入如下内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hello.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        print_hello();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立src/CMakeLists.txt文件，内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FIND_PACKAGE</span>(Hello)</span><br><span class="line"><span class="keyword">IF</span>(HELLO_FOUND)</span><br><span class="line">        <span class="keyword">ADD_EXECUTABLE</span>(hello main.c)</span><br><span class="line">        <span class="keyword">INCLUDE_DIRECTORIES</span>(<span class="variable">$&#123;HELLO_INCLUDE_DIR&#125;</span>)</span><br><span class="line">        <span class="keyword">TARGET_LINK_LIBRARIES</span>(hello <span class="variable">$&#123;HELLO_LIBRARY&#125;</span>)</span><br><span class="line"><span class="keyword">ENDIF</span>(HELLO_FOUND)</span><br></pre></td></tr></table></figure>

<p>为了能够让工程找到<code>FindHello.cmake</code>模块(存放在工程中的cmake目录)我们在主工程文件CMakeLists.txt中加入：<br><code>SET(CMAKE_MODULE_PATH $&#123;PROJECT_SOURCE_DIR&#125;/cmake)</code></p>
<p>仍然采用外部编译的方式，建立build目录，进入目录运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure>

<p>我们可以从输出中看到：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">-- Found Hello: /usr/local/lib/libhello.so</span><br></pre></td></tr></table></figure>

<p>如果没有找到hello library呢？</p>
<p>我们可以尝试将/usr/local/lib/libhello.x 移动到/tmp目录，这样，按照FindHello模块的定义，就找不到hello library了，我们再来看一下构建结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure>

<p>仍然可以成功进行构建，但是这时候是没有办法编译的。修改 <code>FIND_PACKAGE(HELLO)</code>为<code>FIND_PACKAGE(HELLO REQUIRED)</code>，将 hello library定义为工程必须的共享库。</p>
<p>这时候再次运行 cmake ..</p>
<p>我们得到如下输出：</p>
<p><code>CMake Error: Could not find hello library.</code></p>
<p>因为找不到libhello.x，所以，整个Makefile生成过程被出错中止。</p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>CMake</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>关于EDCC算法的诞生、原理、效果</title>
    <url>/posts/4354/</url>
    <content><![CDATA[<h2 id="EDCC-Enhanced-and-Discriminative-Competitive-Code-高效、准确的掌纹识别算法"><a href="#EDCC-Enhanced-and-Discriminative-Competitive-Code-高效、准确的掌纹识别算法" class="headerlink" title="EDCC(Enhanced and Discriminative Competitive Code): 高效、准确的掌纹识别算法"></a>EDCC(Enhanced and Discriminative Competitive Code): 高效、准确的掌纹识别算法</h2><h3 id="掌纹识别技术的优势"><a href="#掌纹识别技术的优势" class="headerlink" title="掌纹识别技术的优势"></a>掌纹识别技术的优势</h3><p>作为新崛起的生物特征识别技术之一，掌纹识别可以从分辨率较低的图像中提取出稳定、抗噪能力强且具有识别力的特征。对比其他的生物特征识别技术，掌纹识别技术有以下优势：</p>
<ol>
<li>与指纹相比，掌纹的识别面积更大，包含的信息更丰富，而且掌纹比指纹更不易受损具有长期稳定性。掌纹识别对图像的分辨率要求不是特别高，所以在采集设备的造价比指纹低很多。</li>
<li>与人脸相比，掌纹不受眼镜、表情、妆容等因素的影响，稳定性较高，并且在用户接受度方面，掌纹的采集方式对用户更加友好。</li>
<li>与虹膜、DNA相比，掌纹的识别准确率虽然不及它们，但是掌纹采集设备造价远低于这两种生物特征识别技术的采集设备。</li>
<li>与签名、步态等行为特征相比，掌纹识别不受人们习惯的影响，特征不会随着时间改变，并且识别的准确率远高于行为特征。</li>
</ol>
<p>综上所述，掌纹识别有识别精度高、采集设备成本低、稳定性高、用户接受度高等优点，在生活中的应用越来越广泛。</p>
<h3 id="掌纹识别的基本步骤"><a href="#掌纹识别的基本步骤" class="headerlink" title="掌纹识别的基本步骤"></a>掌纹识别的基本步骤</h3><p>掌纹特征识别过程分为数据库的创建和特征库的检索。</p>
<ul>
<li>数据库创建通过采集注册样本，进行预处理、特征提取工作，之后形成数据库</li>
<li>特征库检索通过采集待测试的样本，在预处理和提取特征之后与掌纹数据库中的数据进行匹配，得到该待测样本的类别。</li>
</ul>
<h3 id="掌纹特征提取方法"><a href="#掌纹特征提取方法" class="headerlink" title="掌纹特征提取方法"></a>掌纹特征提取方法</h3><p>掌纹特征提取方法主要分为四大类，分别为基于结构的方法、基于统计的方法、基于子空间的方法以及基于编码的方法。</p>
<ol>
<li>基于结构的方法主要是利用掌纹中主线和褶皱的方向和位置信息实现掌纹识别的方法，此类方法最为直观。但是无论是哪一种边缘检测算子都无法提取出所有的纹线，所以此类方法实用性很差，已经被人们渐渐放弃。</li>
<li>基于统计的方法主要是利用统计特征，例如均值、方差等组成一组用来描述掌纹图像的特征向量，可以根据是否分块这一特性分为局部统计变量方法和全局统计量方法。基于局部统计量的方法通过将图像分成若干小块，分别统计每个小块的统计信息，然后将这些统计信息组合表示为整个掌纹的统计特征向量，如采用傅里叶变换、小波变换等方式获得掌纹图像的每个分块统计信息并进行识别。</li>
<li>基于子空间的方法是将原始掌纹图像看做普通的图片模式，将图片对应的高维矩阵通过投影映射运算转化为低维向量或矩阵。根据投影变换的实现方式，分为线性子空间法和非线性子空间法。常用的子空间特征提取方法有主成分分析法(PCA)，FisherPalm方法，BDPCA(Bi-directional PCA)等。</li>
<li>基于编码的方法是将掌纹图像看作纹理图像，根据某些规则对纹理图像进行编码。Zhang等提出了一种名为PalmCode的编码方法，该方法首先采用2DGabor对图像进行滤波处理，然后根据滤波结果的实部和虚部的正负来进行编码。Kong等提出使用六个方向的Gabor滤波器对掌纹图像滤波, 并对幅值最小的方向编码, 称为竞争编码(Competitive code)。由于竞争编码考察了掌纹图像的方向信息，对光照不敏感，因此识别精度很高。</li>
</ol>
<h2 id="EDCC"><a href="#EDCC" class="headerlink" title="EDCC"></a>EDCC</h2><p>掌纹充满了线条和纹理特征，具备丰富的方向信息。因此，基于方向编码被认为是最有效的掌纹特征提取方法。而竞争编码是辨识度极高的编码方法之一，它使用不同方向的滤波器与掌纹图像进行卷积，之后根据一定的编码规则对掌纹图像进行编码。</p>
<p>EDCC算法有以下关键点:</p>
<ol>
<li>通过图像增强算子处理原始掌纹图像，使得纹线更加突出，提取的方向更加准确。</li>
<li>使用一组方向不同的2DGabor小波滤波器对图像进行滤波。</li>
<li>选择滤波响应值最大和次大的方向作为该点所在纹线的主要方向和次要方向，进而进行编码。</li>
</ol>
<p>下面将对这三个关键点进行详细解释。</p>
<h3 id="图像增强"><a href="#图像增强" class="headerlink" title="图像增强"></a>图像增强</h3><p>拉普拉斯算子是图像锐化常用的方法，锐化可以增强图像的对比度，突出灰度值变化明显的部分，使比较模糊的纹线变得清晰。</p>
<p>典型的核大小为的拉普拉斯算子:<img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb3382cb19d.png"></p>
<p>使用上式中的算子对如下掌纹图像进行卷积</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb33f8436b2.bmp"></p>
<p>得到增强掌纹后的结果如下图所示。</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb343537443.png"></p>
<p>纹线明显被增强显示出来，而且纹线处的灰度值大大高于周围皮肤灰度值。</p>
<p>实验表明，拉普拉斯增强算子可以有效的增强纹线对比度。所以EDCC算法在对图像使用2DGabor小波滤波之前，先对图像进行拉普拉斯变换。</p>
<h3 id="2DGabor小波"><a href="#2DGabor小波" class="headerlink" title="2DGabor小波"></a>2DGabor小波</h3><p>2DGabor小波滤波器与人类视觉刺激响应非常相似。如下图所示，</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb399728299.png"></p>
<p>第一行是人类视觉感受野，第二行是Gabor小波滤波器，第三行是两者之间的残差，可见两者及其相似。而且Gabor小波可以变换方向和尺度，对于不同方向的纹线都能很好地适应。</p>
<p>函数形式表示如下：</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb3a260404b.png"></p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb3a4a20358.png"></p>
<p>取3个尺度，6个方向构成一组滤波器，并对掌纹图像进行卷积，得到结果如下图所示</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb3ab3874ed.png"></p>
<p>不难发现，经过2DGabor小波滤波后的掌纹纹线非常清晰。</p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>采用一组尺度统一方向不同的2DGabor小波滤波器对图像做卷积后，可以得到掌纹图像每一个像素点对应的响应值，不难推断最大响应值对应的滤波器方向可以近似表示该点的掌纹线方向，但并不是纹线准确的方向。</p>
<p>如下图所示，选择掌纹图像主线上的两个像素点与一组方向个数为6的2DGabor小波滤波器进行卷积，并计算相应滤波响应值。然后确定具有最大滤波响应的取向作为主要方向，从图中可以看出，(a)和(b)主要方向是相同的。</p>
<p>实际上，这两个像素的真正的主要方向分别在提取的主要方向的左侧和右侧。这种现象也在掌纹的其他部位也可以发现。因此，基于最大滤波响应提取的主要方向并不能准确地表示掌纹真实的方向。</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb3ce12a9be.png"></p>
<p>根据滤波响应提取掌纹主要方向的方法基于掌纹图像中的像素属于一条线的基本假设。当滤波器的方向与掌纹的主要方向相同时，滤波响应将达到最大值。</p>
<p>换句话说，滤波器响应与主线和滤波器之间的重叠程度成正比。然而，因为在实践中使用的滤波器方向有限，可能没有Gabor滤波器具有与掌纹图像的主要方向相同的取向。结果，在这种情况下，提取的方向不能准确地表示掌纹的主要方向特征。</p>
<p>通常来说，2DGabor小波滤波器方向越靠近掌纹的主要方向，得到的滤波响应就越大。因此，提取主要方向（通常也具有较大的滤波响应）的相邻方向可以与主要方向相结合，来更准确地表示掌纹图像。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>首先使用一个尺度、N个方向的一组2DGabor小波滤波器对图像进行卷积。<br>掌纹纹线上的一点I(x, y)的主要方向通过计算该点最大响应值对应的滤波器方向来确定。即: <img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb44de0bec2.png"></p>
<p>式中：C是掌纹图像的主要方向。令Cleft和Cright表示主要方向相邻的方向<img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb452103f23.png"></p>
<p>通过比较Cleft和Cright方向对应的响应值，得到次要方向Cs的编码<img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb455ea7c52.png"></p>
<p>由于C表示掌纹图像的主要方向特征，Cs表示次要方向特征，所以结合C和Cs能够较为准确表示纹线的真实方向。</p>
<p>(C, Cs)的计算例子如下图所示</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb45a465ef2.png"></p>
<h4 id="匹配方式"><a href="#匹配方式" class="headerlink" title="匹配方式"></a>匹配方式</h4><p>在掌纹图像的匹配阶段，使用与竞争编码方法相似但不同的角距离来确定两个掌纹图像之间的相似度。</p>
<p>两个掌纹图像和之间的匹配得分定义为：<img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb56ad4c0fd.png"></p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb56db5a549.png"></p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在掌纹验证这一步中，令掌纹数据库中每个掌纹图像与剩下所有的图像一一对比。假如两幅图像来自同一人，则称之为同类匹配，否则称之为异类匹配。</p>
<p>在多光谱数据库中，每个人有12张手掌图片，每个光谱对应的数据库有6000张图片，所以有个匹配，其中同类匹配有33000个，异类匹配有17964000个。在同济大学掌纹数据库中，同类匹配有114000个，异类匹配有71880000个。图5.7展示了使用EDCC算法在多光谱数据库以及同济大学数据库上得到的匹配得分分布情况。可以发现，同类匹配得分与异类匹配得分明显分离，并且同类匹配得分远高于异类匹配得分。</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb57ffdd9f8.png"></p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb588595119.png"><br><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb584ff209b.png"></p>
<p><strong>(a)-(e)分别为Red,Green,Blue,NIR,同济大学数据库</strong></p>
<p>正确接受率(GAR)和错误接受率(FAR)可以评估算法的性能，ROC曲线通过设置所有可能的阈值进而得到对应的GAR和FAR值，并以FAR、GAR的值做为横、纵坐标绘制曲线。</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb61e520e28.png"></p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb620f24c4a.png"><br><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb622756e76.png"></p>
<p><strong>(a)-(e)分别为Red,Green,Blue,NIR,同济大学数据库</strong></p>
<p>上图展示了EDCC算法、DCC算法、小波变换分块统计算法以及BDPCA+LDA算法在不同数据库上验证得到的ROC曲线。忽略产生过拟合的BDPCA+LDA算法，不难发现，当FAR相同时，EDCC算法的GAR最高。</p>
<p>等误率(Equal Error Rate, EER)是FAR=FRR对应的值。去除掉存在过拟合问题的BDPCA+LDA算法，不同算法对应的EER如表下表所示。可以发现，EDCC算法在所有数据库上达到了最低的EER。对比DCC算法，EDCC算法的EER下降率最大达到了73%((5.5105-1.4728)/5.5105)，平均下降率也在50%左右。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">EDCC</th>
<th align="center">DCC</th>
<th align="center">小波变换分块信息统计</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Red</td>
<td align="center">1.2612</td>
<td align="center">4.0145</td>
<td align="center">2.2772</td>
</tr>
<tr>
<td align="center">Green</td>
<td align="center">1.8715</td>
<td align="center">4.7460</td>
<td align="center">3.3249</td>
</tr>
<tr>
<td align="center">Blue</td>
<td align="center">1.7455</td>
<td align="center">4.5881</td>
<td align="center">3.2456</td>
</tr>
<tr>
<td align="center">NIR</td>
<td align="center">1.4728</td>
<td align="center">5.5105</td>
<td align="center">2.0192</td>
</tr>
<tr>
<td align="center">同济大学</td>
<td align="center">3.6116</td>
<td align="center">5.3703</td>
<td align="center">6.6747</td>
</tr>
</tbody></table>
<h3 id="识别"><a href="#识别" class="headerlink" title="识别"></a>识别</h3><p>识别是指通过逐个匹配数据库内的掌纹，确定一个未知掌纹来自何人。</p>
<p>在本文的掌纹识别实验中，将每个手掌的N(N=1,2,3,4)张掌纹图像组成训练集，剩下的掌纹图像组成测试集。将测试集中的每张图像与训练集一一比较，来计算匹配得分，训练集中得分最高的样本对应的类别作为该测试图片的类别，通过此方法可以计算不同算法在不同训练集大小下的错误识别率。</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb648e1e44e.png"></p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb64bc52383.png"><br><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/10/21/59eb64d98edd3.png"></p>
<p><strong>(a)-(e)分别为Red,Green,Blue,NIR,同济大学数据库</strong></p>
<p>实验结果如上图所示。可以发现，EDCC算法在训练样本较少时，仍然可以取得较高的识别率，并且在训练样本个数相同的条件下，EDCC算法的错误率明显低于其他算法，换句话说，EDCC算法可以使用更少的训练样本得到更高的识别准确率。</p>
]]></content>
      <categories>
        <category>我的开源项目</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>整理一些常用的 Git 指令</title>
    <url>/posts/ce41/</url>
    <content><![CDATA[<h1 id="GitHub创建仓库提示代码"><a href="#GitHub创建仓库提示代码" class="headerlink" title="GitHub创建仓库提示代码"></a>GitHub创建仓库提示代码</h1><pre><code>echo &quot;# 项目名&quot; &gt;&gt; README.md
git init
git add README.md
git commit -m &quot;first commit&quot;
git remote add origin git@github.com:Leosocy/项目名.git
git push -u origin master
</code></pre>
<p>若仓库存在直接push</p>
<pre><code>git remote add origin git@github.com:Leosocy/test.git
git push -u origin master
</code></pre>
<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h4 id="创建仓库（初始化）"><a href="#创建仓库（初始化）" class="headerlink" title="创建仓库（初始化）"></a>创建仓库（初始化）</h4><pre><code>在当前指定目录下创建
git init

新建一个仓库目录
git init [project-name]

克隆一个远程项目
git clone [url]
</code></pre>
<h4 id="添加文件到缓存区"><a href="#添加文件到缓存区" class="headerlink" title="添加文件到缓存区"></a>添加文件到缓存区</h4><pre><code>添加所有变化的文件
 git add .

添加名称指定文件
git add text.txt
</code></pre>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><pre><code>设置提交代码时的用户信息
git config [--global] user.name &quot;[name]&quot;
git config [--global] user.email &quot;[email address]&quot;
</code></pre>
<h4 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h4><pre><code>提交暂存区到仓库区
git commit -m &quot;msg&quot;

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
</code></pre>
<h4 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h4><pre><code># 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all
</code></pre>
<h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><pre><code># 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 切换到上一个分支
$ git checkout -

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
</code></pre>
<h4 id="标签Tags"><a href="#标签Tags" class="headerlink" title="标签Tags"></a>标签Tags</h4><pre><code>添加标签 在当前commit
git tag -a v1.0 -m &#39;xxx&#39; 

添加标签 在指定commit
git tag v1.0 [commit]

查看
git tag

删除
git tag -d V1.0

删除远程tag
git push origin :refs/tags/[tagName]

推送
git push origin --tags

拉取
git fetch origin tag V1.0

新建一个分支，指向某个tag
git checkout -b [branch] [tag]
</code></pre>
<h4 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h4><pre><code># 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 搜索提交历史，根据关键词
$ git log -S [keyword]

# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示过去5次提交
$ git log -5 --pretty --oneline

# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [file]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示今天你写了多少行代码
$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog
</code></pre>
<h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><pre><code># 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]

# 恢复暂存区的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]

# 暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop
</code></pre>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><pre><code># 生成一个可供发布的压缩包
$ git archives
</code></pre>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Google C++ 编程风格</title>
    <url>/posts/71b3/</url>
    <content><![CDATA[<p>C++ 是 Google 大部分开源项目的主要编程语言。正如每个 C++ 程序员都知道的， C++ 有很多强大的特性， 但这种强大不可避免的导致它走向复杂，使代码更容易产生 bug， 难以阅读和维护。</p>
<p>本指南的目的是通过详细阐述 C++ 注意事项来驾驭其复杂性。这些规则在保证代码易于管理的同时， 也能高效使用 C++ 的语言特性。</p>
<span id="more"></span>

<p>风格， 亦被称作可读性， 也就是指导 C++ 编程的约定. 使用术语 “风格” 有些用词不当， 因为这些习惯远不止源代码文件格式化这么简单。</p>
<p>使代码易于管理的方法之一是加强代码一致性。让任何程序员都可以快速读懂你的代码这点非常重要。保持统一编程风格并遵守约定意味着可以很容易根据 “模式匹配” 规则来推断各种标识符的含义。创建通用， 必需的习惯用语和模式可以使代码更容易理解。在一些情况下可能有充分的理由改变某些编程风格， 但我们还是应该遵循一致性原则，尽量不这么做。</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>一个<code>.cc/.cpp</code>文件都应该对应一个<code>.h</code>文件。也有些常见例外，例如单元测试代码和只包含<code>main()</code>入口函数的源文件。</p>
<h4 id="Self-contained-头文件"><a href="#Self-contained-头文件" class="headerlink" title="Self-contained 头文件"></a>Self-contained 头文件</h4><blockquote>
<p>Tip: 头文件应该能够自给自足（<strong>self-contained</strong>，也就是可以作为第一个头文件被引入），简单来说就是头文件中依赖的其他声明要在头文件中定义清楚，而不能依赖在<code>.cc</code>文件中调整引入顺序解决依赖。</p>
</blockquote>
<p>如果<code>.h</code>文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的<code>.cc</code>文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。</p>
<p>有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 .cc 文件里。</p>
<h4 id="define保护"><a href="#define保护" class="headerlink" title="#define保护"></a>#define保护</h4><blockquote>
<p>Tip: 所有头文件都应该使用 <code>#define</code> 来防止头文件被多重包含， 命名格式当是: <code>&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_</code>。</p>
</blockquote>
<p>为保证唯一性， 头文件的命名应该基于所在项目源代码树的全路径. 例如， 项目 <code>foo</code>中的头文件<code>foo/src/bar/baz.h</code>可按如下方式保护:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FOO_BAR_BAZ_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOO_BAR_BAZ_H_</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// FOO_BAR_BAZ_H_</span></span></span><br></pre></td></tr></table></figure>

<p><code>#define</code> 与 <code>#pragma once</code>区别</p>
<p><code>#pragma once</code>是编译相关，就是说这个编译系统上能用，但在其他编译系统不一定可以，也就是说移植性差。</p>
<p>所以尽量使用<code>#ifndef</code>来避免头文件重复引用。</p>
<h4 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h4><blockquote>
<p>Tip: 尽可能地<strong>避免使用</strong>前置声明。使用 #include 包含需要的头文件即可。</p>
</blockquote>
<p>所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义。</p>
<ul>
<li><p>优点</p>
<ul>
<li>前置声明能够节省编译时间，多余的<code>#include</code>会迫使编译器展开更多的文件，处理更多的输入。</li>
<li>前置声明能够节省不必要的重新编译的时间。<code>#include</code>使代码因为头文件中无关的改动而被重新编译多次。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。</p>
</li>
<li><p>前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其API。例如扩大形参类型，加个自带默认参数的模板形参等等。</p>
</li>
<li><p>前置声明来自命名空间 <code>std::</code>的symbol时，其<strong>行为未定义</strong>。</p>
</li>
<li><p>很难判断什么时候该用前置声明，什么时候该用<code>#include</code>。极端情况下，用前置声明代替<code>includes</code>甚至都会暗暗地改变代码的含义：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.h:</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : B &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good_user.cc:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;b.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(B*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(D* x)</span> </span>&#123; <span class="built_in">f</span>(x); &#125;  <span class="comment">// calls f(B*)</span></span><br></pre></td></tr></table></figure>

<p>  如果<code>#include</code>被 B 和 D 的前置声明替代，<code>test()</code>就会调用<code>f(void*)</code>。</p>
</li>
<li><p>前置声明了不少来自头文件的symbol时，就会比单单一行的<strong>include冗长</strong>。</p>
</li>
<li><p>仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂。</p>
</li>
</ul>
</li>
<li><p>结论</p>
<ul>
<li>尽量避免前置声明那些定义在其他项目中的实体。</li>
<li>函数：总是使用<code>#include</code>。</li>
<li>类模板：优先使用<code>#include</code>。</li>
</ul>
</li>
</ul>
<h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><blockquote>
<p>Tip: 只有当函数只有<strong>10行甚至更少</strong>时才将其定义为内联函数。</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  当函数被声明为内联函数之后， 编译器会将其内联展开， 而不是按通常的函数调用机制进行调用。</p>
</li>
<li><p>优点</p>
<p>  只要内联的函数体较小， 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短， 性能关键的函数， 鼓励使用内联。</p>
</li>
<li><p>缺点</p>
<p>  滥用内联将导致程序变得更慢。内联可能使目标代码量或增或减， 这取决于内联函数的大小。内联非常短小的存取函数通常会减少代码大小， 但内联一个相当大的函数将戏剧性的增加代码大小。现代处理器由于更好的利用了指令缓存， 小巧的代码往往执行更快。</p>
</li>
<li><p>结论</p>
<p>  一个较为合理的经验准则是， <strong>不要内联超过10行</strong>的函数。<strong>谨慎对待析构函数</strong>， 析构函数往往比其表面看起来要更长， 因为有隐含的成员和基类析构函数被调用!</p>
<p>  有些函数即使声明为内联的也不一定会被编译器内联， 这点很重要; 比如<strong>虚函数</strong>和<strong>递归函数</strong>就不会被正常内联。通常， 递归函数不应该声明成内联函数，递归调用堆栈的展开并不像循环那么简单， 比如递归层数在编译时可能是未知的， 大多数编译器都不支持内联递归函数。虚函数内联的主要原因则是想把它的函数体放在类定义内， 为了图个方便， 抑或是当作文档描述其行为， 比如精短的存取函数.</p>
</li>
</ul>
<h4 id="include的路径及顺序"><a href="#include的路径及顺序" class="headerlink" title="#include的路径及顺序"></a><code>#include</code>的路径及顺序</h4><blockquote>
<p>Tip: 使用标准的头文件包含顺序可增强可读性， 避免隐藏依赖: 相关头文件， C 库， C++ 库， 其他库的 .h， 本项目内的 .h。</p>
</blockquote>
<p>项目内头文件应按照项目源代码目录树结构排列， 避免使用 UNIX 特殊的快捷目录<code>.</code>(当前目录)或<code>..</code>(上级目录). 例如， <code>google-awesome-project/src/base/logging.h</code>应该按如下方式包含:</p>
<blockquote>
<p><code>#include &quot;base/logging.h&quot;</code></p>
</blockquote>
<p>又如，<code>dir/foo.cc</code>或<code>dir/foo_test.cc</code>的主要作用是实现或测试<code>dir2/foo2.h</code>的功能，<code>foo.cc</code>中包含头文件的次序如下：</p>
<ol>
<li><code>dir2/foo2.h</code>（优先位置，详情如下）</li>
<li>C 系统文件</li>
<li>C++ 系统文件</li>
<li>其他库的<code>.h</code>文件</li>
<li>本项目内<code>.h</code>文件</li>
</ol>
<p>这种优先的顺序排序保证当<code>dir2/foo2.h</code>遗漏某些必要的库时，<code>dir/foo.cc</code>或<code>dir/foo_test.cc</code>的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。</p>
<p>您所依赖的符号(symbols)被哪些头文件所定义，您就应该包含<code>(include)</code>哪些头文件，前置声明(forward declarations)情况除外。比如您要用到<code>bar.h</code>中的某个符号， 哪怕您所包含的 <code>foo.h</code>已经包含了<code>bar.h</code>， 也照样得包含<code>bar.h</code>， 除非 <code>foo.h</code>有明确说明它会自动向您提供<code>bar.h</code>中的symbol。 不过，凡是cc文件所对应的「相关头文件」已经包含的，就不用再重复包含进其cc文件里面了，就像<code>foo.cc</code>只包含<code>foo.h</code>就够了，不用再管后者所包含的其它内容。</p>
<p>举例来说，<code>google-awesome-project/src/foo/internal/fooserver.cc</code>的包含次序如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo/public/fooserver.h&quot;</span> <span class="comment">// 优先位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hash_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/basictypes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/commandlineflags.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo/public/bar.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol>
<li>避免多重包含</li>
<li>头文件尽量避免使用前置声明，直接<code>include</code></li>
<li>内联函数最好少于10行。类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的<code>.cc</code>文件里</li>
<li>包含文件的次序除了美观之外， 最重要的是可以减少隐藏依赖，使每个头文件在“最需要编译”的地方编译。</li>
</ol>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><blockquote>
<p>Tip: 鼓励在<code>.cc</code>文件内使用匿名命名空间或<code>static</code>声明. 使用具名的命名空间时，其名称可基于项目名或相对路径。**禁止使用using指示(using-directive e.g. using namespace foo;)**。禁止使用内联命名空间(inline namespace)。</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  命名空间将全局作用域细分为独立的， 具名的作用域， 可有效防止全局作用域的命名冲突。</p>
</li>
<li><p>优点</p>
<p>  类已经提将命名分割在不同类的作用域内， 命名空间在这基础上又封装了一层。</p>
<p>  举例来说， 两个不同项目的全局作用域都有一个类<code>Foo</code>， 这样在编译或运行时造成冲突。如果每个项目将代码置于不同命名空间中，<code>project1::Foo</code>和<code>project2::Foo</code>作为不同符号自然不会冲突。</p>
<p>  内联命名空间会自动把内部的标识符放到外层作用域，比如：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> X &#123;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> Y &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  <span class="comment">// namespace Y</span></span><br><span class="line">&#125;  <span class="comment">// namespace X</span></span><br></pre></td></tr></table></figure>

<p>  <code>X::Y::foo()</code>与<code>X::foo()</code>彼此可代替。内联命名空间主要用来保持跨版本的 ABI 兼容性。</p>
</li>
<li><p>缺点</p>
<p>  命名空间具有迷惑性， 因为它们使得区分两个相同命名所指代的定义更加困难。</p>
<p>  内联命名空间很容易令人迷惑，毕竟其内部的成员不再受其声明所在命名空间的限制。内联命名空间只在大型版本控制里有用。</p>
</li>
<li><p>结论</p>
<p>  根据下文将要提到的策略合理使用命名空间。</p>
<ul>
<li><p>遵守<code>命名空间命名</code>中的规则。</p>
</li>
<li><p>像之前的几个例子中一样，在命名空间的最后注释出命名空间的名字。</p>
</li>
<li><p>用命名空间把文件包含， 以及类的前置声明<strong>以外</strong>的整个源文件封装起来， 以区别于其它命名空间:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h 文件</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有声明都置于命名空间中</span></span><br><span class="line"><span class="comment">// 注意不要使用缩进</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace mynamespace</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .cc 文件</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义都置于命名空间中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace mynamespace</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不要在命名空间<code>std</code>内声明任何东西， 包括标准库的类前置声明。在<code>std</code>命名空间声明实体是未定义的行为， 会导致如不可移植。声明标准库下的实体， 需要包含对应的头文件。</p>
</li>
<li><p>不应该使用<code>using</code>指示 引入整个命名空间的标识符号。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 禁止 —— 污染命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> foo;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要在头文件中使用<code>命名空间别名</code>除非显式标记内部命名空间使用。因为任何在头文件中引入的命名空间都会成为公开API的一部分。</p>
</li>
<li><p>禁止用内联命名空间</p>
</li>
</ul>
</li>
</ul>
<h4 id="匿名命名空间和静态变量"><a href="#匿名命名空间和静态变量" class="headerlink" title="匿名命名空间和静态变量"></a>匿名命名空间和静态变量</h4><blockquote>
<p>Tip: 在<code>.cc</code>文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为<code>static</code>。但是不要在<code>.h</code>文件中这么做。</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  所有置于匿名命名空间的声明都具有内部链接性，函数和变量可以经由声明为<code>static</code>拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。</p>
</li>
<li><p>结论</p>
<p>  推荐、鼓励在<code>.cc</code>中对于不需要在其他地方引用的标识符使用内部链接性声明，但是不要在<code>.h</code>中使用。</p>
<p>  匿名命名空间的声明和具名的格式相同，在最后注释上<code>namespace</code>:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="非成员函数、静态成员函数和全局函数"><a href="#非成员函数、静态成员函数和全局函数" class="headerlink" title="非成员函数、静态成员函数和全局函数"></a>非成员函数、静态成员函数和全局函数</h4><blockquote>
<p>Tip: 使用静态成员函数或命名空间内的非成员函数，尽量不要用裸的全局函数。将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关。</p>
</blockquote>
<ul>
<li><p>优点</p>
<p>  某些情况下，非成员函数和静态成员函数是非常有用的，将非成员函数放在命名空间内可避免污染全局作用域。</p>
</li>
<li><p>缺点</p>
<p>  将非成员函数和静态成员函数作为新类的成员或许更有意义，当它们需要访问外部资源或具有重要的依赖关系时更是如此。</p>
</li>
<li><p>结论</p>
<p>  有时，把函数的定义同类的实例脱钩是有益的，甚至是必要的。这样的函数可以被定义成静态成员，或是非成员函数。非成员函数不应依赖于外部变量，应尽量置于某个命名空间内。相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类，不如使用<code>2.1命名空间</code>。举例而言，对于头文件<code>myproject/foo_bar.h</code>，应当使用</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="keyword">namespace</span> foo_bar &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  <span class="comment">// namespace foo_bar</span></span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure>

<p>  而非</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure>

<p>  定义在同一编译单元的函数，被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖；静态成员函数对此尤其敏感。可以考虑提取到新类中，或者将函数置于独立库的命名空间内。</p>
<p>  如果你必须定义非成员函数，又只是在<code>.cc</code>文件中使用它，可使用<code>匿名命名空间</code>或<code>static</code>链接关键字(如<code>static int Foo() &#123;...&#125;</code>) 限定其作用域。</p>
</li>
</ul>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><blockquote>
<p>Tip: 将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化。</p>
</blockquote>
<p>C++允许在函数的任何位置声明变量。我们提倡在尽可能小的作用域中声明变量，离第一次使用越近越好。这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值。特别是，应使用初始化的方式替代声明再赋值, 比如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line">i = <span class="built_in">f</span>(); <span class="comment">// 坏——初始化和声明分离</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="built_in">g</span>(); <span class="comment">// 好——初始化时声明</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">// 用花括号初始化更好</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 好——v 一开始就初始化</span></span><br></pre></td></tr></table></figure>

<p>属于<code>if</code>,<code>while</code>和<code>for</code>语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了，举例而言:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="type">const</span> <span class="type">char</span>* p = <span class="built_in">strchr</span>(str, <span class="string">&#x27;/&#x27;</span>)) str = p + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数。这会导致效率降低。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 低效的实现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    Foo f;    <span class="comment">// 构造函数和析构函数分别调用 1000000 次!</span></span><br><span class="line">    f.<span class="built_in">DoSomething</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Foo f;    <span class="comment">// 构造函数和析构函数只调用 1 次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    f.<span class="built_in">DoSomething</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态和全局变量"><a href="#静态和全局变量" class="headerlink" title="静态和全局变量"></a>静态和全局变量</h4><blockquote>
<p>Tip: 禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。</p>
</blockquote>
<p>静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型<code>(POD : Plain Old Data)</code>: 即<code>int</code>,<code>char</code>和<code>float</code>, 以及 POD类型的<code>指针</code>、<code>数组</code>和<code>结构体</code>。</p>
<p>静态变量的构造函数、析构函数和初始化的顺序在<code>C++</code>中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的 bug。所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化POD 变量，除非该函数（比如 getenv() 或 getpid() ）不涉及任何全局变量。函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。</p>
<p>综上所述，我们只允许POD类型的静态变量，即<strong>完全禁用</strong><code>vector</code>(使用 C 数组替代) 和<code>string</code>(使用<code>const char []</code>)。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ol>
<li><code>cc</code>中的匿名命名空间可避免命名冲突, 限定作用域, 避免直接使用<code>using</code>关键字污染命名空间</li>
<li>尽量不用全局函数和全局变量, 考虑作用域和命名空间限制, 尽量单独形成编译单元</li>
<li>多线程中的全局变量 (含静态成员变量) 不要使用<code>class</code>类型(含 STL 容器), 避免不明确行为导致的 bug</li>
<li>局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效</li>
</ol>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类是 C++ 中代码的基本单元. 显然, 它们被广泛使用. 本节列举了在写一个类时的主要注意事项.</p>
<h4 id="构造函数的职责"><a href="#构造函数的职责" class="headerlink" title="构造函数的职责"></a>构造函数的职责</h4><ul>
<li><p>总述</p>
<p>  不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.</p>
</li>
<li><p>定义</p>
<p>  在构造函数中可以进行各种初始化操作.</p>
</li>
<li><p>优点</p>
<ul>
<li>无需考虑类是否被初始化</li>
<li>经过构造函数完全初始化后的对象可以为<code>const</code>类型, 也能更方便地被标准容器或算法使用</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患.</li>
<li>如果执行失败, 会得到一个初始化失败的对象, 这个对象有可能进入不正常的状态, 必须使用<code>bool isValid()</code>或类似这样的机制才能检查出来, 然而这是一个十分容易被疏忽的方法.</li>
<li>构造函数的地址是无法被取得的, 因此, 举例来说, 由构造函数完成的工作是无法以简单的方式交给其他线程的.</li>
</ul>
</li>
<li><p>结论</p>
<p>  构造函数不允许调用虚函数. 如果代码允许, 直接终止程序是一个合适的处理错误的方式. 否则, 考虑用<code>Init()</code>方法或工厂函数.</p>
</li>
</ul>
<h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><ul>
<li><p>总述</p>
<p>  不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用<code>explicit</code>关键字.</p>
</li>
<li><p>定义</p>
<p>  隐式类型转换允许一个某种类型 (称作 源类型) 的对象被用于需要另一种类型 (称作 目的类型) 的位置, 例如, 将一个<code>int</code>类型的参数传递给需要<code>double</code>类型的函数.</p>
<p>  <code>explicit</code>关键字可以用于构造函数或 (在 C++11 引入) 类型转换运算符, 以保证只有当目的类型在调用点被显式写明时才能进行类型转换,例如使用<code>cast</code>. 这不仅作用于隐式类型转换, 还能作用于 C++11 的列表初始化语法:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x, <span class="type">double</span> y)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(Foo f)</span></span>;</span><br></pre></td></tr></table></figure>

<p>  此时下面的代码是不允许的:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Func</span>(&#123;<span class="number">42</span>, <span class="number">3.14</span>&#125;);  <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>  这一代码从技术上说并非隐式类型转换, 但是语言标准认为这是<code>explicit</code>应当限制的行为.</p>
</li>
<li><p>优点</p>
<ul>
<li>有时目的类型名是一目了然的, 通过避免显式地写出类型名, 隐式类型转换可以让一个类型的可用性和表达性更强.</li>
<li>隐式类型转换可以简单地取代函数重载.</li>
<li>在初始化对象时, 列表初始化语法是一种简洁明了的写法.</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>隐式类型转换会隐藏类型不匹配的错误. 有时, 目的类型并不符合用户的期望, 甚至用户根本没有意识到发生了类型转换.</li>
<li>隐式类型转换会让代码难以阅读, 尤其是在有函数重载的时候, 因为这时很难判断到底是哪个函数被调用.</li>
<li>单参数构造函数有可能会被无意地用作隐式类型转换.</li>
<li>如果单参数构造函数没有加上<code>explicit</code>关键字, 读者无法判断这一函数究竟是要作为隐式类型转换, 还是作者忘了加上<code>explicit</code>标记.</li>
<li>并没有明确的方法用来判断哪个类应该提供类型转换, 这会使得代码变得含糊不清.</li>
<li>如果目的类型是隐式指定的, 那么列表初始化会出现和隐式类型转换一样的问题, 尤其是在列表中只有一个元素的时候.</li>
</ul>
</li>
<li><p>结论</p>
<p>  在类型定义中, 类型转换运算符和单参数构造函数都应当用<code>explicit</code>进行标记. 一个例外是, 拷贝和移动构造函数不应当被标记为<code>explicit</code>, 因为它们并不执行类型转换.</p>
<p>  不能以一个参数进行调用的构造函数不应当加上<code>explicit</code>. 接受一个<code>std::initializer_list</code>作为参数的构造函数也应当省略 <code>explicit</code>, 以便支持拷贝初始化 (例如<code>MyType m = &#123;1, 2&#125;;</code>)</p>
</li>
</ul>
<h4 id="可拷贝类型和可移动类型"><a href="#可拷贝类型和可移动类型" class="headerlink" title="可拷贝类型和可移动类型"></a>可拷贝类型和可移动类型</h4><ul>
<li><p>总述</p>
<p>  如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.</p>
</li>
<li><p>定义</p>
<p>  可拷贝类型允许对象在初始化时得到来自相同类型的另一对象的值, 或在赋值时被赋予相同类型的另一对象的值, 同时不改变源对象的值. 对于用户定义的类型, 拷贝操作一般通过拷贝构造函数与拷贝赋值操作符定义. <code>string</code>类型就是一个可拷贝类型的例子.</p>
<p>  可移动类型允许对象在初始化时得到来自相同类型的临时对象的值, 或在赋值时被赋予相同类型的临时对象的值 (因此所有可拷贝对象也是可移动的). <code>std::unique_ptr&lt;int&gt;</code>就是一个可移动但不可复制的对象的例子. 对于用户定义的类型, 移动操作一般是通过移动构造函数和移动赋值操作符实现的.</p>
<p>  拷贝 / 移动构造函数在某些情况下会被编译器隐式调用. 例如, 通过传值的方式传递对象.</p>
</li>
<li><p>优点</p>
<p>  可移动及可拷贝类型的对象可以通过传值的方式进行传递或者返回, 这使得 API 更简单, 更安全也更通用. 与传指针和引用不同, 这样的传递不会造成所有权, 生命周期, 可变性等方面的混乱, 也就没必要在协议中予以明确. 这同时也防止了客户端与实现在非作用域内的交互, 使得它们更容易被理解与维护. 这样的对象可以和需要传值操作的通用 API 一起使用, 例如大多数容器.</p>
<p>  拷贝 / 移动构造函数与赋值操作一般来说要比它们的各种替代方案, 比如<code>Clone()</code>, <code>CopyFrom()</code> or <code>Swap()</code>, 更容易定义, 因为它们能通过编译器产生, 无论是隐式的还是通过<code>= default</code>. 这种方式很简洁, 也保证所有数据成员都会被复制. 拷贝与移动构造函数一般也更高效, 因为它们不需要堆的分配或者是单独的初始化和赋值步骤, 同时,对于类似省略不必要的拷贝这样的优化它们也更加合适.</p>
<p>  移动操作允许隐式且高效地将源数据转移出右值对象. 这有时能让代码风格更加清晰.</p>
</li>
<li><p>缺点</p>
<p>  许多类型都不需要拷贝, 为它们提供拷贝操作会让人迷惑, 也显得荒谬而不合理. 单件类型(<code>Registerer</code>), 与特定的作用域相关的类型 (<code>Cleanup</code>), 与其他对象实体紧耦合的类型 (<code>Mutex</code>) 从逻辑上来说都不应该提供拷贝操作. 为基类提供拷贝 / 赋值操作是有害的, 因为在使用它们时会造成对象切割. 默认的或者随意的拷贝操作实现可能是不正确的, 这往往导致令人困惑并且难以诊断出的错误.</p>
<p>  拷贝构造函数是隐式调用的, 也就是说, 这些调用很容易被忽略. 这会让人迷惑, 尤其是对那些所用的语言约定或强制要求传引用的程序员来说更是如此. 同时, 这从一定程度上说会鼓励过度拷贝, 从而导致性能上的问题.</p>
</li>
<li><p>结论</p>
<p>  如果需要就让你的类型可拷贝 / 可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一眼就能看出来的, 那就不要把类型设置为可拷贝. 如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义, 反之亦然. 如果让类型可拷贝, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义. 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作.</p>
<p>  如果定义了拷贝/移动操作, 则要保证这些操作的默认实现是正确的. 记得时刻检查默认操作的正确性, 并且在文档中说明类是可拷贝的且/或可移动的.</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(Foo&amp;&amp; other) : <span class="built_in">field_</span>(other.field) &#123;&#125;</span><br><span class="line">    <span class="comment">// 差, 只定义了移动构造函数, 而没有定义对应的赋值运算符.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Field field_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  由于存在对象切割的风险, 不要为任何有可能有派生类的对象提供赋值操作或者拷贝 / 移动构造函数 (当然也不要继承有这样的成员函数的类). 如果你的基类需要可复制属性, 请提供一个<code>public virtual Clone()</code>和一个<code>protected</code>的拷贝构造函数以供派生类实现.</p>
<p>  如果你的类不需要拷贝 / 移动操作, 请显式地通过在<code>public</code>域中使用<code>= delete</code>或其他手段禁用之.</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyClass is neither copyable nor movable.</span></span><br><span class="line"><span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="结构体-VS-类"><a href="#结构体-VS-类" class="headerlink" title="结构体 VS 类"></a>结构体 VS 类</h4><ul>
<li><p>总述</p>
<p>  仅当只有数据成员时使用<code>struct</code>, 其它一概使用<code>class</code>.</p>
</li>
<li><p>说明</p>
<p>  在 C++ 中<code>struct</code>和<code>class</code>关键字几乎含义一样. 我们为这两个关键字添加我们自己的语义理解, 以便为定义的数据类型选择合适的关键字.</p>
<p>  <code>struct</code>用来定义包含数据的被动式对象, 也可以包含相关的常量, 但除了存取数据成员之外, 没有别的函数功能. 并且存取功能是通过直接访问位域, 而非函数调用. 除了构造函数, 析构函数, <code>Initialize()</code>, <code>Reset()</code>, <code>Validate()</code> 等类似的用于设定数据成员的函数外, 不能提供其它功能的函数.</p>
<p>  如果需要更多的函数功能, <code>class</code>更适合. 如果拿不准, 就用 <code>class</code>.</p>
<p>  为了和STL保持一致, 对于仿函数等特性可以不用<code>class</code>而是使用<code>struct</code>.</p>
<p>  注意: 类和结构体的成员变量使用不同的命名规则.</p>
</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul>
<li><p>总述</p>
<p>  使用组合常常比使用继承更合理. 如果使用继承的话, 定义为 public 继承.</p>
</li>
<li><p>定义</p>
<p>  当子类继承基类时, 子类包含了父基类所有数据及操作的定义. C++ 实践中, 继承主要用于两种场合: 实现继承, 子类继承父类的实现代码; 接口继承, 子类仅继承父类的方法名称.</p>
</li>
<li><p>优点</p>
<p>  实现继承通过原封不动的复用基类代码减少了代码量. 由于继承是在编译时声明, 程序员和编译器都可以理解相应操作并发现错误. 从编程角度而言, 接口继承是用来强制类输出特定的 API. 在类没有实现 API 中某个必须的方法时, 编译器同样会发现并报告错误.</p>
</li>
<li><p>缺点</p>
<p>  对于实现继承, 由于子类的实现代码散布在父类和子类间之间, 要理解其实现变得更加困难. 子类不能重写父类的非虚函数, 当然也就不能修改其实现. 基类也可能定义了一些数据成员, 因此还必须区分基类的实际布局.</p>
</li>
<li><p>结论</p>
<p>  所有继承必须是<code>public</code>的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式.</p>
<p>  不要过度使用实现继承. 组合常常更合适一些. 尽量做到只在 “是一个” (“is-a”, 其他 “has-a” 情况下请使用组合) 的情况下使用继承: 如果<code>Bar</code>的确 “是一种” <code>Foo</code>, <code>Bar</code>才能继承<code>Foo</code>.</p>
<p>  必要的话, 析构函数声明为<code>virtual</code>. 如果你的类有虚函数, 则析构函数也应该为虚函数.</p>
<p>  对于可能被子类访问的成员函数, 不要过度使用<code>protected</code>关键字. 注意, 数据成员都必须是<strong>私有的</strong>.</p>
<p>  对于重载的虚函数或虚析构函数, 使用<code>override</code>, 或 (较不常用的)<code>final</code>关键字显式地进行标记. 较早 (早于 C++11) 的代码可能会使用<code>virtual</code>关键字作为不得已的选项. 因此, 在声明重载时, 请使用 <code>override</code>, <code>final</code>或<code>virtual</code>的其中之一进行标记. 标记为<code>override</code>或<code>final</code>的析构函数如果不是对基类虚函数的重载的话, 编译会报错, 这有助于捕获常见的错误. 这些标记起到了文档的作用, 因为如果省略这些关键字, 代码阅读者不得不检查所有父类, 以判断该函数是否是虚函数.</p>
</li>
</ul>
<h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><ul>
<li><p>总述</p>
<p>  真正需要用到多重实现继承的情况少之又少. 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以<code>Interface</code>为后缀的纯接口类.</p>
</li>
<li><p>定义</p>
<p>  多重继承允许子类拥有多个基类. 要将作为<em>纯接口</em>的基类和具有<em>实现</em>的基类区别开来.</p>
</li>
<li><p>优点</p>
<p>  相比单继承, 多重实现继承可以复用更多的代码.</p>
</li>
<li><p>缺点</p>
<p>  真正需要用到多重 实现 继承的情况少之又少. 有时多重实现继承看上去是不错的解决方案, 但这时你通常也可以找到一个更明确, 更清晰的不同解决方案.</p>
</li>
<li><p>结论</p>
<p>  只有当所有父类除第一个外都是<em>纯接口类</em>时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以<code>Interface</code>为后缀.</p>
</li>
</ul>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul>
<li><p>总述</p>
<p>  接口是指满足特定条件的类, 这些类以<code>Interface</code>为后缀 (不强制).</p>
</li>
<li><p>定义</p>
<p>  当一个类满足以下要求时, 称之为纯接口:</p>
<ul>
<li><p>只有纯虚函数 (“<code>=0</code>”) 和静态函数 (除了下文提到的析构函数).</p>
</li>
<li><p>没有非静态数据成员.</p>
</li>
<li><p>没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为<code>protected</code>.</p>
</li>
<li><p>如果它是一个子类, 也只能从满足上述条件并以<code>Interface</code>为后缀的类继承.</p>
<p>接口类不能被直接实例化, 因为它声明了纯虚函数. 为确保接口类的所有实现可被正确销毁, 必须为之声明虚析构函数</p>
</li>
</ul>
</li>
<li><p>优点</p>
<p>  以<code>Interface</code>为后缀可以提醒其他人不要为该接口类增加函数实现或非静态数据成员. 这一点对于<code>多重继承</code>尤其重要.</p>
</li>
<li><p>缺点</p>
<p>  <code>Interface</code>后缀增加了类名长度, 为阅读和理解带来不便. 同时, 接口属性作为实现细节不应暴露给用户.</p>
</li>
<li><p>结论</p>
<p>  只有在满足上述条件时, 类才以<code>Interface</code>结尾, 但反过来, 满足上述需要的类未必一定以<code>Interface</code>结尾.</p>
</li>
</ul>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><ul>
<li><p>总述</p>
<p>  除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量.</p>
</li>
<li><p>定义</p>
<p>  C++ 允许用户通过使用<code>operator</code>关键字对内建运算符进行重载定义, 只要其中一个参数是用户定义的类型. <code>operator</code>关键字还允许用户使用<code>operator&quot;&quot;</code>定义新的字面运算符, 并且定义类型转换函数, 例如<code>operator bool()</code>.</p>
</li>
<li><p>优点</p>
<p>  重载运算符可以让代码更简洁易懂, 也使得用户定义的类型和内建类型拥有相似的行为. 重载运算符对于某些运算来说是符合符合语言习惯的名称 (例如<code>==</code>,<code>&lt;</code>,<code>=</code>,<code>&lt;&lt;</code>), 遵循这些语言约定可以让用户定义的类型更易读, 也能更好地和需要这些重载运算符的函数库进行交互操作.</p>
<p>  对于创建用户定义的类型的对象来说, 用户定义字面量是一种非常简洁的标记.</p>
</li>
<li><p>缺点</p>
<ul>
<li>要提供正确, 一致, 不出现异常行为的操作符运算需要花费不少精力, 而且如果达不到这些要求的话, 会导致令人迷惑的 Bug.</li>
<li>过度使用运算符会带来难以理解的代码, 尤其是在重载的操作符的语义与通常的约定不符合时.</li>
<li>函数重载有多少弊端, 运算符重载就至少有多少.</li>
<li>运算符重载会混淆视听, 让你误以为一些耗时的操作和操作内建类型一样轻巧.</li>
<li>对重载运算符的调用点的查找需要的可就不仅仅是像 grep 那样的程序了, 这时需要能够理解 C++ 语法的搜索工具.</li>
<li>重载某些运算符本身就是有害的. 例如, 重载一元运算符 &amp; 会导致同样的代码有完全不同的含义, 这取决于重载的声明对某段代码而言是否是可见的. 重载诸如<code>&amp;&amp;</code>,<code>||</code>和<code>,</code> 会导致运算顺序和内建运算的顺序不一致.</li>
</ul>
</li>
<li><p>结论</p>
<p>  只有在意义明显, 不会出现奇怪的行为并且与对应的内建运算符的行为一致时才定义重载运算符. 例如, | 要作为位或或逻辑或来使用, 而不是作为 shell 中的管道.</p>
<p>  只有对用户自己定义的类型重载运算符. 更准确地说, 将它们和它们所操作的类型定义在同一个头文件中, <code>.cc</code>中和命名空间中. 这样做无论类型在哪里都能够使用定义的运算符, 并且最大程度上避免了多重定义的风险. 如果可能的话, 请避免将运算符定义为模板, 因为此时它们必须对任何模板参数都能够作用. 如果你定义了一个运算符, 请将其相关且有意义的运算符都进行定义, 并且保证这些定义的语义是一致的. 例如, 如果你重载了<code>&lt;</code>, 那么请将所有的比较运算符都进行重载, 并且保证对于同一组参数,<code>&lt;</code>和<code>&gt;</code>不会同时返回<code>true</code>.</p>
<p>  不要为了避免重载操作符而走极端. 比如说, 应当定义<code>==</code>,<code>=</code>,和<code>&lt;&lt;</code>而不是<code>Equals()</code>,<code>CopyFrom()</code>和<code>PrintTo()</code>. 反过来说, 不要只是为了满足函数库需要而去定义运算符重载. 比如说, 如果你的类型没有自然顺序, 而你要将它们存入<code>std::set</code>中, 最好还是定义一个自定义的比较运算符而不是重载<code>&lt;</code>.</p>
<p>  不要重载<code>&amp;&amp;</code>,<code>||</code>,<code>,</code>或一元运算符<code>&amp;</code>. 不要重载<code>operator&quot;&quot;</code>, 也就是说, 不要引入用户定义字面量.</p>
</li>
</ul>
<h4 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h4><ul>
<li><p>总述</p>
<p>  将<em>所有</em>数据成员声明为<code>private</code>, 除非是<code>static const</code>类型成员 (遵循 常量命名规则). 处于技术上的原因, 在使用<code>Google Test</code>时我们允许测试固件类中的数据成员为<code>protected</code>.</p>
</li>
</ul>
<h4 id="声明顺序"><a href="#声明顺序" class="headerlink" title="声明顺序"></a>声明顺序</h4><ul>
<li><p>总述</p>
<p>  将相似的声明放在一起, 将<code>public</code>部分放在最前.</p>
</li>
<li><p>说明</p>
<p>  类定义一般应以<code>public:</code>开始, 后跟<code>protected:</code>, 最后是<code>private:</code>. 省略空部分.</p>
<p>  在各个部分中, 建议将类似的声明放在一起, 并且建议以如下的顺序: 类型 (包括<code>typedef</code>,<code>using</code>和嵌套的结构体与类), 常量, 工厂函数, 构造函数, 赋值运算符, 析构函数, 其它函数, 数据成员.</p>
<p>  不要将大段的函数定义内联在类定义中. 通常，只有那些普通的, 或性能关键且短小的函数可以内联在类定义中. 参见 内联函数 一节.</p>
</li>
</ul>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ol>
<li>不在构造函数中做太多逻辑相关的初始化</li>
<li>编译器提供的默认构造函数不会对变量进行初始化, 如果定义了其他构造函数, 编译器不再提供, 需要编码者自行提供默认构造函数</li>
<li>为避免隐式转换, 需将单参数构造函数声明为<code>explicit</code></li>
<li>为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为<code>private</code>且无需实现</li>
<li>仅在作为数据集合时使用<code>struct</code></li>
<li>组合 &gt; 实现继承 &gt; 接口继承 &gt; 私有继承, 子类重载的虚函数也要声明<code>virtual</code>关键字, 虽然编译器允许不这样做</li>
<li>避免使用多重继承, 使用时, 除一个基类含有实现外, 其他基类均为纯接口</li>
<li>接口类类名以<code>Interface</code>为后缀, 除提供带实现的虚析构函数, 静态成员函数外, 其他均为纯虚函数, 不定义非静态数据成员, 不提供构造函数, 提供的话, 声明为<code>protected</code></li>
<li>为降低复杂性, 尽量不重载操作符, 模板, 标准类中使用时提供文档说明</li>
<li>存取函数一般内联在头文件中</li>
<li>声明次序:<code>public</code> -&gt; <code>protected</code> -&gt; <code>private</code></li>
<li>函数体尽量短小, 紧凑, 功能单一</li>
</ol>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h4 id="参数顺序"><a href="#参数顺序" class="headerlink" title="参数顺序"></a>参数顺序</h4><ul>
<li><p>总述</p>
<p>  函数的参数顺序为: 输入参数在先, 后跟输出参数.</p>
</li>
<li><p>说明</p>
<p>  C/C++ 中的函数参数或者是函数的输入, 或者是函数的输出, 或兼而有之. 输入参数通常是值参或<code>const</code>引用, 输出参数或输入/输出参数则一般为非<code>const</code>指针. 在排列参数顺序时, 将所有的输入参数置于输出参数之前. 特别要注意, 在加入新参数时不要因为它们是新参数就置于参数列表最后, 而是仍然要按照前述的规则, 即将新的输入参数也置于输出参数之前.</p>
<p>  这并非一个硬性规定. 输入/输出参数 (通常是类或结构体) 让这个问题变得复杂. 并且, 有时候为了其他函数保持一致, 你可能不得不有所变通.</p>
</li>
</ul>
<h4 id="编写简短函数"><a href="#编写简短函数" class="headerlink" title="编写简短函数"></a>编写简短函数</h4><ul>
<li><p>总述</p>
<p>  我们倾向于编写简短, 凝练的函数.</p>
</li>
<li><p>说明</p>
<p>  我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过<code>40</code>行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.</p>
<p>  即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题, 甚至导致难以发现的 bug. 使函数尽量简短,以便于他人阅读和修改代码.</p>
<p>  在处理代码时, 你可能会发现复杂的长函数. 不要害怕修改现有代码: 如果证实这些代码使用/调试起来很困难, 或者你只需要使用其中的一小段代码, 考虑将其分割为更加简短并易于管理的若干函数.</p>
</li>
</ul>
<h4 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h4><ul>
<li><p>总述</p>
<p>  所有按引用传递的参数必须加上<code>const</code>.</p>
</li>
<li><p>定义</p>
<p>  在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如<code>int foo(int *pval)</code>. 在 C++ 中, 函数还可以声明为引用参数: <code>int foo(int &amp;val)</code>.</p>
</li>
<li><p>优点</p>
<p>  定义引用参数可以防止出现<code>(*pval)++</code>这样丑陋的代码. 引用参数对于拷贝构造函数这样的应用也是必需的. 同时也更明确地不接受空指针.</p>
</li>
<li><p>缺点</p>
<p>  容易引起误解, 因为引用在语法上是值变量却拥有指针的语义.</p>
</li>
<li><p>结论</p>
<p>  函数参数列表中, 所有引用参数都必须是<code>const</code>:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">const</span> string &amp;in, string *out)</span></span>;</span><br></pre></td></tr></table></figure>

<p>  事实上这在Google Code是一个硬性约定: 输入参数是值参或<code>const</code>引用, 输出参数为指针. 输入参数可以是<code>const</code>指针, 但决不能是非<code>const</code>的引用参数, 除非特殊要求, 比如 swap().</p>
<p>  有时候, 在输入形参中用<code>const T*</code>指针比<code>const T&amp;</code>更明智. 比如:</p>
<ul>
<li><p>可能会传递空指针.</p>
</li>
<li><p>函数要把指针或对地址的引用赋值给输入形参.</p>
<p>总而言之, 大多时候输入形参往往是<code>const T&amp;</code>. 若用<code>const T*</code>则说明输入另有处理. 所以若要使用<code>const T*</code>, 则应给出相应的理由, 否则会使得读者感到迷惑.</p>
</li>
</ul>
</li>
</ul>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><ul>
<li><p>总述</p>
<p>  若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.</p>
</li>
<li><p>定义</p>
<p>  你可以编写一个参数类型为<code>const string&amp;</code>的函数, 然后用另一个参数类型为<code>const char*</code>的函数对其进行重载:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Analyze</span><span class="params">(<span class="type">const</span> string &amp;text)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Analyze</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *text, <span class="type">size_t</span> textlen)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点</p>
<p>  通过重载参数不同的同名函数, 可以令代码更加直观. 模板化代码需要重载, 这同时也能为使用者带来便利.</p>
</li>
<li><p>缺点</p>
<p>  如果函数单靠不同的参数类型而重载, 读者就得十分熟悉 C++ 五花八门的匹配规则, 以了解匹配过程具体到底如何. 另外, 如果派生类只重载了某个函数的部分变体, 继承语义就容易令人困惑.</p>
</li>
<li><p>结论</p>
<p>  如果打算重载一个函数, 可以试试改在函数名里加上参数信息. 例如, 用<code>AppendString()</code>和<code>AppendInt()</code>等, 而不是一口气重载多个<code>Append()</code>. 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用<code>std::vector</code>以便使用者可以用 列表初始化 指定参数.</p>
</li>
</ul>
<h4 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h4><ul>
<li><p>总述</p>
<p>  只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致. 缺省参数与 函数重载 遵循同样的规则. 一般情况下建议使用函数重载, 尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下.</p>
</li>
<li><p>优点</p>
<p>  有些函数一般情况下使用默认参数, 但有时需要又使用非默认的参数. 缺省参数为这样的情形提供了便利, 使程序员不需要为了极少的例外情况编写大量的函数. 和函数重载相比, 缺省参数的语法更简洁明了, 减少了大量的样板代码, 也更好地区别了 “必要参数” 和 “可选参数”.</p>
</li>
<li><p>缺点</p>
<p>  缺省参数实际上是函数重载语义的另一种实现方式, 因此所有 不应当使用函数重载的理由 也都适用于缺省参数.</p>
<p>  虚函数调用的缺省参数取决于目标对象的静态类型, 此时无法保证给定函数的所有重载声明的都是同样的缺省参数.</p>
<p>  缺省参数是在每个调用点都要进行重新求值的, 这会造成生成的代码迅速膨胀. 作为读者, 一般来说也更希望缺省的参数在声明时就已经被固定了, 而不是在每次调用时都可能会有不同的取值.</p>
<p>  缺省参数会干扰函数指针, 导致函数签名与调用点的签名不一致. 而函数重载不会导致这样的问题.</p>
</li>
<li><p>结论</p>
<p>  对于虚函数, 不允许使用缺省参数, 因为在虚函数中缺省参数不一定能正常工作. 如果在每个调用点缺省参数的值都有可能不同, 在这种情况下缺省函数也不允许使用. (例如, 不要写像<code>void f(int n = counter++);</code> 这样的代码.)</p>
<p>  在其他情况下, 如果缺省参数对可读性的提升远远超过了以上提及的缺点的话, 可以使用缺省参数. 如果仍有疑惑, 就使用函数重载.</p>
</li>
</ul>
<h2 id="来自Google的奇技"><a href="#来自Google的奇技" class="headerlink" title="来自Google的奇技"></a>来自Google的奇技</h2><p>Google 用了很多自己实现的技巧 / 工具使 C++ 代码更加健壮, 我们使用 C++ 的方式可能和你在其它地方见到的有所不同.</p>
<h4 id="所有权与智能指针"><a href="#所有权与智能指针" class="headerlink" title="所有权与智能指针"></a>所有权与智能指针</h4><ul>
<li><p>总述</p>
<p>  动态分配出的对象最好有单一且固定的所有主, 并通过智能指针传递所有权.</p>
</li>
<li><p>定义</p>
<p>  所有权是一种登记／管理动态内存和其它资源的技术. 动态分配对象的所有主是一个对象或函数, 后者负责确保当前者无用时就自动销毁前者. 所有权有时可以共享, 此时就由最后一个所有主来负责销毁它. 甚至也可以不用共享, 在代码中直接把所有权传递给其它对象.</p>
<p>  智能指针是一个通过重载<code>*</code>和<code>-&gt;</code>运算符以表现得如指针一样的类. 智能指针类型被用来自动化所有权的登记工作, 来确保执行销毁义务到位.<code>std::unique_ptr</code>是 C++11 新推出的一种智能指针类型, 用来表示动态分配出的对象的独一无二的所有权; 当<code>std::unique_ptr</code>离开作用域时, 对象就会被销毁.<code>std::unique_ptr</code>不能被复制, 但可以把它移动（move）给新所有主.<code>std::shared_ptr</code>同样表示动态分配对象的所有权, 但可以被共享, 也可以被复制; 对象的所有权由所有复制者共同拥有, 最后一个复制者被销毁时, 对象也会随着被销毁.</p>
</li>
<li><p>优点</p>
<ul>
<li>如果没有清晰、逻辑条理的所有权安排, 不可能管理好动态分配的内存.</li>
<li>传递对象的所有权, 开销比复制来得小, 如果可以复制的话.</li>
<li>传递所有权也比”借用”指针或引用来得简单, 毕竟它大大省去了两个用户一起协调对象生命周期的工作.</li>
<li>如果所有权逻辑条理, 有文档且不紊乱的话, 可读性会有很大提升.</li>
<li>可以不用手动完成所有权的登记工作, 大大简化了代码, 也免去了一大波错误之恼.</li>
<li>对于 const 对象来说, 智能指针简单易用, 也比深度复制高效.</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>不得不用指针（不管是智能的还是原生的）来表示和传递所有权. 指针语义可要比值语义复杂得许多了, 特别是在 API 里：这时不光要操心所有权, 还要顾及别名, 生命周期, 可变性以及其它大大小小的问题.</li>
<li>其实值语义的开销经常被高估, 所以所有权传递带来的性能提升不一定能弥补可读性和复杂度的损失.</li>
<li>如果 API 依赖所有权的传递, 就会害得客户端不得不用单一的内存管理模型.</li>
<li>如果使用智能指针, 那么资源释放发生的位置就会变得不那么明显.</li>
<li><code>std::unique_ptr</code>的所有权传递原理是 C++11 的 move 语法, 后者毕竟是刚刚推出的, 容易迷惑程序员.</li>
<li>如果原本的所有权设计已经够完善了, 那么若要引入所有权共享机制, 可能不得不重构整个系统.</li>
<li>所有权共享机制的登记工作在运行时进行, 开销可能相当大.</li>
<li>某些极端情况下 (例如循环引用), 所有权被共享的对象永远不会被销毁.</li>
<li>智能指针并不能够完全代替原生指针.</li>
</ul>
</li>
<li><p>结论</p>
<p>  如果必须使用动态分配, 那么更倾向于将所有权保持在分配者手中. 如果其他地方要使用这个对象, 最好传递它的拷贝, 或者传递一个不用改变所有权的指针或引用. 倾向于使用<code>std::unique_ptr</code>来明确所有权传递, 例如：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Foo&gt; <span class="title">FooFactory</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FooConsumer</span><span class="params">(std::unique_ptr&lt;Foo&gt; ptr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>  如果没有很好的理由, 则不要使用共享所有权. 这里的理由可以是为了避免开销昂贵的拷贝操作, 但是只有当性能提升非常明显, 并且操作的对象是不可变的（比如说<code>std::shared_ptr&lt;const Foo&gt;</code>）时候, 才能这么做. 如果确实要使用共享所有权, 建议于使用<code>std::shared_ptr</code>.</p>
<p>  不要使用<code>std::auto_ptr</code>, 使用<code>std::unique_ptr</code>代替它.</p>
</li>
</ul>
<h4 id="Cpplint"><a href="#Cpplint" class="headerlink" title="Cpplint"></a>Cpplint</h4><ul>
<li><p>总述</p>
<p>  使用<code>cpplint.py</code>检查风格错误.</p>
</li>
<li><p>说明</p>
<p>  <code>cpplint.py</code>是一个用来分析源文件, 能检查出多种风格错误的工具. 它不并完美, 甚至还会漏报和误报, 但它仍然是一个非常有用的工具. 在行尾加<code>// NOLINT</code>, 或在上一行加<code>// NOLINTNEXTLINE</code>, 可以忽略报错.</p>
<p>  某些项目会指导你如何使用他们的项目工具运行<code>cpplint.py</code>. 如果你参与的项目没有提供, 你可以单独下载<code>cpplint.py</code>.</p>
</li>
</ul>
<h2 id="其他C-特性"><a href="#其他C-特性" class="headerlink" title="其他C++特性"></a>其他C++特性</h2><h4 id="引用参数-1"><a href="#引用参数-1" class="headerlink" title="引用参数"></a>引用参数</h4><blockquote>
<p>Tip: 所有按引用传递的参数<strong>必须</strong>加上<code>const</code>.</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如<code>int foo(int *pval)</code>. 在 C++ 中, 函数还可以声明引用参数:<code>int foo(int &amp;val)</code>.</p>
</li>
<li><p>优点</p>
<p>  定义引用参数防止出现<code>(*pval)++</code>这样丑陋的代码. 像拷贝构造函数这样的应用也是必需的. 而且更明确, 不接受<code>NULL</code>指针.</p>
</li>
<li><p>缺点</p>
<p>  容易引起误解, 因为引用在语法上是值变量却拥有指针的语义.</p>
</li>
<li><p>结论</p>
<p>  函数参数列表中, 所有引用参数都必须是<code>const</code>:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">const</span> string &amp;in, string *out)</span></span>;</span><br></pre></td></tr></table></figure>

<p>  事实上这在 Google Code 是一个硬性约定: 输入参数是值参或<code>const</code>引用, 输出参数为指针. 输入参数可以是<code>const</code>指针, 但决不能是非<code>const</code>的引用参数，除非用于交换，比如<code>swap()</code>.</p>
<p>  有时候，在输入形参中用<code>const T*</code>指针比<code>const T&amp;</code>更明智。比如：</p>
<pre><code>  - 您会传 null 指针。
  - 函数要把指针或对地址的引用赋值给输入形参。
</code></pre>
<p>  总之大多时候输入形参往往是<code>const T&amp;</code>. 若用<code>const T*</code>说明输入另有处理。所以若您要用 <code>const T*</code>, 则应有理有据，否则会害得读者误解。</p>
</li>
</ul>
<h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><blockquote>
<p>Tip: 只在定义移动构造函数与移动赋值操作时使用右值引用. 不要使用<code>std::forward</code>.</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  右值引用是一种只能绑定到临时对象的引用的一种, 其语法与传统的引用语法相似. 例如,<code>void f(string&amp;&amp; s)</code>; 声明了一个其参数是一个字符串的右值引用的函数.</p>
</li>
<li><p>优点</p>
<p>  用于定义移动构造函数 (使用类的右值引用进行构造的函数) 使得移动一个值而非拷贝之成为可能. 例如, 如果<code>v1</code>是一个<code>vector&lt;string&gt;</code>, 则<code>auto v2(std::move(v1))</code>将很可能不再进行大量的数据复制而只是简单地进行指针操作, 在某些情况下这将带来大幅度的性能提升.</p>
</li>
<li><p>缺点</p>
<p>  右值引用是一个相对比较新的特性 (由 C++11 引入), 它尚未被广泛理解. 类似引用崩溃, 移动构造函数的自动推导这样的规则都是很复杂的.</p>
</li>
<li><p>结论</p>
<p>  只在定义移动构造函数与移动赋值操作时使用右值引用, 不要使用<code>std::forward</code>功能函数. 你可能会使用<code>std::move</code>来表示将值从一个对象移动而不是复制到另一个对象.</p>
</li>
</ul>
<h4 id="函数重载-1"><a href="#函数重载-1" class="headerlink" title="函数重载"></a>函数重载</h4><blockquote>
<p>Tip: 若要用好函数重载，最好能让读者一看调用点（call site）就胸有成竹，不用花心思猜测调用的重载函数到底是哪一种。该规则适用于构造函数。</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  你可以编写一个参数类型为<code>const string&amp;</code>的函数, 然后用另一个参数类型为<code>const char*</code>的函数重载它:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Analyze</span><span class="params">(<span class="type">const</span> string &amp;text)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Analyze</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *text, <span class="type">size_t</span> textlen)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点</p>
<p>  通过重载参数不同的同名函数, 令代码更加直观. 模板化代码需要重载, 同时为使用者带来便利.</p>
</li>
<li><p>缺点</p>
<p>  如果函数单单靠不同的参数类型而重载，读者就得十分熟悉 C++ 五花八门的匹配规则，以了解匹配过程具体到底如何。另外，当派生类只重载了某个函数的部分变体，继承语义容易令人困惑。</p>
</li>
<li><p>结论</p>
<p>  如果您打算重载一个函数, 可以试试改在函数名里加上参数信息。例如，用<code>AppendString()</code>和<code>AppendInt()</code>等， 而不是一口气重载多个<code>Append()</code>.</p>
</li>
</ul>
<h4 id="缺省参数-1"><a href="#缺省参数-1" class="headerlink" title="缺省参数"></a>缺省参数</h4><blockquote>
<p>Tip: 我们不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载。</p>
</blockquote>
<ul>
<li><p>优点</p>
<p>  当您有依赖缺省参数的函数时，您也许偶尔会修改修改这些缺省参数。通过缺省参数，不用再为个别情况而特意定义一大堆函数了。与函数重载相比，缺省参数语法更为清晰，代码少，也很好地区分了「必选参数」和「可选参数」。</p>
</li>
<li><p>缺点</p>
<p>  缺省参数会干扰函数指针，害得后者的函数签名（function signature）往往对不上所实际要调用的函数签名。即在一个现有函数添加缺省参数，就会改变它的类型，那么调用其地址的代码可能会出错，不过函数重载就没这问题了。此外，缺省参数会造成臃肿的代码，毕竟它们在每一个调用点（call site）都有重复。函数重载正好相反，毕竟它们所谓的「缺省参数」只会出现在函数定义里。</p>
</li>
<li><p>结论</p>
<p>  由于缺点并不是很严重，有些人依旧偏爱缺省参数胜于函数重载。所以除了以下情况，我们要求必须显式提供所有参数。</p>
<ol>
<li>位于<code>.cc</code>文件里的静态函数或匿名空间函数，毕竟都只能在局部文件里调用该函数了</li>
<li>可以在构造函数里用缺省参数，毕竟不可能取得它们的地址</li>
<li>可以用来模拟变长数组</li>
</ol>
</li>
</ul>
<h4 id="变长数组和alloca"><a href="#变长数组和alloca" class="headerlink" title="变长数组和alloca()"></a>变长数组和alloca()</h4><blockquote>
<p>Tip: 我们不允许使用变长数组和<code>alloca()</code>.</p>
</blockquote>
<ul>
<li><p>优点</p>
<p>  变长数组具有浑然天成的语法. 变长数组和<code>alloca()</code>也都很高效.</p>
</li>
<li><p>缺点</p>
<p>  变长数组和<code>alloca()</code>不是标准 C++ 的组成部分. 更重要的是, 它们根据数据大小动态分配堆栈内存, 会引起难以发现的内存越界 bugs: “在我的机器上运行的好好的, 发布后却莫名其妙的挂掉了”.</p>
</li>
<li><p>结论</p>
<p>  改用更安全的分配器（allocator），就像<code>std::vector</code>或<code>std::unique_ptr&lt;T[]&gt;</code>.</p>
</li>
</ul>
<h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><blockquote>
<p>Tip: 我们允许合理的使用友元类及友元函数.</p>
</blockquote>
<p>通常友元应该定义在同一文件内, 避免代码读者跑到其它文件查找使用该私有成员的类. 经常用到友元的一个地方是将<code>FooBuilder</code>声明为<code>Foo</code>的友元, 以便<code>FooBuilder</code>正确构造 Foo 的内部状态, 而无需将该状态暴露出来. 某些情况下, 将一个单元测试类声明成待测类的友元会很方便.</p>
<p>友元扩大了 (但没有打破) 类的封装边界. 某些情况下, 相对于将类成员声明为<code>public</code>, 使用友元是更好的选择, 尤其是如果你只允许另一个类访问该类的私有成员时. 当然, 大多数类都只应该通过其提供的公有成员进行互操作.</p>
<h4 id="运行时类型识别"><a href="#运行时类型识别" class="headerlink" title="运行时类型识别"></a>运行时类型识别</h4><blockquote>
<p>Tip: 禁止使用 RTTI(Run-Time Type Identification).</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  RTTI 允许程序员在运行时识别 C++ 类对象的类型. 它通过使用<code>typeid</code>或者<code>dynamic_cast</code>完成.</p>
</li>
<li><p>优点</p>
<p>  RTTI 的标准替代 (下面将描述) 需要对有问题的类层级进行修改或重构. 有时这样的修改并不是我们所想要的, 甚至是不可取的, 尤其是在一个已经广泛使用的或者成熟的代码中.</p>
<p>  RTTI 在某些单元测试中非常有用. 比如进行工厂类测试时, 用来验证一个新建对象是否为期望的动态类型. RTTI 对于管理对象和派生对象的关系也很有用.</p>
<p>  在考虑多个抽象对象时 RTTI 也很好用. 例如:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Base::Equal</span><span class="params">(Base* other)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Derived::Equal</span><span class="params">(Base* other)</span> </span>&#123;</span><br><span class="line">Derived* that = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(other);</span><br><span class="line"><span class="keyword">if</span> (that == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>缺点</p>
<p>  在运行时判断类型通常意味着设计问题. 如果你需要在运行期间确定一个对象的类型, 这通常说明你需要考虑重新设计你的类.</p>
<p>  随意地使用 RTTI 会使你的代码难以维护. 它使得基于类型的判断树或者 switch 语句散布在代码各处. 如果以后要进行修改, 你就必须检查它们.</p>
</li>
<li><p>结论</p>
<p>  基于类型的判断树是一个很强的暗示, 它说明你的代码已经偏离正轨了. 不要像下面这样:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(*data) == <span class="built_in">typeid</span>(D1)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">typeid</span>(*data) == <span class="built_in">typeid</span>(D2)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">typeid</span>(*data) == <span class="built_in">typeid</span>(D3)) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>  一旦在类层级中加入新的子类, 像这样的代码往往会崩溃. 而且, 一旦某个子类的属性改变了, 你很难找到并修改所有受影响的代码块.</p>
<p>  不要去手工实现一个类似 RTTI 的方案. 反对 RTTI 的理由同样适用于这些方案, 比如带类型标签的类继承体系. 而且, 这些方案会掩盖你的真实意图.</p>
</li>
</ul>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><blockquote>
<p>Tip: 使用 C++ 的类型转换, 如<code>static_cast&lt;&gt;()</code>. 不要使用<code>int y = (int)x</code>或<code>int y = int(x)</code>等转换方式</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  C++ 采用了有别于 C 的类型转换机制, 对转换操作进行归类.</p>
</li>
<li><p>优点</p>
<p>  C 语言的类型转换问题在于模棱两可的操作; 有时是在做强制转换 (如 <code>(int)3.5</code>), 有时是在做类型转换 (如 <code>(int)&quot;hello&quot;</code>). 另外, C++ 的类型转换在查找时更醒目.</p>
</li>
<li><p>结论</p>
<p>  不要使用 C 风格类型转换. 而应该使用 C++ 风格.</p>
<ul>
<li>用<code>static_cast</code>替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时.</li>
<li>用<code>const_cast</code>去掉<code>const</code>限定符.</li>
<li>用<code>reinterpret_cast</code>指针类型和整型或其它指针之间进行不安全的相互转换. 仅在你对所做一切了然于心时使用.</li>
</ul>
</li>
</ul>
<h4 id="流"><a href="#流" class="headerlink" title="流"></a>流</h4><blockquote>
<p>Tip: 只在记录日志时使用流.</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  流用来替代<code>printf()</code>和<code>scanf()</code>.</p>
</li>
<li><p>优点</p>
<p>  有了流, 在打印时不需要关心对象的类型. 不用担心格式化字符串与参数列表不匹配 (虽然在 gcc 中使用<code>printf</code>也不存在这个问题). 流的构造和析构函数会自动打开和关闭对应的文件.</p>
</li>
<li><p>缺点</p>
<p>  流使得<code>pread()</code>等功能函数很难执行. 如果不使用<code>printf</code>风格的格式化字符串, 某些格式化操作 (尤其是常用的格式字符串 %.*s) 用流处理性能是很低的. 流不支持字符串操作符重新排序 (%1s), 而这一点对于软件国际化很有用.</p>
</li>
<li><p>结论</p>
<p>  不要使用流, 除非是日志接口需要. 使用<code>printf</code>之类的代替.</p>
<p>  使用流还有很多利弊, 但代码一致性胜过一切. 不要在代码中使用流.</p>
</li>
</ul>
<h4 id="前置自增和自减减"><a href="#前置自增和自减减" class="headerlink" title="前置自增和自减减"></a>前置自增和自减减</h4><blockquote>
<p>Tip: 对于迭代器和其他模板对象使用前缀形式<code>(++i)</code>的自增, 自减运算符.</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  对于变量在自增 (<code>++i</code>或<code>i++</code>) 或自减 (<code>--i</code>或<code>i--</code>) 后表达式的值又没有没用到的情况下, 需要确定到底是使用前置还是后置的自增 (自减).</p>
</li>
<li><p>优点</p>
<p>  不考虑返回值的话, 前置自增 (<code>++i</code>) 通常要比后置自增 (<code>i++</code>) 效率更高. 因为后置自增 (或自减) 需要对表达式的值 i 进行一次拷贝. 如果 i 是迭代器或其他非数值类型, 拷贝的代价是比较大的. 既然两种自增方式实现的功能一样, 为什么不总是使用前置自增呢?</p>
</li>
<li><p>缺点</p>
<p>  在 C 开发中, 当表达式的值未被使用时, 传统的做法是使用后置自增, 特别是在<code>for</code>循环中. 有些人觉得后置自增更加易懂, 因为这很像自然语言, 主语 (<code>i</code>) 在谓语动词 (<code>++</code>) 前.</p>
</li>
<li><p>结论</p>
<p>  对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减).</p>
</li>
</ul>
<h4 id="const用法"><a href="#const用法" class="headerlink" title="const用法"></a><code>const</code>用法</h4><blockquote>
<p>Tip: 我们强烈建议你在任何可能的情况下都要使用<code>const</code>. 此外有时改用 C++11 推出的 constexpr 更好。</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  在声明的变量或参数前加上关键字<code>const</code>用于指明变量值不可被篡改 (如 <code>const int foo</code>). 为类中的函数加上<code>const</code>限定符表明该函数不会修改类成员变量的状态 (如<code>class Foo &#123; int Bar(char c) const; &#125;;</code>).</p>
</li>
<li><p>优点</p>
<p>  大家更容易理解如何使用变量. 编译器可以更好地进行类型检测, 相应地, 也能生成更好的代码. 人们对编写正确的代码更加自信, 因为他们知道所调用的函数被限定了能或不能修改变量值. 即使是在无锁的多线程编程中, 人们也知道什么样的函数是安全的.</p>
</li>
<li><p>缺点</p>
<p>  <code>const</code>是入侵性的: 如果你向一个函数传入<code>const</code>变量, 函数原型声明中也必须对应<code>const</code>参数 (否则变量需要<code>const_cast</code>类型转换), 在调用库函数时显得尤其麻烦.</p>
</li>
<li><p>结论</p>
<p>  <code>const</code>变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误. 因此, 我们强烈建议在任何可能的情况下使用<code>const</code>:</p>
<ul>
<li>如果函数不会修改传你入的引用或指针类型参数, 该参数应声明为 <code>const</code>.</li>
<li>尽可能将函数声明为<code>const</code>. 访问函数应该总是<code>const</code>. 其他不会修改任何数据成员, 未调用非<code>const</code>函数, 不会返回数据成员非 <code>const</code>指针或引用的函数也应该声明成<code>const</code>.</li>
<li>如果数据成员在对象构造之后不再发生变化, 可将其定义为<code>const</code>.</li>
</ul>
</li>
</ul>
<h4 id="constexpr用法"><a href="#constexpr用法" class="headerlink" title="constexpr用法"></a><code>constexpr</code>用法</h4><blockquote>
<p>Tip: 在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  变量可以被声明成<code>constexpr</code>以表示它是真正意义上的常量，即在编译时和运行时都不变。函数或构造函数也可以被声明成<code>constexpr</code>, 以用来定义 <code>constexpr</code>变量。</p>
</li>
<li><p>优点</p>
<p>  如今 constexpr 就可以定义浮点式的真・常量，不用再依赖字面值了；也可以定义用户自定义类型上的常量；甚至也可以定义函数调用所返回的常量。</p>
</li>
<li><p>缺点</p>
<p>  若过早把变量优化成 constexpr 变量，将来又要把它改为常规变量时，挺麻烦的；当前对constexpr函数和构造函数中允许的限制可能会导致这些定义中解决的方法模糊。</p>
</li>
<li><p>结论</p>
<p>  靠 constexpr 特性，方才实现了 C++ 在接口上打造真正常量机制的可能。好好用 constexpr 来定义真・常量以及支持常量的函数。避免复杂的函数定义，以使其能够与constexpr一起使用。 千万别痴心妄想地想靠 constexpr 来强制代码「内联」。</p>
</li>
</ul>
<h4 id="预处理宏"><a href="#预处理宏" class="headerlink" title="预处理宏"></a>预处理宏</h4><blockquote>
<p>Tip: 使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之.</p>
</blockquote>
<p>宏意味着你和编译器看到的代码是不同的. 这可能会导致异常行为, 尤其因为宏具有全局作用域.</p>
<p>值得庆幸的是, C++ 中, 宏不像在 C 中那么必不可少. 以往用宏展开性能关键的代码, 现在可以用内联函数替代. 用宏表示常量可被<code>const</code>变量代替. 用宏 “缩写” 长变量名可被引用代替. 用宏进行条件编译… 这个, 千万别这么做, 会令测试更加痛苦 (<code>#define</code>防止头文件重包含当然是个特例).</p>
<p>宏可以做一些其他技术无法实现的事情, 在一些代码库 (尤其是底层库中) 可以看到宏的某些特性 (如用<code>#</code>字符串化, 用<code>##</code>连接等等). 但在使用前, 仔细考虑一下能不能不使用宏达到同样的目的.</p>
<p>下面给出的用法模式可以避免使用宏带来的问题; 如果你要宏, 尽可能遵守:</p>
<ul>
<li>不要在<code>.h</code>文件中定义宏.</li>
<li>在马上要使用时才进行<code>#define</code>, 使用后要立即 <code>#undef</code>.</li>
<li>不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；</li>
<li>不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为.</li>
<li>不要用<code>##</code>处理函数，类和变量的名字。</li>
</ul>
<h4 id="nullptr和NULL"><a href="#nullptr和NULL" class="headerlink" title="nullptr和NULL"></a><code>nullptr</code>和<code>NULL</code></h4><blockquote>
<p>Tip: 对于指针 (地址值), 到底是用<code>0</code>,<code>NULL</code>还是<code>nullptr</code>. C++11 项目用<code>nullptr</code>; C++03 项目则用<code>NULL</code>, 毕竟它看起来像指针。实际上，一些 C++ 编译器对<code>NULL</code>的定义比较特殊，可以输出有用的警告，特别是 <code>sizeof(NULL)</code>就和<code>sizeof(0)</code>不一样。</p>
</blockquote>
<h4 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a><code>sizeof</code></h4><blockquote>
<p>Tip: 尽可能用<code>sizeof(varname)</code>代替<code>sizeof(type)</code>.<br>使用<code>sizeof(varname)</code>是因为当代码中变量类型改变时会自动更新. 您或许会用<code>sizeof(type)</code>处理不涉及任何变量的代码，比如处理来自外部或内部的数据格式，这时用变量就不合适了。</p>
</blockquote>
<h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a><code>auto</code></h4><blockquote>
<p>Tip: 用<code>auto</code>绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。</p>
</blockquote>
<ul>
<li>定义</li>
</ul>
<p>C++11 中，若变量被声明成<code>auto</code>, 那它的类型就会被自动匹配成初始化表达式的类型。您可以用<code>auto</code>来复制初始化或绑定引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> s1 = v[<span class="number">0</span>];  <span class="comment">// 创建一份 v[0] 的拷贝。</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; s2 = v[<span class="number">0</span>];  <span class="comment">// s2 是 v[0] 的一个引用。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>优点</li>
</ul>
<p>C++ 类型名有时又长又臭，特别是涉及模板或命名空间的时候。就像：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sparse_hash_map&lt;string, <span class="type">int</span>&gt;::iterator iter = m.<span class="built_in">find</span>(val);</span><br></pre></td></tr></table></figure>

<p>返回类型好难读，代码目的也不够一目了然。重构其：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> iter = m.<span class="built_in">find</span>(val);</span><br></pre></td></tr></table></figure>

<p>好多了。</p>
<p>没有<code>auto</code>的话，我们不得不在同一个表达式里写同一个类型名两次，无谓的重复，就像：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">diagnostics::ErrorStatus* status = <span class="keyword">new</span> diagnostics::<span class="built_in">ErrorStatus</span>(<span class="string">&quot;xyz&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>有了 auto, 可以更方便地用中间变量，显式编写它们的类型轻松点。</p>
<ul>
<li>缺点</li>
</ul>
<p>类型够明显时，特别是初始化变量时，代码才会够一目了然。但以下就不一样了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = x.<span class="built_in">Lookup</span>(key);</span><br></pre></td></tr></table></figure>

<p>看不出其类型是啥，x 的类型声明恐怕远在几百行之外了。</p>
<p>程序员必须会区分<code>auto</code>和<code>const auto&amp;</code>的不同之处，否则会复制错东西。</p>
<p>auto 和 C++11 列表初始化的合体令人摸不着头脑：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x</span><span class="params">(<span class="number">3</span>)</span></span>;  <span class="comment">// 圆括号。</span></span><br><span class="line"><span class="keyword">auto</span> y&#123;<span class="number">3</span>&#125;;  <span class="comment">// 大括号。</span></span><br></pre></td></tr></table></figure>

<p>它们不是同一回事——<code>x</code>是<code>int</code>,<code>y</code>则是<code>std::initializer_list&lt;int&gt;</code>. 其它一般不可见的代理类型也有大同小异的陷阱。</p>
<p>如果在接口里用<code>auto</code>, 比如声明头文件里的一个常量，那么只要仅仅因为程序员一时修改其值而导致类型变化的话——API 要翻天覆地了。</p>
<ul>
<li>结论</li>
</ul>
<p><code>auto</code>只能用在局部变量里用。别用在文件作用域变量，命名空间作用域变量和类数据成员里。永远别列表初始化<code>auto</code>变量。</p>
<p><code>auto</code>还可以和 C++11 特性「尾置返回类型（trailing return type）」一起用，不过后者只能用在<code>lambda</code>表达式里。</p>
<h4 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h4><p>早在 C++03 里，聚合类型（aggregate types）就已经可以被列表初始化了，比如数组和不自带构造函数的结构体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123; <span class="type">int</span> x; <span class="type">int</span> y; &#125;;</span><br><span class="line">Point p = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>C++11 中，该特性得到进一步的推广，任何对象类型都可以被列表初始化。示范如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vector 接收了一个初始化列表。</span></span><br><span class="line">vector&lt;string&gt; v&#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不考虑细节上的微妙差别，大致上相同。</span></span><br><span class="line"><span class="comment">// 您可以任选其一。</span></span><br><span class="line">vector&lt;string&gt; v = &#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以配合 new 一起用。</span></span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> vector&lt;string&gt;&#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表也可以用在返回类型上的隐式转换。</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">test_function</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表可迭代。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数调用里用列表初始化。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunction2</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v)</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">TestFunction2</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>用户自定义类型也可以定义接收<code>std::initializer_list&lt;T&gt;</code>的构造函数和赋值运算符，以自动列表初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyType</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// std::initializer_list 专门接收 init 列表。</span></span><br><span class="line">  <span class="comment">// 得以值传递。</span></span><br><span class="line">  <span class="built_in">MyType</span>(std::initializer_list&lt;<span class="type">int</span>&gt; init_list) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : init_list) <span class="built_in">append</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  MyType&amp; <span class="keyword">operator</span>=(std::initializer_list&lt;<span class="type">int</span>&gt; init_list) &#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : init_list) <span class="built_in">append</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MyType m&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>最后，列表初始化也适用于常规数据类型的构造，哪怕没有接收<code>std::initializer_list&lt;T&gt;</code>的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> d&#123;<span class="number">1.23</span>&#125;;</span><br><span class="line"><span class="comment">// MyOtherType 没有 std::initializer_list 构造函数，</span></span><br><span class="line"> <span class="comment">// 直接上接收常规类型的构造函数。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyOtherType</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyOtherType</span><span class="params">(string)</span></span>;</span><br><span class="line">  <span class="built_in">MyOtherType</span>(<span class="type">int</span>, string);</span><br><span class="line">&#125;;</span><br><span class="line">MyOtherType m = &#123;<span class="number">1</span>, <span class="string">&quot;b&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 不过如果构造函数是显式的（explict），您就不能用 `= &#123;&#125;` 了。</span></span><br><span class="line">MyOtherType m&#123;<span class="string">&quot;b&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><blockquote>
<p>Tip: 适当使用<code>lambda</code>表达式。别用默认<code>lambda</code>捕获，所有捕获都要显式写出来。</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  Lambda 表达式是创建匿名函数对象的一种简易途径，常用于把函数当参数传，例如：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Weight</span>(x) &lt; <span class="built_in">Weight</span>(y);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>  C++11 首次提出 Lambdas, 还提供了一系列处理函数对象的工具，比如多态包装器（polymorphic wrapper）<code>std::function</code>.</p>
</li>
<li><p>优点</p>
<ul>
<li>传函数对象给 STL 算法，Lambdas 最简易，可读性也好。</li>
<li>Lambdas,<code>std::functions</code>和<code>std::bind</code>可以搭配成通用回调机制（general purpose callback mechanism）；写接收有界函数为参数的函数也很容易了。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>Lambdas 的变量捕获略旁门左道，可能会造成悬空指针。</li>
<li>Lambdas 可能会失控；层层嵌套的匿名函数难以阅读。</li>
</ul>
</li>
<li><p>结论</p>
<ul>
<li>按 format 小用 lambda 表达式怡情。</li>
<li>**禁用默认捕获([=] [&amp;])**，捕获都要显式写出来。打比方，比起<code>[=](int x) &#123;return x + n;&#125;</code>, 您该写成<code>[n](int x) &#123;return x + n;&#125;</code>才对，这样读者也好一眼看出<code>n</code>是被捕获的值。</li>
<li>匿名函数始终要简短，如果函数体超过了五行，那么还不如起名，或改用函数。</li>
<li>如果可读性更好，就显式写出 lambd 的尾置返回类型，就像auto.</li>
</ul>
</li>
</ul>
<h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><p>最重要的一致性规则是命名管理. 命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义: 类型, 变量, 函数, 常量, 宏, 等等, 甚至. 我们大脑中的模式匹配引擎非常依赖这些命名规则.</p>
<p>命名规则具有一定随意性, 但相比按个人喜好命名, 一致性更重要, 所以无论你认为它们是否重要, 规则总归是规则.</p>
<h4 id="通用命名规则"><a href="#通用命名规则" class="headerlink" title="通用命名规则"></a>通用命名规则</h4><ul>
<li><p>总述</p>
<p>  函数命名, 变量命名, 文件命名要有描述性; 少用缩写</p>
</li>
<li><p>说明</p>
<p>  尽可能使用描述性的命名, 别心疼空间, 毕竟相比之下让代码易于新读者理解更重要. 不要用只有项目开发者能理解的缩写, 也不要通过砍掉几个字母来缩写单词.</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> price_count_reader;    <span class="comment">// 无缩写</span></span><br><span class="line"><span class="type">int</span> num_errors;            <span class="comment">// &quot;num&quot; 是一个常见的写法</span></span><br><span class="line"><span class="type">int</span> num_dns_connections;   <span class="comment">// 人人都知道 &quot;DNS&quot; 是什么</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;                     <span class="comment">// 毫无意义.</span></span><br><span class="line"><span class="type">int</span> nerr;                  <span class="comment">// 含糊不清的缩写.</span></span><br><span class="line"><span class="type">int</span> n_comp_conns;          <span class="comment">// 含糊不清的缩写.</span></span><br><span class="line"><span class="type">int</span> wgc_connections;       <span class="comment">// 只有贵团队知道是什么意思.</span></span><br><span class="line"><span class="type">int</span> pc_reader;             <span class="comment">// &quot;pc&quot; 有太多可能的解释了.</span></span><br><span class="line"><span class="type">int</span> cstmr_id;              <span class="comment">// 删减了若干字母.</span></span><br></pre></td></tr></table></figure>

<p>  注意, 一些特定的广为人知的缩写是允许的, 例如用 i 表示迭代变量和用 T 表示模板参数.</p>
</li>
</ul>
<h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><ul>
<li><p>总述</p>
<p>  文件名要全部小写, 可以包含下划线<code>_</code>或连字符<code>-</code>, 依照项目的约定. 如果没有约定, 那么<code>_</code>更好.</p>
</li>
<li><p>说明</p>
<p>  可接受的文件命名示例:</p>
<ul>
<li><p><code>my_useful_class.cc</code></p>
</li>
<li><p><code>my-useful-class.cc</code></p>
</li>
<li><p><code>myusefulclass.cc</code></p>
</li>
<li><p><code>myusefulclass_test.cc</code> // <code>_unittest</code> 和 <code>_regtest</code> 已弃用</p>
<p>C++ 文件要以<code>.cc</code>结尾, 头文件以<code>.h</code>结尾. 专门插入文本的文件则以<code>.inc</code>结尾</p>
<p>不要使用已经存在于<code>/usr/include</code>下的文件名, 如<code>db.h</code>.</p>
<p>通常应尽量让文件名更加明确.<code>http_server_logs.h</code>就比<code>logs.h</code>要好. 定义类时文件名一般成对出现, 如<code>foo_bar.h</code>和<code>foo_bar.cc</code>, 对应于类<code>FooBar</code>.</p>
<p>内联函数必须放在<code>.h</code>文件中. 如果内联函数比较短, 就直接放在<code>.h</code>中.</p>
</li>
</ul>
</li>
</ul>
<h4 id="类型命名"><a href="#类型命名" class="headerlink" title="类型命名"></a>类型命名</h4><ul>
<li><p>总述</p>
<p>  类型名称的每个单词首字母均大写, 不包含下划线: <code>MyExcitingClass</code>, <code>MyExcitingEnum</code>.</p>
</li>
<li><p>说明</p>
<p>  所有类型命名 —— 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数 —— 均使用相同约定, 即以大写字母开始, 每个单词首字母均大写, 不包含下划线. 例如:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类和结构体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UrlTable</span> &#123; ...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UrlTableTester</span> &#123; ...</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UrlTableProperties</span> &#123; ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using 别名</span></span><br><span class="line"><span class="keyword">using</span> PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UrlTableErrors</span> &#123; ...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><ul>
<li><p>总述</p>
<p>  变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量<em>以下划线结尾</em>, 但结构体的就不用, 如: <code>a_local_variable</code>, <code>a_struct_data_member</code>, <code>a_class_data_member_</code>.</p>
</li>
<li><p>说明</p>
<ul>
<li><p>普通变量命名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string table_name;  <span class="comment">// 好 - 用下划线.</span></span><br><span class="line">string tablename;   <span class="comment">// 好 - 全小写.</span></span><br><span class="line">string tableName;  <span class="comment">// 差 - 混合大小写</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类数据成员</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TableInfo</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  string table_name_;  <span class="comment">// 好 - 后加下划线.</span></span><br><span class="line">  string tablename_;   <span class="comment">// 好.</span></span><br><span class="line">  <span class="type">static</span> Pool&lt;TableInfo&gt;* pool_;  <span class="comment">// 好.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">UrlTableProperties</span> &#123;</span><br><span class="line">  string name;</span><br><span class="line">  <span class="type">int</span> num_entries;</span><br><span class="line">  <span class="type">static</span> Pool&lt;UrlTableProperties&gt;* pool;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h4><ul>
<li><p>总述</p>
<p>  声明为<code>constexpr</code>或<code>const</code>的变量, 或在程序运行期间其值始终保持不变的,命名时以 “k” 开头, 大小写混合. 例如:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> kDaysInAWeek = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>说明</p>
</li>
</ul>
<p>所有具有静态存储类型的变量 (例如静态变量或全局变量) 都应当以此方式命名. 对于其他存储类型的变量, 如自动变量等, 这条规则是可选的. 如果不采用这条规则, 就按照一般的变量命名规则.</p>
<h4 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h4><ul>
<li><p>总述</p>
<p>  常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配: <code>MyExcitingFunction()</code>, <code>MyExcitingMethod()</code>, <code>my_exciting_member_variable()</code>, <code>set_my_exciting_member_variable()</code>.</p>
</li>
<li><p>说明</p>
<p>  一般来说, 函数名的每个单词首字母大写 (即 “驼峰变量名” 或 “帕斯卡变量名”), 没有下划线. 对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作<code>StartRpc()</code>而非<code>StartRPC()</code>).</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AddTableEntry</span>()</span><br><span class="line"><span class="built_in">DeleteUrl</span>()</span><br><span class="line"><span class="built_in">OpenFileOrDie</span>()</span><br></pre></td></tr></table></figure>

<p>  取值和设值函数的命名与变量一致. 一般来说它们的名称与实际的成员变量对应, 但并不强制要求. 例如<code>int count()</code>与<code>void set_count(int count)</code>.</p>
</li>
</ul>
<h4 id="命名空间命名"><a href="#命名空间命名" class="headerlink" title="命名空间命名"></a>命名空间命名</h4><ul>
<li><p>总述</p>
<p>  命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突.</p>
<p>  顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字. 命名空间中的代码, 应当存放于和命名空间的名字匹配的文件夹或其子文件夹中.</p>
<p>  要避免嵌套的命名空间与常见的顶级命名空间发生名称冲突. 由于名称查找规则的存在, 命名空间之间的冲突完全有可能导致编译失败. 尤其是, 不要创建嵌套的<code>std</code>命名空间. 建议使用更独特的项目标识符 (<code>websearch::index</code>,<code>websearch::index_util</code>) 而非常见的极易发生冲突的名称 (比如<code>websearch::util</code>).</p>
<p>  对于<code>internal</code>命名空间, 要当心加入到同一<code>internal</code>命名空间的代码之间发生冲突 (由于内部维护人员通常来自同一团队, 因此常有可能导致冲突). 在这种情况下, 请使用文件名以使得内部名称独一无二 (例如对于<code>frobber.h</code>, 使用<code>websearch::index::frobber_internal</code>).</p>
</li>
</ul>
<h4 id="枚举命名"><a href="#枚举命名" class="headerlink" title="枚举命名"></a>枚举命名</h4><ul>
<li><p>总述</p>
<p>  枚举的命名应当和 常量 或 宏 一致: <code>kEnumName</code>或是<code>ENUM_NAME</code>.</p>
</li>
<li><p>说明</p>
<p>  单独的枚举值应该优先采用 常量 的命名方式. 但 宏 方式的命名也可以接受. 枚举名<code>UrlTableErrors</code>(以及 <code>AlternateUrlTableErrors</code>) 是类型, 所以要用大小写混合的方式.</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">UrlTableErrors</span> &#123;</span><br><span class="line">    kOK = <span class="number">0</span>,</span><br><span class="line">    kErrorOutOfMemory,</span><br><span class="line">    kErrorMalformedInput,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">AlternateUrlTableErrors</span> &#123;</span><br><span class="line">    OK = <span class="number">0</span>,</span><br><span class="line">    OUT_OF_MEMORY = <span class="number">1</span>,</span><br><span class="line">    MALFORMED_INPUT = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="宏命名"><a href="#宏命名" class="headerlink" title="宏命名"></a>宏命名</h4><p>你并不打算 使用宏, 对吧? 如果你一定要用, 像这样命名: <code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN</code>.</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释虽然写起来很痛苦, 但对保证代码可读性至关重要. 下面的规则描述了如何注释以及在哪儿注释. 当然也要记住: 注释固然很重要, 但最好的代码应当本身就是文档. 有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字.</p>
<h4 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a>注释风格</h4><ul>
<li><p>总述</p>
<p>  使用<code>//</code>或<code>/* */</code>, 统一就好.</p>
</li>
<li><p>说明</p>
<p>  <code>//</code>或<code>/* */</code>都可以; 但<code>//</code>更 常用. 要在如何注释及注释风格上确保统一.</p>
</li>
</ul>
<h4 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h4><ul>
<li><p>总述</p>
<p>  在每一个文件开头加入版权公告.</p>
<p>  文件注释描述了该文件的内容. 如果一个文件只声明, 或实现, 或测试了一个对象, 并且这个对象已经在它的声明处进行了详细的注释, 那么就没必要再加上文件注释. 除此之外的其他文件都需要文件注释.</p>
</li>
<li><p>说明</p>
<ul>
<li><p>法律公告和作者信息</p>
<p>  每个文件都应该包含许可证引用. 为项目选择合适的许可证版本.(比如, Apache 2.0, BSD, LGPL, GPL)</p>
<p>  如果你对原始作者的文件做了重大修改, 请考虑删除原作者信息.</p>
</li>
<li><p>文件内容</p>
<p>  如果一个<code>.h</code>文件声明了多个概念, 则文件注释应当对文件的内容做一个大致的说明, 同时说明各概念之间的联系. 一个一到两行的文件注释就足够了, 对于每个概念的详细文档应当放在各个概念中, 而不是文件注释中.</p>
<p>  不要在<code>.h</code>和<code>.cc</code>之间复制注释, 这样的注释偏离了注释的实际意义.</p>
</li>
</ul>
</li>
</ul>
<h4 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h4><ul>
<li><p>总述</p>
<p>  每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显.</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Iterates over the contents of a GargantuanTable.</span></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="comment">//    GargantuanTableIterator* iter = table-&gt;NewIterator();</span></span><br><span class="line"><span class="comment">//    for (iter-&gt;Seek(&quot;foo&quot;); !iter-&gt;done(); iter-&gt;Next()) &#123;</span></span><br><span class="line"><span class="comment">//      process(iter-&gt;key(), iter-&gt;value());</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    delete iter;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GargantuanTableIterator</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>说明</p>
<p>  类注释应当为读者理解如何使用与何时使用类提供足够的信息, 同时应当提醒读者在正确使用此类时应当考虑的因素. 如果类有任何同步前提, 请用文档说明. 如果该类的实例可被多线程访问, 要特别注意文档说明多线程环境下相关的规则和常量使用.</p>
<p>  如果你想用一小段代码演示这个类的基本用法或通常用法, 放在类注释里也非常合适.</p>
<p>  如果类的声明和定义分开了(例如分别放在了<code>.h</code>和<code>.cc</code>文件中), 此时, 描述类用法的注释应当和接口定义放在一起, 描述类的操作和实现的注释应当和实现放在一起.</p>
</li>
</ul>
<h4 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h4><ul>
<li>总述</li>
</ul>
<p>函数声明处的注释描述函数功能; 定义处的注释描述函数实现.</p>
<ul>
<li><p>说明</p>
<ul>
<li><p>函数说明</p>
<p>  基本上每个函数声明处前都应当加上注释, 描述函数的功能和用途. 只有在函数的功能简单而明显时才能省略这些注释(例如, 简单的取值和设值函数). 注释使用叙述式 (“Opens the file”) 而非指令式 (“Open the file”); 注释只是为了描述函数, 而不是命令函数做什么. 通常, 注释不会描述函数如何工作. 那是函数定义部分的事情.</p>
<p>  函数声明处注释的内容:</p>
<ul>
<li><p>函数的输入输出.</p>
</li>
<li><p>对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数.</p>
</li>
<li><p>函数是否分配了必须由调用者释放的空间.</p>
</li>
<li><p>参数是否可以为空指针.</p>
</li>
<li><p>是否存在函数使用上的性能隐患.</p>
</li>
<li><p>如果函数是可重入的, 其同步前提是什么?</p>
<p>举例如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns an iterator for this table.  It is the client&#x27;s</span></span><br><span class="line"><span class="comment">// responsibility to delete the iterator when it is done with it,</span></span><br><span class="line"><span class="comment">// and it must not use the iterator once the GargantuanTable object</span></span><br><span class="line"><span class="comment">// on which the iterator was created has been deleted.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The iterator is initially positioned at the beginning of the table.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This method is equivalent to:</span></span><br><span class="line"><span class="comment">//    Iterator* iter = table-&gt;NewIterator();</span></span><br><span class="line"><span class="comment">//    iter-&gt;Seek(&quot;&quot;);</span></span><br><span class="line"><span class="comment">//    return iter;</span></span><br><span class="line"><span class="comment">// If you are going to immediately seek to another place in the</span></span><br><span class="line"><span class="comment">// returned iterator, it will be faster to use NewIterator()</span></span><br><span class="line"><span class="comment">// and avoid the extra seek.</span></span><br><span class="line"><span class="function">Iterator* <span class="title">GetIterator</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>但也要避免罗罗嗦嗦, 或者对显而易见的内容进行说明. 下面的注释就没有必要加上 “否则返回 false”, 因为已经暗含其中了:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns true if the table cannot hold any more entries.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsTableFull</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>注释函数重载时, 注释的重点应该是函数中被重载的部分, 而不是简单的重复被重载的函数的注释. 多数情况下, 函数重载不需要额外的文档, 因此也没有必要加上注释.</p>
<p>注释构造/析构函数时, 切记读代码的人知道构造/析构函数的功能, 所以 “销毁这一对象” 这样的注释是没有意义的. 你应当注明的是注明构造函数对参数做了什么 (例如, 是否取得指针所有权) 以及析构函数清理了什么. 如果都是些无关紧要的内容, 直接省掉注释. 析构函数前没有注释是很正常的.</p>
</li>
</ul>
</li>
<li><p>函数定义</p>
<p>  如果函数的实现过程中用到了很巧妙的方式, 那么在函数定义处应当加上解释性的注释. 例如, 你所使用的编程技巧, 实现的大致步骤, 或解释如此实现的理由. 举个例子, 你可以说明为什么函数的前半部分要加锁而后半部分不需要.</p>
<p>  不要 从<code>.h</code>文件或其他地方的函数声明处直接复制注释. 简要重述函数功能是可以的, 但注释重点要放在如何实现上.</p>
</li>
</ul>
</li>
</ul>
<h4 id="变量注释"><a href="#变量注释" class="headerlink" title="变量注释"></a>变量注释</h4><ul>
<li>总述</li>
</ul>
<p>通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.</p>
<ul>
<li><p>说明</p>
<ul>
<li><p>类数据成员</p>
<p>  每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途. 如果有非变量的参数(例如特殊值, 数据成员之间的关系, 生命周期等)不能够用类型与变量名明确表达, 则应当加上注释. 然而, 如果变量类型与变量名已经足以描述一个变量, 那么就不再需要加上注释.</p>
<p>  特别地, 如果变量可以接受<code>NULL</code>或<code>-1</code>等警戒值, 须加以说明. 比如:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// Used to bounds-check table accesses. -1 means</span></span><br><span class="line"><span class="comment">// that we don&#x27;t yet know how many entries the table has.</span></span><br><span class="line"><span class="type">int</span> num_total_entries_;</span><br></pre></td></tr></table></figure>
</li>
<li><p>全局变量</p>
<p>  和数据成员一样, 所有全局变量也要注释说明含义及用途, 以及作为全局变量的原因. 比如:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The total number of tests cases that we run through in this regression test.</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> kNumTestCases = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="实现注释"><a href="#实现注释" class="headerlink" title="实现注释"></a>实现注释</h4><ul>
<li>总述</li>
</ul>
<p>对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.</p>
<ul>
<li><p>说明</p>
<ul>
<li><p>代码前注释</p>
<p>  巧妙或复杂的代码段前要加注释. 比如:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Divide result by two, taking into account that x</span></span><br><span class="line"><span class="comment">// contains the carry from the add.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; result-&gt;<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">x = (x &lt;&lt; <span class="number">8</span>) + (*result)[i];</span><br><span class="line">(*result)[i] = x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">x &amp;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>行注释</p>
<p>  比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释. 比如:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// If we have enough memory, mmap the data portion too.</span></span><br><span class="line">mmap_budget = <span class="built_in">max</span>&lt;int64&gt;(<span class="number">0</span>, mmap_budget - index_-&gt;<span class="built_in">length</span>());</span><br><span class="line"><span class="keyword">if</span> (mmap_budget &gt;= data_size_ &amp;&amp; !<span class="built_in">MmapData</span>(mmap_chunk_bytes, mlock))</span><br><span class="line"><span class="keyword">return</span>;  <span class="comment">// Error already logged.</span></span><br></pre></td></tr></table></figure>

<p>  注意, 这里用了两段注释分别描述这段代码的作用, 和提示函数返回时错误已经被记入日志.</p>
</li>
<li><p>函数参数注释</p>
<p>  如果函数参数的意义不明显, 考虑用下面的方式进行弥补:</p>
<ul>
<li>如果参数是一个字面常量, 并且这一常量在多处函数调用中被使用, 用以推断它们一致, 你应当用一个常量名让这一约定变得更明显, 并且保证这一约定不会被打破.</li>
<li>考虑更改函数的签名, 让某个<code>bool</code>类型的参数变为<code>enum</code>类型, 这样可以让这个参数的值表达其意义.</li>
<li>如果某个函数有多个配置选项, 你可以考虑定义一个类或结构体以保存所有的选项, 并传入类或结构体的实例. 这样的方法有许多优点, 例如这样的选项可以在调用处用变量名引用, 这样就能清晰地表明其意义. 同时也减少了函数参数的数量, 使得函数调用更易读也易写. 除此之外, 以这样的方式, 如果你使用其他的选项, 就无需对调用点进行更改.</li>
<li>用具名变量代替大段而复杂的嵌套表达式.</li>
<li>万不得已时, 才考虑在调用点用注释阐明参数的意义.</li>
</ul>
</li>
<li><p>不允许的行为</p>
<p>  不要描述显而易见的现象, <em>永远不要</em>用自然语言翻译代码作为注释, 除非即使对深入理解 C++ 的读者来说代码的行为都是不明显的. 要假设读代码的人 C++ 水平比你高, 即便他/她可能不知道你的用意:</p>
<p>  你所提供的注释应当解释代码<em>为什么</em>要这么做和代码的目的, 或者最好是让代码自文档化.</p>
<p>  比较这样的注释:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find the element in the vector.  &lt;-- 差: 这太明显了!</span></span><br><span class="line"><span class="keyword">auto</span> iter = std::<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), element);</span><br><span class="line"><span class="keyword">if</span> (iter != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="built_in">Process</span>(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  和这样的注释:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Process &quot;element&quot; unless it was already processed.</span></span><br><span class="line"><span class="keyword">auto</span> iter = std::<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), element);</span><br><span class="line"><span class="keyword">if</span> (iter != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="built_in">Process</span>(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  自文档化的代码根本就不需要注释. 上面例子中的注释对下面的代码来说就是毫无必要的:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsAlreadyProcessed</span>(element)) &#123;</span><br><span class="line">    <span class="built_in">Process</span>(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="TODO注释"><a href="#TODO注释" class="headerlink" title="TODO注释"></a>TODO注释</h4><ul>
<li><p>总述</p>
<p>  对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用<code>TODO</code>注释.</p>
<p>  <code>TODO</code>注释要使用全大写的字符串<code>TODO</code>,在随后的圆括号里写上你的名字, 邮件地址, bug ID, 或其它身份标识和与这一<code>TODO</code>相关的 issue. 主要目的是让添加注释的人 (也是可以请求提供更多细节的人) 可根据规范的<code>TODO</code>格式进行查找. 添加<code>TODO</code>注释并不意味着你要自己来修正, 因此当你加上带有姓名的<code>TODO</code>时, 一般都是写上自己的名字.</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO(kl@gmail.com): Use a &quot;*&quot; here for concatenation operator.</span></span><br><span class="line"><span class="comment">// TODO(Zeke) change this to use relations.</span></span><br><span class="line"><span class="comment">// TODO(bug 12345): remove the &quot;Last visitors&quot; feature</span></span><br></pre></td></tr></table></figure>

<p>  如果加<code>TODO</code>是为了在 “将来某一天做某事”, 可以附上一个非常明确的时间 “Fix by November 2005”), 或者一个明确的事项 (“Remove this code when all clients can handle XML responses.”).</p>
</li>
</ul>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><ol>
<li>关于注释风格, 很多 C++ 的 coders 更喜欢行注释, C coders 或许对块注释依然情有独钟, 或者在文件头大段大段的注释时使用块注释</li>
<li>文件注释可以炫耀你的成就, 也是为了捅了篓子别人可以找你</li>
<li>注释要言简意赅, 不要拖沓冗余, 复杂的东西简单化和简单的东西复杂化都是要被鄙视的</li>
<li>对于 Chinese coders 来说, 用英文注释还是用中文注释, it is a problem, 但不管怎样, 注释是为了让别人看懂, 难道是为了炫耀编程语言之外的你的母语或外语水平吗</li>
<li>注释不要太乱, 适当的缩进才会让人乐意看. 但也没有必要规定注释从第几列开始 (我自己写代码的时候总喜欢这样), UNIX/LINUX 下还可以约定是使用 tab 还是 space, 个人倾向于 space</li>
<li>TODO 很不错, 有时候, 注释确实是为了标记一些未完成的或完成的不尽如人意的地方, 这样一搜索, 就知道还有哪些活要干, 日志都省了</li>
</ol>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><h4 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h4><ul>
<li><p>总述</p>
<p>  每一行代码字符数不超过 80.</p>
<p>  我们也认识到这条规则是有争议的, 但很多已有代码都遵照这一规则, 因此我们感觉一致性更重要.</p>
</li>
<li><p>优点</p>
<p>  提倡该原则的人认为强迫他们调整编辑器窗口大小是很野蛮的行为. 很多人同时并排开几个代码窗口, 根本没有多余的空间拉伸窗口. 大家都把窗口最大尺寸加以限定, 并且 80 列宽是传统标准. 那么为什么要改变呢?</p>
</li>
<li><p>缺点</p>
<p>  反对该原则的人则认为更宽的代码行更易阅读. 80 列的限制是上个世纪 60 年代的大型机的古板缺陷; 现代设备具有更宽的显示屏, 可以很轻松地显示更多代码.</p>
</li>
<li><p>结论</p>
<p>  80 个字符是最大值.</p>
<p>  如果无法在不伤害易读性的条件下进行断行, 那么注释行可以超过 80 个字符, 这样可以方便复制粘贴. 例如, 带有命令示例或 URL 的行可以超过 80 个字符.</p>
<p>  包含长路径的<code>#include</code>语句可以超出80列.</p>
</li>
</ul>
<h4 id="非ASCII字符"><a href="#非ASCII字符" class="headerlink" title="非ASCII字符"></a>非ASCII字符</h4><ul>
<li><p>总述</p>
<p>  尽量不使用非 ASCII 字符, 使用时必须使用<em>UTF-8</em>编码.</p>
</li>
<li><p>说明</p>
<p>  即使是英文, 也不应将用户界面的文本硬编码到源代码中, 因此非 ASCII 字符应当很少被用到. 特殊情况下可以适当包含此类字符. 例如, 代码分析外部数据文件时, 可以适当硬编码数据文件中作为分隔符的非 ASCII 字符串; 更常见的是 (不需要本地化的) 单元测试代码可能包含非 ASCII 字符串. 此类情况下, 应使用 UTF-8 编码, 因为很多工具都可以理解和处理 UTF-8 编码.</p>
</li>
</ul>
<h4 id="空格还是制表位"><a href="#空格还是制表位" class="headerlink" title="空格还是制表位"></a>空格还是制表位</h4><ul>
<li><p>总述</p>
<p>  只使用空格, 每次缩进2个空格.（如果你所在的项目使用4各空格缩进，那么请保持一致性）</p>
</li>
<li><p>说明</p>
<p>  我们使用空格缩进. 不要在代码中使用制表符. 你应该设置编辑器将制表符转为空格.</p>
</li>
</ul>
<h4 id="函数声明与定义"><a href="#函数声明与定义" class="headerlink" title="函数声明与定义"></a>函数声明与定义</h4><ul>
<li><p>总述</p>
<p>  返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与函数调用一致.</p>
</li>
<li><p>说明</p>
<p>  函数看上去像这样:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">ClassName::FunctionName</span><span class="params">(Type par_name1, Type par_name2)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  如果同一行文本太多, 放不下所有参数:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">ClassName::ReallyLongFunctionName</span><span class="params">(Type par_name1, Type par_name2,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             Type par_name3)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  甚至连第一个参数都放不下:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">LongClassName::ReallyReallyReallyLongFunctionName</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Type par_name1,  <span class="comment">// 4 space indent</span></span></span></span><br><span class="line"><span class="params"><span class="function">    Type par_name2,</span></span></span><br><span class="line"><span class="params"><span class="function">    Type par_name3)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();  <span class="comment">// 2 space indent</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  注意以下几点：</p>
<ul>
<li><p>使用好的参数名.</p>
</li>
<li><p>只有在参数未被使用或者其用途非常明显时, 才能省略参数名.</p>
</li>
<li><p>如果返回类型和函数名在一行放不下, 分行.</p>
</li>
<li><p>如果返回类型与函数声明或定义分行了, 不要缩进.</p>
</li>
<li><p>左圆括号总是和函数名在同一行.</p>
</li>
<li><p>函数名和左圆括号间永远没有空格.</p>
</li>
<li><p>圆括号与参数间没有空格.</p>
</li>
<li><p>左大括号{总在最后一个参数同一行的末尾处, 不另起新行.</p>
</li>
<li><p>右大括号总是单独位于函数最后一行, 或者与左大括号同一行.</p>
</li>
<li><p>右圆括号和左大括号间总是有一个空格.</p>
</li>
<li><p>所有形参应尽可能对齐.</p>
</li>
<li><p>缺省缩进为 2 个空格.</p>
</li>
<li><p>换行后的参数保持 4 个空格的缩进.</p>
<p>未被使用的参数, 或者根据上下文很容易看出其用途的参数, 可以省略参数名:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Foo</span>(Foo&amp;&amp;);</span><br><span class="line">  <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;);</span><br><span class="line">  Foo&amp; <span class="keyword">operator</span>=(Foo&amp;&amp;);</span><br><span class="line">  Foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>未被使用的参数如果其用途不明显的话, 在函数定义处将参数名注释起来:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Rotate</span><span class="params">(<span class="type">double</span> radians)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Rotate</span><span class="params">(<span class="type">double</span> radians)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Circle::Rotate</span><span class="params">(<span class="type">double</span> <span class="comment">/*radians*/</span>)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 差 - 如果将来有人要实现, 很难猜出变量的作用.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Circle::Rotate</span><span class="params">(<span class="type">double</span>)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>属性, 和展开为属性的宏, 写在函数声明或定义的最前面, 即返回类型之前:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">MUST_USE_RESULT <span class="type">bool</span> <span class="title">IsOK</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="Lambda表达式-1"><a href="#Lambda表达式-1" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><ul>
<li><p>总述</p>
<p>  Lambda 表达式对形参和函数体的格式化和其他函数一致; 捕获列表同理, 表项用逗号隔开.</p>
</li>
<li><p>说明</p>
<p>  若用引用捕获, 在变量名和<code>&amp;</code>之间不留空格.</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> add_to_x = [&amp;x](<span class="type">int</span> n) &#123; x += n; &#125;;</span><br></pre></td></tr></table></figure>

<p>  短 lambda 就写得和内联函数一样.</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; blacklist = &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; digits = &#123;<span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>&#125;;</span><br><span class="line">digits.<span class="built_in">erase</span>(std::<span class="built_in">remove_if</span>(digits.<span class="built_in">begin</span>(), digits.<span class="built_in">end</span>(), [&amp;blacklist](<span class="type">int</span> i) &#123;</span><br><span class="line">               <span class="keyword">return</span> blacklist.<span class="built_in">find</span>(i) != blacklist.<span class="built_in">end</span>();</span><br><span class="line">            &#125;),</span><br><span class="line">            digits.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><ul>
<li><p>总述</p>
<p>  要么一行写完函数调用, 要么在圆括号里对参数分行, 要么参数另起一行且缩进四格. 如果没有其它顾虑的话, 尽可能精简行数, 比如把多个参数适当地放在同一行里.</p>
</li>
<li><p>说明</p>
<p>  函数调用遵循如下形式</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> retval = <span class="built_in">DoSomething</span>(argument1, argument2, argument3);</span><br></pre></td></tr></table></figure>

<p>  如果同一行放不下, 可断为多行, 后面每一行都和第一个实参对齐, 左圆括号后和右圆括号前不要留空格：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> retval = <span class="built_in">DoSomething</span>(averyveryveryverylongargument1,</span><br><span class="line">                          argument2, argument3);</span><br></pre></td></tr></table></figure>

<p>  参数也可以放在次行, 缩进四格：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (...) &#123;</span><br><span class="line">    <span class="built_in">DoSomething</span>(</span><br><span class="line">        argument1, argument2,  <span class="comment">// 4 空格缩进</span></span><br><span class="line">        argument3, argument4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  如果一些参数本身就是略复杂的表达式, 且降低了可读性, 那么可以直接创建临时变量描述该表达式, 并传递给函数：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> my_heuristic = scores[x] * y + bases[x];</span><br><span class="line"><span class="type">bool</span> retval = <span class="built_in">DoSomething</span>(my_heuristic, x, y, z);</span><br></pre></td></tr></table></figure>

<p>  或者放着不管, 补充上注释：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> retval = <span class="built_in">DoSomething</span>(scores[x] * y + bases[x],  <span class="comment">// Score heuristic.</span></span><br><span class="line">                          x, y, z);</span><br></pre></td></tr></table></figure>

<p>  如果某参数独立成行, 对可读性更有帮助的话, 那也可以如此做. 参数的格式处理应当以可读性而非其他作为最重要的原则.</p>
<p>  此外, 如果一系列参数本身就有一定的结构, 可以酌情地按其结构来决定参数格式：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 3x3 矩阵转换 widget.</span></span><br><span class="line">my_widget.<span class="built_in">Transform</span>(x1, x2, x3,</span><br><span class="line">                    y1, y2, y3,</span><br><span class="line">                    z1, z2, z3);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="列表初始化-1"><a href="#列表初始化-1" class="headerlink" title="列表初始化"></a>列表初始化</h4><p>如果列表初始化伴随着名字, 比如类型或变量名, 格式化时将将名字视作函数调用名, {} 视作函数调用的括号. 如果没有名字, 就视作名字长度为零.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一行列表初始化示范.</span></span><br><span class="line"><span class="keyword">return</span> &#123;foo, bar&#125;;</span><br><span class="line"><span class="built_in">functioncall</span>(&#123;foo, bar&#125;);</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p&#123;foo, bar&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当不得不断行时.</span></span><br><span class="line"><span class="built_in">SomeFunction</span>(</span><br><span class="line">    &#123;<span class="string">&quot;assume a zero-length name before &#123;&quot;</span>&#125;,  <span class="comment">// 假设在 &#123; 前有长度为零的名字.</span></span><br><span class="line">    some_other_function_parameter);</span><br><span class="line">SomeType variable&#123;</span><br><span class="line">    some, other, values,</span><br><span class="line">    &#123;<span class="string">&quot;assume a zero-length name before &#123;&quot;</span>&#125;,  <span class="comment">// 假设在 &#123; 前有长度为零的名字.</span></span><br><span class="line">    SomeOtherType&#123;</span><br><span class="line">        <span class="string">&quot;Very long string requiring the surrounding breaks.&quot;</span>,  <span class="comment">// 非常长的字符串, 前后都需要断行.</span></span><br><span class="line">        some, other values&#125;,</span><br><span class="line">    SomeOtherType&#123;<span class="string">&quot;Slightly shorter string&quot;</span>,  <span class="comment">// 稍短的字符串.</span></span><br><span class="line">                  some, other, values&#125;&#125;;</span><br><span class="line">SomeType variable&#123;</span><br><span class="line">    <span class="string">&quot;This is too long to fit all in one line&quot;</span>&#125;;  <span class="comment">// 字符串过长, 因此无法放在同一行.</span></span><br><span class="line">MyType m = &#123;  <span class="comment">// 注意了, 您可以在 &#123; 前断行.</span></span><br><span class="line">    superlongvariablename1,</span><br><span class="line">    superlongvariablename2,</span><br><span class="line">    &#123;<span class="type">short</span>, interior, list&#125;,</span><br><span class="line">    &#123;interiorwrappinglist,</span><br><span class="line">     interiorwrappinglist2&#125;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><ul>
<li><p>总述</p>
<p>  倾向于不在圆括号内使用空格. 关键字<code>if</code>和<code>else</code>另起一行.</p>
</li>
<li><p>说明</p>
<p>  对基本条件语句有两种可以接受的格式. 一种在圆括号和条件之间有空格, 另一种没有.</p>
<p>  最常见的是没有空格的格式. 哪一种都可以, 最重要的是<em>保持一致</em>. 如果你是在修改一个文件, 参考当前已有格式. 如果是写新的代码, 参考目录下或项目中其它文件. 还在犹豫的话, 就不要加空格了.</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;  <span class="comment">// 圆括号里没有空格.</span></span><br><span class="line">  ...  <span class="comment">// 2 空格缩进.</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;  <span class="comment">// else 与 if 的右括号同一行.</span></span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  注意所有情况下<code>if</code>和左圆括号间都有个空格. 右圆括号和左大括号之间也要有个空格:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)     <span class="comment">// 差 - IF 后面没空格.</span></span><br><span class="line"><span class="keyword">if</span> (condition)&#123;   <span class="comment">// 差 - &#123; 前面没空格.</span></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;    <span class="comment">// 变本加厉地差.</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;  <span class="comment">// 好 - IF 和 &#123; 都与空格紧邻.</span></span><br></pre></td></tr></table></figure>

<p>  如果能增强可读性, 简短的条件语句允许写在同一行. 只有当语句简单并且没有使用<code>else</code>子句时使用:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == kFoo) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line"><span class="keyword">if</span> (x == kBar) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bar</span>();</span><br></pre></td></tr></table></figure>

<p>  如果语句有<code>else</code>分支则不允许:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不允许 - 当有 ELSE 分支时 IF 块却写在同一行</span></span><br><span class="line"><span class="keyword">if</span> (x) <span class="built_in">DoThis</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">DoThat</span>();</span><br></pre></td></tr></table></figure>

<p>  通常, 单行语句不需要使用大括号, 如果你喜欢用也没问题; 复杂的条件或循环语句用大括号可读性会更好. 也有一些项目要求<code>if</code>必须总是使用大括号:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">  <span class="built_in">DoSomething</span>();  <span class="comment">// 2 空格缩进.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();  <span class="comment">// 2 空格缩进.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  但如果语句中某个<code>if-else</code>分支使用了大括号的话, 其它分支也必须使用:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不可以这样子 - IF 有大括号 ELSE 却没有.</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  foo;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">  bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以这样子 - ELSE 有大括号 IF 却没有.</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">  foo;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只要其中一个分支用了大括号, 两个分支都要用上大括号.</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  foo;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="循环和开关选择语句"><a href="#循环和开关选择语句" class="headerlink" title="循环和开关选择语句"></a>循环和开关选择语句</h4><ul>
<li><p>总述</p>
<p>  <code>switch</code>语句可以使用大括号分段, 以表明 cases 之间不是连在一起的. 在单语句循环里, 括号可用可不用. 空循环体应使用<code>&#123;&#125;</code>或<code>continue</code>.</p>
</li>
<li><p>说明</p>
<p>  <code>switch</code>语句中的<code>case</code>块可以使用大括号也可以不用, 取决于你的个人喜好. 如果用的话, 要按照下文所述的方法.</p>
<p>  如果有不满足<code>case</code>条件的枚举值, <code>switch</code>应该总是包含一个<code>default</code>匹配 (如果有输入值没有 case 去处理, 编译器将给出 warning). 如果<code>default</code>应该永远执行不到, 简单的加条 <code>assert</code>:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (var) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: &#123;  <span class="comment">// 2 空格缩进</span></span><br><span class="line">    ...      <span class="comment">// 4 空格缩进</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">default</span>: &#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  在单语句循环里, 括号可用可不用：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I love you\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I take it back\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  空循环体应使用<code>&#123;&#125;</code>或<code>continue</code>, 而不是一个简单的分号.</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">  <span class="comment">// 反复循环直到条件失效.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i) &#123;&#125;  <span class="comment">// 可 - 空循环体.</span></span><br><span class="line"><span class="keyword">while</span> (condition) <span class="keyword">continue</span>;  <span class="comment">// 可 - contunue 表明没有逻辑.</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="指针和引用表达式"><a href="#指针和引用表达式" class="headerlink" title="指针和引用表达式"></a>指针和引用表达式</h4><ul>
<li><p>总述</p>
<p>  句点或箭头前后不要有空格. 指针/地址操作符 (<code>*, &amp;</code>) 之后不能有空格.</p>
</li>
<li><p>说明</p>
<p>  下面是指针和引用表达式的正确使用范例:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x = *p;</span><br><span class="line">p = &amp;x;</span><br><span class="line">x = r.y;</span><br><span class="line">x = r-&gt;y;</span><br></pre></td></tr></table></figure>

<p>  注意</p>
<ul>
<li><p>在访问成员时, 句点或箭头前后没有空格.</p>
</li>
<li><p>指针操作符 * 或 &amp; 后没有空格.</p>
<p>在声明指针变量或参数时, 星号与类型或变量名紧挨都可以:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 好, 空格前置.</span></span><br><span class="line"><span class="type">char</span> *c;</span><br><span class="line"><span class="type">const</span> string &amp;str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好, 空格后置.</span></span><br><span class="line"><span class="type">char</span>* c;</span><br><span class="line"><span class="type">const</span> string&amp; str;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x, *y;  <span class="comment">// 不允许 - 在多重声明中不能使用 &amp; 或 *</span></span><br><span class="line"><span class="type">char</span> * c;  <span class="comment">// 差 - * 两边都有空格</span></span><br><span class="line"><span class="type">const</span> string &amp; str;  <span class="comment">// 差 - &amp; 两边都有空格.</span></span><br></pre></td></tr></table></figure>

<p>在单个文件内要保持风格一致, 所以, 如果是修改现有文件, 要遵照该文件的风格.</p>
</li>
</ul>
</li>
</ul>
<h4 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h4><ul>
<li><p>总述</p>
<p>  如果一个布尔表达式超过标准行宽, 断行方式要统一一下.</p>
</li>
<li><p>说明</p>
<p>  下例中, 逻辑与 (<code>&amp;&amp;</code>) 操作符总位于行尾:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (this_one_thing &gt; this_other_thing &amp;&amp;</span><br><span class="line">    a_third_thing == a_fourth_thing &amp;&amp;</span><br><span class="line">    yet_another &amp;&amp; last_one) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><ul>
<li><p>总述</p>
<p>  不要在<code>return</code>表达式里加上非必须的圆括号.</p>
</li>
<li><p>说明</p>
<p>  只有在写<code>x = expr</code>要加上括号的时候才在<code>return expr;</code>里使用括号.</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> result;                  <span class="comment">// 返回值很简单, 没有圆括号.</span></span><br><span class="line"><span class="comment">// 可以用圆括号把复杂表达式圈起来, 改善可读性.</span></span><br><span class="line"><span class="keyword">return</span> (some_long_condition &amp;&amp;</span><br><span class="line">        another_condition);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="变量及数组初始化"><a href="#变量及数组初始化" class="headerlink" title="变量及数组初始化"></a>变量及数组初始化</h4><ul>
<li><p>总述</p>
<p>  用<code>=</code>,<code>()</code>和<code>&#123;&#125;</code>均可.</p>
</li>
<li><p>说明</p>
<p>  您可以用<code>=</code>,<code>()</code>和<code>&#123;&#125;</code>, 以下的例子都是正确的：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> x&#123;<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">string <span class="title">name</span><span class="params">(<span class="string">&quot;Some Name&quot;</span>)</span></span>;</span><br><span class="line">string name = <span class="string">&quot;Some Name&quot;</span>;</span><br><span class="line">string name&#123;<span class="string">&quot;Some Name&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>  请务必小心列表初始化<code>&#123;...&#125;</code>用<code>std::initializer_list</code>构造函数初始化出的类型. 非空列表初始化就会优先调用<code>std::initializer_list</code>, 不过空列表初始化除外, 后者原则上会调用默认构造函数. 为了强制禁用<code>std::initializer_list</code>构造函数, 请改用括号.</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>, <span class="number">1</span>)</span></span>;  <span class="comment">// 内容为 100 个 1 的向量.</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">100</span>, <span class="number">1</span>&#125;;  <span class="comment">// 内容为 100 和 1 的向量.</span></span><br></pre></td></tr></table></figure>

<p>  此外, 列表初始化不允许整型类型的四舍五入, 这可以用来避免一些类型上的编程失误.</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pi</span><span class="params">(<span class="number">3.14</span>)</span></span>;  <span class="comment">// 好 - pi == 3.</span></span><br><span class="line"><span class="type">int</span> pi&#123;<span class="number">3.14</span>&#125;;  <span class="comment">// 编译错误: 缩窄转换.</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h4><ul>
<li><p>总述</p>
<p>  预处理指令不要缩进, 从行首开始.</p>
</li>
<li><p>说明</p>
<p>  即使预处理指令位于缩进代码块中, 指令也应从行首开始.</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 好 - 指令从行首开始</span></span><br><span class="line">  <span class="keyword">if</span> (lopsided_score) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DISASTER_PENDING      <span class="comment">// 正确 - 从行首开始</span></span></span><br><span class="line">    <span class="built_in">DropEverything</span>();</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> NOTIFY               <span class="comment">// 非必要 - # 后跟空格</span></span></span><br><span class="line">    <span class="built_in">NotifyClient</span>();</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">BackToNormal</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h4><ul>
<li><p>总述</p>
<p>  构造函数初始化列表放在同一行或按四格缩进并排多行.</p>
</li>
<li><p>说明</p>
<p>  下面两种初始值列表方式都可以接受:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果所有变量能放在同一行:</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">int</span> var) : <span class="built_in">some_var_</span>(var) &#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不能放在同一行,</span></span><br><span class="line"><span class="comment">// 必须置于冒号后, 并缩进 4 个空格</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">int</span> var)</span><br><span class="line">    : <span class="built_in">some_var_</span>(var), <span class="built_in">some_other_var_</span>(var + <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">DoSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行</span></span><br><span class="line"><span class="comment">// 并逐行对齐</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">int</span> var)</span><br><span class="line">    : <span class="built_in">some_var_</span>(var),             <span class="comment">// 4 space indent</span></span><br><span class="line">    <span class="built_in">some_other_var_</span>(var + <span class="number">1</span>) &#123;  <span class="comment">// lined up</span></span><br><span class="line">  <span class="built_in">DoSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右大括号 &#125; 可以和左大括号 &#123; 放在同一行</span></span><br><span class="line"><span class="comment">// 如果这样做合适的话</span></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">int</span> var)</span><br><span class="line">    : <span class="built_in">some_var_</span>(var) &#123;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="命名空间格式化"><a href="#命名空间格式化" class="headerlink" title="命名空间格式化"></a>命名空间格式化</h4><ul>
<li><p>总述</p>
<p>  命名空间内容不缩进.</p>
</li>
<li><p>说明</p>
<p>  命名空间 不要增加额外的缩进层次, 例如:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;  <span class="comment">// 正确. 命名空间内没有额外的缩进.</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure>

<p>  不要在命名空间内缩进:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错, 缩进多余了.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure>

<p>  声明嵌套命名空间时, 每个命名空间都独立成行.</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> foo &#123;</span><br><span class="line"><span class="keyword">namespace</span> bar &#123;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="水平留白"><a href="#水平留白" class="headerlink" title="水平留白"></a>水平留白</h4><ul>
<li><p>总述</p>
<p>  水平留白的使用根据在代码中的位置决定. 永远不要在行尾添加没意义的留白.</p>
</li>
<li><p>说明</p>
<ul>
<li><p>通用</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">bool</span> b)</span> </span>&#123;  <span class="comment">// 左大括号前总是有空格.</span></span><br><span class="line">  ...</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;  <span class="comment">// 分号前不加空格.</span></span><br><span class="line"><span class="comment">// 列表初始化中大括号内的空格是可选的.</span></span><br><span class="line"><span class="comment">// 如果加了空格, 那么两边都要加上.</span></span><br><span class="line"><span class="type">int</span> x[] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> x[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承与初始化列表中的冒号前后恒有空格.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> : <span class="keyword">public</span> Bar &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 对于单行函数的实现, 在大括号内加上空格</span></span><br><span class="line">  <span class="comment">// 然后是函数实现</span></span><br><span class="line">  <span class="built_in">Foo</span>(<span class="type">int</span> b) : <span class="built_in">Bar</span>(), <span class="built_in">baz_</span>(b) &#123;&#125;  <span class="comment">// 大括号里面是空的话, 不加空格.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123; baz_ = <span class="number">0</span>; &#125;  <span class="comment">// 用括号把大括号与实现分开.</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>  添加冗余的留白会给其他人编辑时造成额外负担. 因此, 行尾不要留空格. 如果确定一行代码已经修改完毕, 将多余的空格去掉; 或者在专门清理空格时去掉（尤其是在没有其他人在处理这件事的时候).</p>
</li>
<li><p>循环和条件语句</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (b) &#123;          <span class="comment">// if 条件语句和循环语句关键字后均有空格.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;          <span class="comment">// else 前后有空格.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (test) &#123;&#125;   <span class="comment">// 圆括号内部不紧邻空格.</span></span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">switch</span> ( i ) &#123;    <span class="comment">// 循环和条件语句的圆括号里可以与空格紧邻.</span></span><br><span class="line"><span class="keyword">if</span> ( test ) &#123;     <span class="comment">// 圆括号, 但这很少见. 总之要一致.</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i ) &#123;</span><br><span class="line"><span class="keyword">for</span> ( ; i &lt; <span class="number">5</span> ; ++i) &#123;  <span class="comment">// 循环里内 ; 后恒有空格, ;  前可以加个空格.</span></span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:         <span class="comment">// switch case 的冒号前无空格.</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">break</span>;  <span class="comment">// 如果冒号有代码, 加个空格.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>操作符</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 赋值运算符前后总是有空格.</span></span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.</span></span><br><span class="line"><span class="comment">// 圆括号内部没有紧邻空格.</span></span><br><span class="line">v = w * x + y / z;</span><br><span class="line">v = w*x + y/z;</span><br><span class="line">v = w * (x + z);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在参数和一元操作符之间不加空格.</span></span><br><span class="line">x = <span class="number">-5</span>;</span><br><span class="line">++x;</span><br><span class="line"><span class="keyword">if</span> (x &amp;&amp; !y)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>模板和转换</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.</span></span><br><span class="line">vector&lt;string&gt; x;</span><br><span class="line">y = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类型与指针操作符之间留空格也可以, 但要保持一致.</span></span><br><span class="line">vector&lt;<span class="type">char</span> *&gt; x;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="垂直留白"><a href="#垂直留白" class="headerlink" title="垂直留白"></a>垂直留白</h4><ul>
<li><p>总述</p>
<p>  垂直留白越少越好.</p>
</li>
<li><p>说明</p>
<p>  这不仅仅是规则而是原则问题了: 不在万不得已, 不要使用空行. 尤其是: 两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行, 函数体中也不要随意添加空行.</p>
<p>  基本原则是: 同一屏可以显示的代码越多, 越容易理解程序的控制流. 当然, 过于密集的代码块和过于疏松的代码块同样难看, 这取决于你的判断. 但通常是垂直留白越少越好.</p>
<p>  下面的规则可以让加入的空行更有效:</p>
<ul>
<li>函数体内开头或结尾的空行可读性微乎其微.</li>
<li>在多重 if-else 块里加空行或许有点可读性.</li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>对于代码格式, 因人, 系统而异各有优缺点, 但同一个项目中遵循同一标准还是有必要的;</li>
<li>行宽原则上不超过 80 列, 把 22 寸的显示屏都占完, 怎么也说不过去;</li>
<li>80 行限制事实上有助于避免代码可读性失控, 比如超多重嵌套块, 超多重函数调用等等.</li>
<li>尽量不使用非 ASCII 字符, 如果使用的话, 参考 UTF-8 格式 (尤其是 UNIX/Linux 下, Windows 下可以考虑宽字符), 尽量不将字符串常量耦合到代码中, 比如独立出资源文件, 这不仅仅是风格问题了;</li>
<li>UNIX/Linux 下无条件使用空格, MSVC 的话使用 Tab 也无可厚非;</li>
<li>函数参数, 逻辑条件, 初始化列表: 要么所有参数和函数名放在同一行, 要么所有参数并排分行;</li>
<li>除函数定义的左大括号可以置于行首外, 包括函数/类/结构体/枚举声明, 各种语句的左大括号置于行尾, 所有右大括号独立成行;</li>
<li>Google 强调有一对 if-else 时, 不论有没有嵌套, 都要有大括号</li>
<li><code>.</code>/<code>-&gt;</code> 操作符前后不留空格, <code>*</code>/<code>&amp;</code> 不要前后都留, 一个就可, 靠左靠右依各人喜好;</li>
<li>预处理指令/命名空间不使用额外缩进, 类/结构体/枚举/函数/语句使用缩进;</li>
<li>初始化用<code>=</code>还是<code>()</code>依个人喜好, 统一就好;</li>
<li><code>return</code>不要加<code>()</code>;</li>
<li>水平/垂直留白不要滥用, 怎么易读怎么来.</li>
</ul>
]]></content>
      <categories>
        <category>内功心法</category>
        <category>编码规范</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>代码风格</tag>
        <tag>CleanCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Google Python 编程风格</title>
    <url>/posts/436c/</url>
    <content><![CDATA[<p>Python相较于C++来说，语法和写法都比较简单，所以不像C++一样有那么多的规范，主要从<em>语言规范</em>和<em>风格规范</em>两个方面制定规范。</p>
<span id="more"></span>

<h2 id="语言规范"><a href="#语言规范" class="headerlink" title="语言规范"></a>语言规范</h2><h4 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h4><blockquote>
<p>Tip: 对你的代码运行pylint</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  pylint是一个在Python源代码中查找bug的工具. 对于C和C++这样的不那么动态的语言, 这些bug通常由编译器来捕获. 由于Python的动态特性, 有些警告可能不对. 不过伪告警应该很少.</p>
</li>
<li><p>优点</p>
<p>  可以捕获容易忽视的错误, 例如输入错误, 使用未赋值的变量等.</p>
</li>
<li><p>缺点</p>
<p>  pylint不完美. 要利用其优势, 我们有时侯需要:</p>
<ul>
<li>围绕着它来写代码</li>
<li>抑制其告警</li>
<li>改进它</li>
<li>忽略它.</li>
</ul>
</li>
<li><p>结论</p>
<p>  确保对你的代码运行pylint.抑制不准确的警告,以便能够将其他警告暴露出来。</p>
<p>  你可以通过设置一个行注释来抑制告警. 例如:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dict</span> = <span class="string">&#x27;something awful&#x27;</span>  <span class="comment"># Bad Idea... pylint: disable=redefined-builtin</span></span><br></pre></td></tr></table></figure>

<p>  pylint警告是以一个数字编号(如 <code>C0112</code> )和一个符号名(如 <code>empty-docstring</code> )来标识的. 在编写新代码或更新已有代码时对告警进行抑制, 推荐使用符号名来标识.</p>
<p>  如果警告的符号名不够见名知意，那么请对其增加一个详细解释。</p>
<p>  采用这种抑制方式的好处是我们可以轻松查找抑制并回顾它们.</p>
<p>  你可以使用命令 <code>pylint --list-msgs</code> 来获取pylint告警列表. 你可以使用命令 <code>pylint --help-msg=C6409</code> , 以获取关于特定消息的更多信息.</p>
<p>  相比较于之前使用的 <code>pylint: disable-msg</code> , 本文推荐使用 <code>pylint: disable</code> .</p>
<p>  要抑制”参数未使用”告警, 你可以用”_”作为参数标识符, 或者在参数名前加”unused_”. 遇到不能改变参数名的情况, 你可以通过在函数开头”提到”它们来消除告警. 例如:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, unused_b, unused_c, d=<span class="literal">None</span>, e=<span class="literal">None</span></span>):</span><br><span class="line">    _ = d, e</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><blockquote>
<p>Tip: 仅对包和模块使用导入</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  模块间共享代码的重用机制.</p>
</li>
<li><p>优点</p>
<p>  命名空间管理约定十分简单. 每个标识符的源都用一种一致的方式指示. x.Obj表示Obj对象定义在模块x中.</p>
</li>
<li><p>缺点</p>
<p>  模块名仍可能冲突. 有些模块名太长, 不太方便.</p>
</li>
<li><p>结论</p>
<ul>
<li><p><strong>不要</strong>使用<code>from x import *</code></p>
</li>
<li><p>使用<code>import x</code>来导入包和模块.</p>
</li>
<li><p>使用<code>from x import y</code>, 其中x是包前缀, y是不带前缀的模块名.</p>
</li>
<li><p>使用<code>from x import y as z</code>, 如果两个要导入的模块都叫做y或者y太长了.</p>
</li>
<li><p>例如, 模块<code>sound.effects.echo</code>可以用如下方式导入:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo</span><br><span class="line">...</span><br><span class="line">echo.EchoFilter(<span class="built_in">input</span>, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>导入时不要使用相对名称. 即使模块在同一个包中, 也要使用完整包名. 这能帮助你避免无意间导入一个包两次.</p>
</li>
</ul>
</li>
</ul>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><blockquote>
<p>Tip: 使用模块的全路径名来导入每个模块</p>
</blockquote>
<ul>
<li><p>优点</p>
<p>  避免模块名冲突. 查找包更容易.</p>
</li>
<li><p>缺点</p>
<p>  部署代码变难, 因为你必须复制包层次.</p>
</li>
<li><p>结论</p>
<p>  所有的新代码都应该用完整包名来导入每个模块.</p>
<p>  应该像下面这样导入:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reference in code with complete name.</span></span><br><span class="line"><span class="keyword">import</span> sound.effects.echo</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reference in code with just module name (preferred).</span></span><br><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><blockquote>
<p>Tip: 允许使用异常, 但必须小心</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  异常是一种跳出代码块的正常控制流来处理错误或者其它异常条件的方式.</p>
</li>
<li><p>优点</p>
<p>  正常操作代码的控制流不会和错误处理代码混在一起. 当某种条件发生时, 它也允许控制流跳过多个框架. 例如, 一步跳出N个嵌套的函数, 而不必继续执行错误的代码.</p>
</li>
<li><p>缺点</p>
<p>  可能会导致让人困惑的控制流. 调用库时容易错过错误情况.</p>
</li>
<li><p>结论</p>
<p>  异常必须遵守特定条件:</p>
<ul>
<li><p>像这样触发异常:<code>raise MyException(&quot;Error message&quot;)</code>或者<code>raise MyException</code>. 不要使用两个参数的形式(<code>raise MyException, &quot;Error message&quot;</code>)或者过时的字符串异常(<code>raise &quot;Error message&quot;</code>).</p>
</li>
<li><p>模块或包应该定义自己的特定域的异常基类, 这个基类应该从内建的Exception类继承. 模块的异常基类应该叫做”Error”.</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Error</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>永远不要使用<code>except:</code>语句来捕获所有异常, 也不要捕获<code>Exception</code>或者<code>StandardError</code>, 除非你打算重新触发该异常, 或者你已经在当前线程的最外层(记得还是要打印一条错误消息). 在异常这方面, Python非常宽容,<code>except:</code>真的会捕获包括Python语法错误在内的任何错误. 使用<code>except:</code>很容易隐藏真正的bug.</p>
</li>
<li><p>尽量减少<code>try/except</code>块中的代码量. <code>try</code>块的体积越大, 期望之外的异常就越容易被触发. 这种情况下, <code>try/except</code>块将隐藏真正的错误.</p>
</li>
<li><p>使用finally子句来执行那些无论try块中有没有异常都应该被执行的代码. 这对于清理资源常常很有用, 例如关闭文件.</p>
</li>
<li><p>当捕获异常时, 使用 as 而不要用逗号. 例如</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> Error</span><br><span class="line"><span class="keyword">except</span> Error <span class="keyword">as</span> error:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><blockquote>
<p>Tip: 避免全局变量</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  定义在模块级的变量.</p>
</li>
<li><p>优点</p>
<p>  偶尔有用.</p>
</li>
<li><p>缺点</p>
<p>  导入时可能改变模块行为, 因为导入模块时会对模块级变量赋值.</p>
</li>
<li><p>结论</p>
<p>  避免使用全局变量, 用类变量来代替. 但也有一些例外:</p>
<ul>
<li>脚本的默认选项.</li>
<li>模块级常量. 例如:<code>PI = 3.14159</code>. 常量应该全大写, 用下划线连接.</li>
<li>有时候用全局变量来缓存值或者作为函数返回值很有用.</li>
<li>如果需要, 全局变量应该仅在模块内部可用, 并通过模块级的公共函数来访问.</li>
</ul>
</li>
</ul>
<h4 id="嵌套-局部-内部类或函数"><a href="#嵌套-局部-内部类或函数" class="headerlink" title="嵌套/局部/内部类或函数"></a>嵌套/局部/内部类或函数</h4><blockquote>
<p>Tip: 鼓励使用嵌套/本地/内部类或函数</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  类可以定义在方法, 函数或者类中. 函数可以定义在方法或函数中. 封闭区间中定义的变量对嵌套函数是只读的.</p>
</li>
<li><p>优点</p>
<p>  允许定义仅用于有效范围的工具类和函数.</p>
</li>
<li><p>缺点</p>
<p>  嵌套类或局部类的实例不能序列化(pickled).</p>
</li>
<li><p>结论</p>
<p>  推荐使用.</p>
</li>
</ul>
<h4 id="列表推导-List-Comprehensions"><a href="#列表推导-List-Comprehensions" class="headerlink" title="列表推导(List Comprehensions)"></a>列表推导(List Comprehensions)</h4><blockquote>
<p>Tip: 可以在简单情况下使用</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  列表推导(list comprehensions)与生成器表达式(generator expression)提供了一种简洁高效的方式来创建列表和迭代器, 而不必借助<code>map()</code>, <code>filter()</code>, 或者<code>lambda</code>.</p>
</li>
<li><p>优点</p>
<p>  简单的列表推导可以比其它的列表创建方法更加清晰简单. 生成器表达式可以十分高效, 因为它们避免了创建整个列表.</p>
</li>
<li><p>缺点</p>
<p>  复杂的列表推导或者生成器表达式可能难以阅读.</p>
</li>
<li><p>结论</p>
<p>  适用于简单情况. 每个部分应该单独置于一行: 映射表达式, for语句, 过滤器表达式. 禁止多重for语句或过滤器表达式. 复杂情况下还是使用循环.</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes:</span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">if</span> x * y &gt; <span class="number">10</span>:</span><br><span class="line">            result.append((x, y))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> xrange(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">if</span> x != y:</span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> xrange(<span class="number">5</span>):</span><br><span class="line">                <span class="keyword">if</span> y != z:</span><br><span class="line">                    <span class="keyword">yield</span> (x, y, z)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ((x, complicated_transform(x))</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> long_generator_function(parameter)</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">squares = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">eat(jelly_bean <span class="keyword">for</span> jelly_bean <span class="keyword">in</span> jelly_beans</span><br><span class="line">    <span class="keyword">if</span> jelly_bean.color == <span class="string">&#x27;black&#x27;</span>)</span><br></pre></td></tr></table></figure>

  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">No:</span><br><span class="line">result = [(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>) <span class="keyword">if</span> x * y &gt; <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ((x, y, z)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> xrange(<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">if</span> x != y</span><br><span class="line">        <span class="keyword">for</span> z <span class="keyword">in</span> xrange(<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">if</span> y != z)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="默认迭代器和操作符"><a href="#默认迭代器和操作符" class="headerlink" title="默认迭代器和操作符"></a>默认迭代器和操作符</h4><blockquote>
<p>Tip: 如果类型支持, 就使用默认迭代器和操作符. 比如列表, 字典及文件等.</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  容器类型, 像字典和列表, 定义了默认的迭代器和关系测试操作符(<code>in</code>和<code>not in</code>)</p>
</li>
<li><p>优点</p>
<p>  默认操作符和迭代器简单高效, 它们直接表达了操作, 没有额外的方法调用. 使用默认操作符的函数是通用的. 它可以用于支持该操作的任何类型.</p>
</li>
<li><p>缺点</p>
<p>  你没法通过阅读方法名来区分对象的类型(例如, has_key()意味着字典). 不过这也是优点.</p>
</li>
<li><p>结论</p>
<p>  如果类型支持, 就使用默认迭代器和操作符, 例如列表, 字典和文件. 内建类型也定义了迭代器方法. 优先考虑这些方法, 而不是那些返回列表的方法. 当然，这样遍历容器时，你将不能修改容器.</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes:    <span class="keyword">for</span> key <span class="keyword">in</span> adict: ...</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> adict: ...</span><br><span class="line">        <span class="keyword">if</span> obj <span class="keyword">in</span> alist: ...</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> afile: ...</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">dict</span>.iteritems(): ...</span><br></pre></td></tr></table></figure>

  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">No:     <span class="keyword">for</span> key <span class="keyword">in</span> adict.keys(): ...</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> adict.has_key(key): ...</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> afile.readlines(): ...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><blockquote>
<p>Tip: 按需使用生成器.</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  所谓生成器函数, 就是每当它执行一次生成(yield)语句, 它就返回一个迭代器, 这个迭代器生成一个值. 生成值后, 生成器函数的运行状态将被挂起, 直到下一次生成.</p>
</li>
<li><p>优点</p>
<p>  简化代码, 因为每次调用时, 局部变量和控制流的状态都会被保存. 比起一次创建一系列值的函数, 生成器使用的内存更少.</p>
</li>
<li><p>缺点</p>
<p>  无</p>
</li>
<li><p>结论</p>
<p>  鼓励使用. 注意在生成器函数的文档字符串中使用<code>Yields:</code>而不是<code>Returns:</code>.</p>
</li>
</ul>
<h4 id="Lambda函数"><a href="#Lambda函数" class="headerlink" title="Lambda函数"></a>Lambda函数</h4><blockquote>
<p>Tip: 适用于单行函数</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  与语句相反, lambda在一个表达式中定义匿名函数. 常用于为<code>map()</code>和<code>filter()</code>之类的高阶函数定义回调函数或者操作符.</p>
</li>
<li><p>优点</p>
<p>  方便</p>
</li>
<li><p>缺点</p>
<p>  比本地函数更难阅读和调试. 没有函数名意味着堆栈跟踪更难理解. 由于lambda函数通常只包含一个表达式, 因此其表达能力有限.</p>
</li>
<li><p>结论</p>
<p>  适用于单行函数. 如果代码超过60-80个字符, 最好还是定义成常规(嵌套)函数.</p>
<p>  对于常见的操作符，例如乘法操作符，使用<code>operator</code>模块中的函数以代替<code>lambda</code>函数. 例如, 推荐使用 <code>operator.mul</code>, 而不是<code>lambda x, y: x * y</code>.</p>
</li>
</ul>
<h4 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h4><blockquote>
<p>Tip: 适用于单行函数</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  条件表达式是对于if语句的一种更为简短的句法规则. 例如:<code>x = 1 if cond else 2</code>.</p>
</li>
<li><p>优点</p>
<p>  比if语句更加简短和方便.</p>
</li>
<li><p>缺点</p>
<p>  比if语句更加简短和方便.</p>
</li>
<li><p>结论</p>
<p>  适用于单行函数. 在其他情况下，推荐使用完整的if语句.</p>
</li>
</ul>
<h4 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h4><blockquote>
<p>Tip: 适用于大部分情况.</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  你可以在函数参数列表的最后指定变量的值, 例如, def <code>foo(a, b = 0):</code>. 如果调用foo时只带一个参数, 则b被设为0. 如果带两个参数, 则b的值等于第二个参数.</p>
</li>
<li><p>优点</p>
<p>  你经常会碰到一些使用大量默认值的函数, 但偶尔(比较少见)你想要覆盖这些默认值. 默认参数值提供了一种简单的方法来完成这件事, 你不需要为这些罕见的例外定义大量函数. 同时, Python也不支持重载方法和函数, 默认参数是一种”仿造”重载行为的简单方式.</p>
</li>
<li><p>缺点</p>
<p>  默认参数只在模块加载时求值一次. 如果参数是列表或字典之类的可变类型, 这可能会导致问题. 如果函数修改了对象(例如向列表追加项), 默认值就被修改了.</p>
</li>
<li><p>结论</p>
<p>  鼓励使用, 不过有如下注意事项:</p>
<p>  不要在函数或方法定义中使用可变对象作为默认值.</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> b <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            b = []</span><br></pre></td></tr></table></figure>

  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">No:  <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b=[]</span>):</span><br><span class="line">        ...</span><br><span class="line">No:  <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b=time.time(<span class="params"></span>)</span>):  <span class="comment"># The time the module was loaded???</span></span><br><span class="line">        ...</span><br><span class="line">No:  <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a, b=FLAGS.my_thing</span>):  <span class="comment"># sys.argv has not yet been parsed...</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="属性-properties"><a href="#属性-properties" class="headerlink" title="属性(properties)"></a>属性(properties)</h4><blockquote>
<p>Tip: 访问和设置数据成员时, 你通常会使用简单, 轻量级的访问和设置函数. 建议用属性（properties）来代替它们.</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  一种用于包装方法调用的方式. 当运算量不大, 它是获取和设置属性(attribute)的标准方式.</p>
</li>
<li><p>优点</p>
<p>  通过消除简单的属性(attribute)访问时显式的get和set方法调用, 可读性提高了. 允许懒惰的计算. 用Pythonic的方式来维护类的接口. 就性能而言, 当直接访问变量是合理的, 添加访问方法就显得琐碎而无意义. 使用属性(properties)可以绕过这个问题. 将来也可以在不破坏接口的情况下将访问方法加上.</p>
</li>
<li><p>缺点</p>
<p>  属性(properties)是在get和set方法声明后指定, 这需要使用者在接下来的代码中注意: set和get是用于属性(properties)的(除了用<code>@property</code>装饰器创建的只读属性). 必须继承自object类. 可能隐藏比如操作符重载之类的副作用. 继承时可能会让人困惑.</p>
</li>
<li><p>结论</p>
<p>  你通常习惯于使用访问或设置方法来访问或设置数据, 它们简单而轻量. 不过我们建议你在新的代码中使用属性. 只读属性应该用<code>@property</code>装饰器 来创建.</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">@score.setter</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self, value</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must be an integer!&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0 ~ 100!&#x27;</span>)</span><br><span class="line">    self._score = value</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="True-False的求值"><a href="#True-False的求值" class="headerlink" title="True/False的求值"></a>True/False的求值</h4><blockquote>
<p>Tip: 尽可能使用隐式false</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  Python在布尔上下文中会将某些值求值为false. 按简单的直觉来讲, 就是所有的”空”值都被认为是false. 因此<code>0</code>，<code>None</code>,<code>[]</code>,<code>&#123;&#125;</code>,<code>&quot;&quot;</code>都被认为是false.</p>
</li>
<li><p>优点</p>
<p>  使用Python布尔值的条件语句更易读也更不易犯错. 大部分情况下, 也更快.</p>
</li>
<li><p>缺点</p>
<p>  对C/C++开发人员来说, 可能看起来有点怪.</p>
</li>
<li><p>结论</p>
<p>  尽可能使用隐式的false, 例如: 使用<code>if foo:</code>而不是 <code>if foo != []:</code>. 不过还是有一些注意事项需要你铭记在心:</p>
<ul>
<li><p>永远不要用==或者!=来比较单件, 比如<code>None</code>. 使用<code>is</code>或者<code>is not</code>.</p>
</li>
<li><p>注意: 当你写下<code>if x:</code>时, 你其实表示的是<code>if x is not None</code>. 例如: 当你要测试一个默认值是None的变量或参数是否被设为其它值. 这个值在布尔语义下可能是false!</p>
</li>
<li><p>永远不要用<code>==</code>将一个布尔量与false相比较. 使用<code>if not x:</code>代替. 如果你需要区分<code>false</code>和<code>None</code>, 你应该用像<code>if not x and x is not None:</code>这样的语句.</p>
</li>
<li><p>对于序列(字符串, 列表, 元组), 要注意空序列是false. 因此<code>if not seq:</code>或者<code>if seq:</code>比<code>if len(seq):</code>或<code>if not len(seq):</code>要更好.</p>
</li>
<li><p>处理整数时, 使用隐式false可能会得不偿失(即不小心将None当做0来处理). 你可以将一个已知是整型(且不是len()的返回结果)的值与0比较.</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes:    <span class="keyword">if</span> <span class="keyword">not</span> users:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;no users&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> foo == <span class="number">0</span>:</span><br><span class="line">            self.handle_zero()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            self.handle_multiple_of_ten()</span><br></pre></td></tr></table></figure>

  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">No:     <span class="keyword">if</span> <span class="built_in">len</span>(users) == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;no users&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> foo <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> foo:</span><br><span class="line">            self.handle_zero()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> i % <span class="number">10</span>:</span><br><span class="line">            self.handle_multiple_of_ten()</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意’0’(字符串)会被当做true.</p>
</li>
</ul>
</li>
</ul>
<h4 id="过时的语言特性"><a href="#过时的语言特性" class="headerlink" title="过时的语言特性"></a>过时的语言特性</h4><blockquote>
<p>Tip: 尽可能使用字符串方法取代字符串模块. 使用函数调用语法取代apply(). 使用列表推导, for循环取代filter(), map()以及reduce().</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  当前版本的Python提供了大家通常更喜欢的替代品.</p>
</li>
<li><p>结论</p>
<p>  我们不使用不支持这些特性的Python版本, 所以没理由不用新的方式.</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes:    words = foo.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        [x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> my_list <span class="keyword">if</span> x[<span class="number">2</span>] == <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">        <span class="built_in">map</span>(math.sqrt, data)    <span class="comment"># Ok. No inlined lambda expression.</span></span><br><span class="line"></span><br><span class="line">        fn(*args, **kwargs)</span><br></pre></td></tr></table></figure>

  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">No:     words = string.split(foo, <span class="string">&#x27;:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x[<span class="number">1</span>], <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x[<span class="number">2</span>] == <span class="number">5</span>, my_list))</span><br><span class="line"></span><br><span class="line">        apply(fn, args, kwargs)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="词法作用域-Lexical-Scoping"><a href="#词法作用域-Lexical-Scoping" class="headerlink" title="词法作用域(Lexical Scoping)"></a>词法作用域(Lexical Scoping)</h4><blockquote>
<p>Tip: 推荐使用</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  嵌套的Python函数可以引用外层函数中定义的变量, 但是不能够对它们赋值. 变量绑定的解析是使用词法作用域, 也就是基于静态的程序文本. 对一个块中的某个名称的任何赋值都会导致Python将对该名称的全部引用当做局部变量, 甚至是赋值前的处理. 如果碰到global声明, 该名称就会被视作全局变量.</p>
<p>  一个使用这个特性的例子:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_adder</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns a function that adds numbers to a given number.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">adder</span>(<span class="params">summand1, summand2</span>):</span><br><span class="line">        <span class="keyword">return</span> summand1 + summand2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> adder</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点</p>
<p>  通常可以带来更加清晰, 优雅的代码. 尤其会让有经验的Lisp和Scheme(还有Haskell, ML等)程序员感到欣慰.</p>
</li>
<li><p>缺点</p>
<p>  可能导致让人迷惑的bug. 例如下面这个依据 PEP-0227 的例子:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">4</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">        <span class="built_in">print</span> i,</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="comment"># A bunch of code here</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> x:  <span class="comment"># Ah, i *is* local to Foo, so this is what Bar sees</span></span><br><span class="line">        <span class="built_in">print</span> i,</span><br><span class="line">    bar()</span><br></pre></td></tr></table></figure>

<p>  因此<code>foo([1, 2, 3])</code>会打印<code>1 2 3 3</code>, 不是<code>1 2 3 4</code>. x是一个列表, for循环其实是将x中的值依次赋给i.这样对i的赋值就隐式的发生了, 整个foo函数体中的i都会被当做局部变量, 包括bar()中的那个.</p>
</li>
<li><p>结论</p>
<p>  鼓励使用</p>
</li>
</ul>
<h4 id="函数与方法装饰器"><a href="#函数与方法装饰器" class="headerlink" title="函数与方法装饰器"></a>函数与方法装饰器</h4><blockquote>
<p>Tip: 如果好处很显然, 就明智而谨慎的使用装饰器</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  用于函数及方法的装饰器 (也就是@标记). 最常见的装饰器是<code>@classmethod</code>和<code>@staticmethod</code>, 用于将常规函数转换成类方法或静态方法. 不过, 装饰器语法也允许用户自定义装饰器. 特别地, 对于某个函数<code>my_decorator</code>, 下面的两段代码是等效的:</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">    @my_decorator</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># method body ...</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># method body ...</span></span><br><span class="line">    method = my_decorator(method)</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点</p>
<p>  优雅的在函数上指定一些转换. 该转换可能减少一些重复代码, 保持已有函数不变(enforce invariants), 等.</p>
</li>
<li><p>缺点</p>
<p>  装饰器可以在函数的参数或返回值上执行任何操作, 这可能导致让人惊异的隐藏行为. 而且, 装饰器在导入时执行. 从装饰器代码的失败中恢复更加不可能.</p>
</li>
<li><p>结论</p>
<p>  如果好处很显然, 就明智而谨慎的使用装饰器. 装饰器应该遵守和函数一样的导入和命名规则. 装饰器的python文档应该清晰的说明该函数是一个装饰器. 请为装饰器编写单元测试.</p>
<p>  避免装饰器自身对外界的依赖(即不要依赖于文件, socket, 数据库连接等), 因为装饰器运行时这些资源可能不可用(由 pydoc 或其它工具导入). 应该保证一个用有效参数调用的装饰器在所有情况下都是成功的.</p>
</li>
</ul>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><blockquote>
<p>Tip: 不要依赖内建类型的原子性.</p>
</blockquote>
<p>虽然Python的内建类型例如字典看上去拥有原子操作, 但是在某些情形下它们仍然不是原子的(即: 如果__hash__或__eq__被实现为Python方法)且它们的原子性是靠不住的. 你也不能指望原子变量赋值(因为这个反过来依赖字典).</p>
<p>优先使用Queue模块的<code>Queue</code>数据类型作为线程间的数据通信方式. 另外, 使用threading模块及其锁原语(locking primitives). 了解条件变量的合适使用方式, 这样你就可以使用<code>threading.Condition</code>来取代低级别的锁了.</p>
<h4 id="威力过大的特性"><a href="#威力过大的特性" class="headerlink" title="威力过大的特性"></a>威力过大的特性</h4><blockquote>
<p>Tip: 避免使用这些特性</p>
</blockquote>
<ul>
<li><p>定义</p>
<p>  Python是一种异常灵活的语言, 它为你提供了很多花哨的特性, 诸如元类(metaclasses), 字节码访问, 任意编译(on-the-fly compilation), 动态继承, 对象父类重定义(object reparenting), 导入黑客(import hacks), 反射, 系统内修改(modification of system internals), 等等.</p>
</li>
<li><p>优点</p>
<p>  强大的语言特性, 能让你的代码更紧凑.</p>
</li>
<li><p>缺点</p>
<p>  使用这些很”酷”的特性十分诱人, 但不是绝对必要. 使用奇技淫巧的代码将更加难以阅读和调试. 开始可能还好(对原作者而言), 但当你回顾代码, 它们可能会比那些稍长一点但是很直接的代码更加难以理解.</p>
</li>
<li><p>结论</p>
<p>  在你的代码中避免这些特性.</p>
</li>
</ul>
<h2 id="风格规范"><a href="#风格规范" class="headerlink" title="风格规范"></a>风格规范</h2><h4 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h4><blockquote>
<p>Tip: 不要在行尾加分号, 也不要用分号将两条命令放在同一行.</p>
</blockquote>
<h4 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h4><blockquote>
<p>Tip: 每行不超过80个字符</p>
</blockquote>
<p>例外:</p>
<pre><code>1. 长的导入模块语句
1. 注释里的URL
</code></pre>
<p>不要使用反斜杠连接行.</p>
<p>Python会将<code>圆括号</code>,<code>中括号</code>和<code>花括号</code>中的行隐式的连接起来 , 你可以利用这个特点. 如果需要, 你可以在表达式外围增加一对额外的圆括号.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: foo_bar(self, width, height, color=<span class="string">&#x27;black&#x27;</span>, design=<span class="literal">None</span>, x=<span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">             emphasis=<span class="literal">None</span>, highlight=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (width == <span class="number">0</span> <span class="keyword">and</span> height == <span class="number">0</span> <span class="keyword">and</span></span><br><span class="line">         color == <span class="string">&#x27;red&#x27;</span> <span class="keyword">and</span> emphasis == <span class="string">&#x27;strong&#x27;</span>):</span><br></pre></td></tr></table></figure>

<p>如果一个文本字符串在一行放不下, 可以使用圆括号来实现隐式行连接:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = (<span class="string">&#x27;This will build a very long long &#x27;</span></span><br><span class="line">     <span class="string">&#x27;long long long long long long string&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在注释中，如果必要，将长的URL放在一行上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> Google 开源项目风格指南</span><br><span class="line">latest</span><br><span class="line"></span><br><span class="line">Search docs</span><br><span class="line">Google 开源项目风格指南 (中文版)</span><br><span class="line">C++ 风格指南 - 内容目录</span><br><span class="line">Objective-C 风格指南 - 内容目录</span><br><span class="line">Python 风格指南 - 内容目录</span><br><span class="line">扉页</span><br><span class="line">背景</span><br><span class="line">Python语言规范</span><br><span class="line">Python风格规范</span><br><span class="line">分号</span><br><span class="line">行长度</span><br><span class="line">括号</span><br><span class="line">缩进</span><br><span class="line">空行</span><br><span class="line">空格</span><br><span class="line">Shebang</span><br><span class="line">注释</span><br><span class="line">类</span><br><span class="line">字符串</span><br><span class="line">文件和sockets</span><br><span class="line">TODO注释</span><br><span class="line">导入格式</span><br><span class="line">语句</span><br><span class="line">访问控制</span><br><span class="line">命名</span><br><span class="line">Main</span><br><span class="line">临别赠言</span><br><span class="line">Shell 风格指南 - 内容目录</span><br><span class="line"></span><br><span class="line">Love Documentation? Write the Docs <span class="keyword">is</span> a community full of people like you!</span><br><span class="line">Sponsored · Ads served ethically</span><br><span class="line">Google 开源项目风格指南</span><br><span class="line">Docs » Python 风格指南 - 内容目录 » Python风格规范  Edit on GitHub</span><br><span class="line">Python风格规范</span><br><span class="line">分号</span><br><span class="line">Tip</span><br><span class="line"></span><br><span class="line">不要在行尾加分号, 也不要用分号将两条命令放在同一行.</span><br><span class="line"></span><br><span class="line">行长度</span><br><span class="line">Tip</span><br><span class="line"></span><br><span class="line">每行不超过<span class="number">80</span>个字符</span><br><span class="line"></span><br><span class="line">例外:</span><br><span class="line"></span><br><span class="line">长的导入模块语句</span><br><span class="line">注释里的URL</span><br><span class="line">不要使用反斜杠连接行.</span><br><span class="line"></span><br><span class="line">Python会将 圆括号, 中括号和花括号中的行隐式的连接起来 , 你可以利用这个特点. 如果需要, 你可以在表达式外围增加一对额外的圆括号.</span><br><span class="line"></span><br><span class="line">```Python</span><br><span class="line">Yes: foo_bar(self, width, height, color=<span class="string">&#x27;black&#x27;</span>, design=<span class="literal">None</span>, x=<span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">             emphasis=<span class="literal">None</span>, highlight=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (width == <span class="number">0</span> <span class="keyword">and</span> height == <span class="number">0</span> <span class="keyword">and</span></span><br><span class="line">         color == <span class="string">&#x27;red&#x27;</span> <span class="keyword">and</span> emphasis == <span class="string">&#x27;strong&#x27;</span>):</span><br></pre></td></tr></table></figure>

<p>如果一个文本字符串在一行放不下, 可以使用圆括号来实现隐式行连接:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = (<span class="string">&#x27;This will build a very long long &#x27;</span></span><br><span class="line">     <span class="string">&#x27;long long long long long long string&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在注释中，如果必要，将长的URL放在一行上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes:  <span class="comment"># See details at</span></span><br><span class="line">      <span class="comment"># http://www.example.com/us/developer/documentation/api/content/v2.0/csv_file_name_extension_full_specification.html</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">No:  <span class="comment"># See details at</span></span><br><span class="line">     <span class="comment"># http://www.example.com/us/developer/documentation/api/content/\</span></span><br><span class="line">     <span class="comment"># v2.0/csv_file_name_extension_full_specification.html</span></span><br></pre></td></tr></table></figure>

<h4 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h4><blockquote>
<p>Tip: 宁缺毋滥的使用括号</p>
</blockquote>
<p>除非是用于实现行连接, 否则不要在返回语句或条件语句中使用括号. 不过在元组两边使用括号是可以的.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: <span class="keyword">if</span> foo:</span><br><span class="line">         bar()</span><br><span class="line">     <span class="keyword">while</span> x:</span><br><span class="line">         x = bar()</span><br><span class="line">     <span class="keyword">if</span> x <span class="keyword">and</span> y:</span><br><span class="line">         bar()</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">         bar()</span><br><span class="line">     <span class="keyword">return</span> foo</span><br><span class="line">     <span class="keyword">for</span> (x, y) <span class="keyword">in</span> <span class="built_in">dict</span>.items(): ...</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">No:  <span class="keyword">if</span> (x):</span><br><span class="line">         bar()</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span>(x):</span><br><span class="line">         bar()</span><br><span class="line">     <span class="keyword">return</span> (foo)</span><br></pre></td></tr></table></figure>

<h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><blockquote>
<p>Tip: 用4个空格来缩进代码</p>
</blockquote>
<p>绝对不要用tab, 也不要tab和空格混用. 对于行连接的情况, 你应该要么垂直对齐换行的元素, 或者使用4空格的悬挂式缩进(这时第一行不应该有参数):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes:   <span class="comment"># Aligned with opening delimiter</span></span><br><span class="line">       foo = long_function_name(var_one, var_two,</span><br><span class="line">                                var_three, var_four)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># Aligned with opening delimiter in a dictionary</span></span><br><span class="line">       foo = &#123;</span><br><span class="line">           long_dictionary_key: value1 +</span><br><span class="line">                                value2,</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 4-space hanging indent; nothing on first line</span></span><br><span class="line">       foo = long_function_name(</span><br><span class="line">           var_one, var_two, var_three,</span><br><span class="line">           var_four)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 4-space hanging indent in a dictionary</span></span><br><span class="line">       foo = &#123;</span><br><span class="line">           long_dictionary_key:</span><br><span class="line">               long_dictionary_value,</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">No:    <span class="comment"># Stuff on first line forbidden</span></span><br><span class="line">      foo = long_function_name(var_one, var_two,</span><br><span class="line">          var_three, var_four)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 2-space hanging indent forbidden</span></span><br><span class="line">      foo = long_function_name(</span><br><span class="line">        var_one, var_two, var_three,</span><br><span class="line">        var_four)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># No hanging indent in a dictionary</span></span><br><span class="line">      foo = &#123;</span><br><span class="line">          long_dictionary_key:</span><br><span class="line">              long_dictionary_value,</span><br><span class="line">              ...</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h4><blockquote>
<p>顶级定义之间空两行, 方法定义之间空一行</p>
</blockquote>
<p>顶级定义之间空两行, 比如函数或者类定义. 方法定义, 类定义与第一个方法之间, 都应该空一行. 函数或方法中, 某些地方要是你觉得合适, 就空一行.</p>
<h4 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h4><blockquote>
<p>按照标准的排版规范来使用标点两边的空格</p>
</blockquote>
<p>括号内不要有空格.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: spam(ham[<span class="number">1</span>], &#123;eggs: <span class="number">2</span>&#125;, [])</span><br><span class="line">No:  spam( ham[ <span class="number">1</span> ], &#123; eggs: <span class="number">2</span> &#125;, [ ] )</span><br></pre></td></tr></table></figure>

<p>不要在逗号, 分号, 冒号前面加空格, 但应该在它们后面加(除了在行尾).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: <span class="keyword">if</span> x == <span class="number">4</span>:</span><br><span class="line">         <span class="built_in">print</span> x, y</span><br><span class="line">     x, y = y, x</span><br><span class="line">No:  <span class="keyword">if</span> x == <span class="number">4</span> :</span><br><span class="line">         <span class="built_in">print</span> x , y</span><br><span class="line">     x , y = y , x</span><br></pre></td></tr></table></figure>

<p>参数列表, 索引或切片的左括号前不应加空格.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: spam(<span class="number">1</span>)</span><br><span class="line">no: spam (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">Yes: <span class="built_in">dict</span>[<span class="string">&#x27;key&#x27;</span>] = <span class="built_in">list</span>[index]</span><br><span class="line">No:  <span class="built_in">dict</span> [<span class="string">&#x27;key&#x27;</span>] = <span class="built_in">list</span> [index]</span><br></pre></td></tr></table></figure>

<p>在二元操作符两边都加上一个空格, 比如赋值(=), 比较(==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not), 布尔(and, or, not). 至于算术操作符两边的空格该如何使用, 需要你自己好好判断. 不过两侧务必要保持一致.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: x == <span class="number">1</span></span><br><span class="line">No:  x&lt;<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>当’=’用于指示关键字参数或默认参数值时, 不要在其两侧使用空格.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: <span class="keyword">def</span> <span class="title function_">complex</span>(<span class="params">real, imag=<span class="number">0.0</span></span>): <span class="keyword">return</span> magic(r=real, i=imag)</span><br><span class="line">No:  <span class="keyword">def</span> <span class="title function_">complex</span>(<span class="params">real, imag = <span class="number">0.0</span></span>): <span class="keyword">return</span> magic(r = real, i = imag)</span><br></pre></td></tr></table></figure>

<p>不要用空格来垂直对齐多行间的标记, 因为这会成为维护的负担(适用于:, #, =等):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes:</span><br><span class="line">     foo = <span class="number">1000</span>  <span class="comment"># comment</span></span><br><span class="line">     long_name = <span class="number">2</span>  <span class="comment"># comment that should not be aligned</span></span><br><span class="line"></span><br><span class="line">     dictionary = &#123;</span><br><span class="line">         <span class="string">&quot;foo&quot;</span>: <span class="number">1</span>,</span><br><span class="line">         <span class="string">&quot;long_name&quot;</span>: <span class="number">2</span>,</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">No:</span><br><span class="line">     foo       = <span class="number">1000</span>  <span class="comment"># comment</span></span><br><span class="line">     long_name = <span class="number">2</span>     <span class="comment"># comment that should not be aligned</span></span><br><span class="line"></span><br><span class="line">     dictionary = &#123;</span><br><span class="line">         <span class="string">&quot;foo&quot;</span>      : <span class="number">1</span>,</span><br><span class="line">         <span class="string">&quot;long_name&quot;</span>: <span class="number">2</span>,</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Shebang"><a href="#Shebang" class="headerlink" title="Shebang"></a>Shebang</h4><blockquote>
<p>大部分.py文件不必以#!作为文件的开始. 根据 PEP-394 , 程序的main文件应该以 #!/usr/bin/python2或者 #!/usr/bin/python3开始.</p>
</blockquote>
<p>在计算机科学中, Shebang (也称为Hashbang)是一个由井号和叹号构成的字符串行(#!), 其出现在文本文件的第一行的前两个字符. 在文件中存在Shebang的情况下, 类Unix操作系统的程序载入器会分析Shebang后的内容, 将这些内容作为解释器指令, 并调用该指令, 并将载有Shebang的文件路径作为该解释器的参数. 例如, 以指令#!/bin/sh开头的文件在执行时会实际调用/bin/sh程序.</p>
<p>#!先用于帮助内核找到Python解释器, 但是在导入模块时, 将会被忽略. 因此只有被直接执行的文件中才有必要加入#!.</p>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><blockquote>
<p>确保对模块, 函数, 方法和行内注释使用正确的风格</p>
</blockquote>
<h5 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h5><p>Python有一种独一无二的的注释方式: 使用文档字符串. 文档字符串是包, 模块, 类或函数里的第一个语句. 这些字符串可以通过对象的<code>__doc__</code>成员被自动提取, 并且被<code>pydoc</code>所用. (你可以在你的模块上运行pydoc试一把, 看看它长什么样). 我们对文档字符串的惯例是使用三重双引号<code>&quot;&quot;&quot;</code>. 一个文档字符串应该这样组织: 首先是一行以句号, 问号或惊叹号结尾的概述(或者该文档字符串单纯只有一行). 接着是一个空行. 接着是文档字符串剩下的部分, 它应该与文档字符串的第一行的第一个引号对齐. 下面有更多文档字符串的格式化规范.</p>
<h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>每个文件应该包含一个许可样板. 根据项目使用的许可(例如, Apache 2.0, BSD, LGPL, GPL), 选择合适的样板.</p>
<h5 id="函数和方法"><a href="#函数和方法" class="headerlink" title="函数和方法"></a>函数和方法</h5><p>下文所指的函数,包括函数, 方法, 以及生成器.</p>
<p>一个函数必须要有文档字符串, 除非它满足以下条件:</p>
<ul>
<li>外部不可见</li>
<li>非常短小</li>
<li>简单明了</li>
</ul>
<p>文档字符串应该包含函数做什么, 以及输入和输出的详细描述. 通常, 不应该描述”怎么做”, 除非是一些复杂的算法. 文档字符串应该提供足够的信息, 当别人编写代码调用该函数时, 他不需要看一行代码, 只要看文档字符串就可以了. 对于复杂的代码, 在代码旁边加注释会比使用文档字符串更有意义.</p>
<p>Args:</p>
<pre><code>列出每个参数的名字, 并在名字后使用一个冒号和一个空格, 分隔对该参数的描述.如果描述太长超过了单行80字符,使用2或者4个空格的悬挂缩进(与文件其他部分保持一致). 描述应该包括所需的类型和含义. 如果一个函数接受*foo(可变长度参数列表)或者**bar (任意关键字参数), 应该详细列出*foo和**bar.
</code></pre>
<p>Returns: (或者 Yields: 用于生成器)</p>
<pre><code>描述返回值的类型和语义. 如果函数返回None, 这一部分可以省略.
</code></pre>
<p>Raises:</p>
<pre><code>列出与接口有关的所有异常.
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_bigtable_rows</span>(<span class="params">big_table, keys, other_silly_variable=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Fetches rows from a Bigtable.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Retrieves rows pertaining to the given keys from the Table instance</span></span><br><span class="line"><span class="string">    represented by big_table.  Silly things may happen if</span></span><br><span class="line"><span class="string">    other_silly_variable is not None.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        big_table: An open Bigtable Table instance.</span></span><br><span class="line"><span class="string">        keys: A sequence of strings representing the key of each table row</span></span><br><span class="line"><span class="string">            to fetch.</span></span><br><span class="line"><span class="string">        other_silly_variable: Another optional variable, that has a much</span></span><br><span class="line"><span class="string">            longer name than the other args, and which does nothing.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        A dict mapping keys to the corresponding table row data</span></span><br><span class="line"><span class="string">        fetched. Each row is represented as a tuple of strings. For</span></span><br><span class="line"><span class="string">        example:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &#123;&#x27;Serak&#x27;: (&#x27;Rigel VII&#x27;, &#x27;Preparer&#x27;),</span></span><br><span class="line"><span class="string">         &#x27;Zim&#x27;: (&#x27;Irk&#x27;, &#x27;Invader&#x27;),</span></span><br><span class="line"><span class="string">         &#x27;Lrrr&#x27;: (&#x27;Omicron Persei 8&#x27;, &#x27;Emperor&#x27;)&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        If a key from the keys argument is missing from the dictionary,</span></span><br><span class="line"><span class="string">        then that row was not found in the table.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Raises:</span></span><br><span class="line"><span class="string">        IOError: An error occurred accessing the bigtable.Table object.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><p>类应该在其定义下有一个用于描述该类的文档字符串. 如果你的类有公共属性(Attributes), 那么文档中应该有一个属性(Attributes)段. 并且应该遵守和函数参数相同的格式.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SampleClass</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Summary of class here.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Longer class information....</span></span><br><span class="line"><span class="string">    Longer class information....</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        likes_spam: A boolean indicating if we like SPAM or not.</span></span><br><span class="line"><span class="string">        eggs: An integer count of the eggs we have laid.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, likes_spam=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Inits SampleClass with blah.&quot;&quot;&quot;</span></span><br><span class="line">        self.likes_spam = likes_spam</span><br><span class="line">        self.eggs = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">public_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Performs operation blah.&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="块注释和行注释"><a href="#块注释和行注释" class="headerlink" title="块注释和行注释"></a>块注释和行注释</h5><p>最需要写注释的是代码中那些技巧性的部分. 如果你在下次代码审查的时候必须解释一下, 那么你应该现在就给它写注释. 对于复杂的操作, 应该在其操作开始前写上若干行注释. 对于不是一目了然的代码, 应在其行尾添加注释.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># We use a weighted dictionary search to find out where i is in</span></span><br><span class="line"><span class="comment"># the array.  We extrapolate position based on the largest num</span></span><br><span class="line"><span class="comment"># in the array and the array size and then do binary search to</span></span><br><span class="line"><span class="comment"># get the exact number.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &amp; (i-<span class="number">1</span>) == <span class="number">0</span>:        <span class="comment"># true iff i is a power of 2</span></span><br></pre></td></tr></table></figure>

<p>为了提高可读性, 注释应该至少离开代码2个空格.</p>
<p>另一方面, 绝不要描述代码. 假设阅读代码的人比你更懂Python, 他只是不知道你的代码要做什么.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BAD COMMENT: Now go through the b array and make sure whenever i occurs</span></span><br><span class="line"><span class="comment"># the next element is i+1</span></span><br></pre></td></tr></table></figure>

<h4 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h4><blockquote>
<p>Tip: 如果一个类不继承自其它类, 就显式的从object继承. 嵌套类也一样.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: <span class="keyword">class</span> <span class="title class_">SampleClass</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">         <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">class</span> <span class="title class_">OuterClass</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">         <span class="keyword">class</span> <span class="title class_">InnerClass</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">             <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">class</span> <span class="title class_">ChildClass</span>(<span class="title class_ inherited__">ParentClass</span>):</span><br><span class="line">         <span class="string">&quot;&quot;&quot;Explicitly inherits from another class already.&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">No: <span class="keyword">class</span> <span class="title class_">SampleClass</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">OuterClass</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">InnerClass</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>继承自<code>object</code>是为了使属性(properties)正常工作, 并且这样可以保护你的代码, 使其不受<a href="https://www.python.org/dev/peps/pep-3000/">PEP-3000</a> 的一个特殊的潜在不兼容性影响. 这样做也定义了一些特殊的方法, 这些方法实现了对象的默认语义, 包括<code>__new__</code>, <code>__init__</code>, <code>__delattr__</code>, <code>__getattribute__</code>, <code>__setattr__</code>, <code>__hash__</code>, <code>__repr__</code>, and <code>__str__</code> .</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><blockquote>
<p>Tip: 即使参数都是字符串, 使用%操作符或者格式化方法格式化字符串. 不过也不能一概而论, 你需要在+和%之间好好判定.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: x = a + b</span><br><span class="line">     x = <span class="string">&#x27;%s, %s!&#x27;</span> % (imperative, expletive)</span><br><span class="line">     x = <span class="string">&#x27;&#123;&#125;, &#123;&#125;!&#x27;</span>.<span class="built_in">format</span>(imperative, expletive)</span><br><span class="line">     x = <span class="string">&#x27;name: %s; score: %d&#x27;</span> % (name, n)</span><br><span class="line">     x = <span class="string">&#x27;name: &#123;&#125;; score: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name, n)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">No: x = <span class="string">&#x27;%s%s&#x27;</span> % (a, b)  <span class="comment"># use + in this case</span></span><br><span class="line">    x = <span class="string">&#x27;&#123;&#125;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(a, b)  <span class="comment"># use + in this case</span></span><br><span class="line">    x = imperative + <span class="string">&#x27;, &#x27;</span> + expletive + <span class="string">&#x27;!&#x27;</span></span><br><span class="line">    x = <span class="string">&#x27;name: &#x27;</span> + name + <span class="string">&#x27;; score: &#x27;</span> + <span class="built_in">str</span>(n)</span><br></pre></td></tr></table></figure>

<p>避免在循环中用+和+=操作符来累加字符串. 由于字符串是不可变的, 这样做会创建不必要的临时对象, 并且导致二次方而不是线性的运行时间. 作为替代方案, 你可以将每个子串加入列表, 然后在循环结束后用<code>.join</code>连接列表. (也可以将每个子串写入一个<code>cStringIO.StringIO</code>缓存中.)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">No: employee_table = <span class="string">&#x27;&lt;table&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> last_name, first_name <span class="keyword">in</span> employee_list:</span><br><span class="line">        employee_table += <span class="string">&#x27;&lt;tr&gt;&lt;td&gt;%s, %s&lt;/td&gt;&lt;/tr&gt;&#x27;</span> % (last_name, first_name)</span><br><span class="line">    employee_table += <span class="string">&#x27;&lt;/table&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在同一个文件中, 保持使用字符串引号的一致性. 使用单引号’或者双引号”之一用以引用字符串, 并在同一文件中沿用. 在字符串内可以使用另外一种引号, 以避免在字符串中使用. PyLint已经加入了这一检查.</p>
<p>为多行字符串使用三重双引号”“”而非三重单引号’‘’. 当且仅当项目中使用单引号’来引用字符串时, 才可能会使用三重’‘’为非文档字符串的多行字符串来标识引用. 文档字符串必须使用三重双引号”“”. 不过要注意, 通常用隐式行连接更清晰, 因为多行字符串与程序其他部分的缩进方式不一致.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;This is much nicer.\n&quot;</span></span><br><span class="line">           <span class="string">&quot;Do it this way.\n&quot;</span>)</span><br><span class="line">No:</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&quot;&quot;&quot;This is pretty ugly.</span></span><br><span class="line"><span class="string">  Don&#x27;t do this.</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="文件和sockets"><a href="#文件和sockets" class="headerlink" title="文件和sockets"></a>文件和sockets</h4><blockquote>
<p>Tip: 在文件和sockets结束时, 显式的关闭它.</p>
</blockquote>
<p>除文件外, sockets或其他类似文件的对象在没有必要的情况下打开, 会有许多副作用, 例如:</p>
<ol>
<li>它们可能会消耗有限的系统资源, 如文件描述符. 如果这些资源在使用后没有及时归还系统, 那么用于处理这些对象的代码会将资源消耗殆尽.</li>
<li>持有文件将会阻止对于文件的其他诸如移动、删除之类的操作.</li>
<li>仅仅是从逻辑上关闭文件和sockets, 那么它们仍然可能会被其共享的程序在无意中进行读或者写操作. 只有当它们真正被关闭后, 对于它们尝试进行读或者写操作将会抛出异常, 并使得问题快速显现出来.</li>
</ol>
<p>而且, 幻想当文件对象析构时, 文件和sockets会自动关闭, 试图将文件对象的生命周期和文件的状态绑定在一起的想法, 都是不现实的. 因为有如下原因:</p>
<ol>
<li>没有任何方法可以确保运行环境会真正的执行文件的析构. 不同的Python实现采用不同的内存管理技术, 比如延时垃圾处理机制. 延时垃圾处理机制可能会导致对象生命周期被任意无限制的延长.</li>
<li>对于文件意外的引用,会导致对于文件的持有时间超出预期(比如对于异常的跟踪, 包含有全局变量等).</li>
</ol>
<p>推荐使用<code>&quot;with&quot;</code>语句 以管理文件:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;hello.txt&quot;</span>) <span class="keyword">as</span> hello_file:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> hello_file:</span><br><span class="line">        <span class="built_in">print</span> line</span><br></pre></td></tr></table></figure>

<p>对于不支持使用<code>&quot;with&quot;</code>语句的类似文件的对象,使用 contextlib.closing():</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> contextlib.closing(urllib.urlopen(<span class="string">&quot;http://www.python.org/&quot;</span>)) <span class="keyword">as</span> front_page:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> front_page:</span><br><span class="line">        <span class="built_in">print</span> line</span><br></pre></td></tr></table></figure>

<h4 id="TODO注释"><a href="#TODO注释" class="headerlink" title="TODO注释"></a>TODO注释</h4><blockquote>
<p>Tip: 为临时代码使用TODO注释, 它是一种短期解决方案. 不算完美, 但够好了.</p>
</blockquote>
<p>TODO注释应该在所有开头处包含<code>&quot;TODO&quot;</code>字符串, 紧跟着是用括号括起来的你的名字, email地址或其它标识符. 然后是一个可选的冒号. 接着必须有一行注释, 解释要做什么. 主要目的是为了有一个统一的TODO格式, 这样添加注释的人就可以搜索到(并可以按需提供更多细节). 写了TODO注释并不保证写的人会亲自解决问题. 当你写了一个TODO, 请注上你的名字.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># TODO(kl@gmail.com): Use a &quot;*&quot; here for string repetition.</span></span><br><span class="line"><span class="comment"># TODO(Zeke) Change this to use relations.</span></span><br></pre></td></tr></table></figure>

<p>如果你的TODO是”将来做某事”的形式, 那么请确保你包含了一个指定的日期(“2009年11月解决”)或者一个特定的事件(“等到所有的客户都可以处理XML请求就移除这些代码”).</p>
<h4 id="导入格式"><a href="#导入格式" class="headerlink" title="导入格式"></a>导入格式</h4><blockquote>
<p>每个导入应该独占一行</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Yes: <span class="keyword">import</span> os</span><br><span class="line">     <span class="keyword">import</span> sys</span><br><span class="line">No:  <span class="keyword">import</span> os, sys</span><br></pre></td></tr></table></figure>

<p>导入总应该放在文件顶部, 位于模块注释和文档字符串之后, 模块全局变量和常量之前. 导入应该按照从最通用到最不通用的顺序分组:</p>
<ol>
<li>标准库导入</li>
<li>第三方库导入</li>
<li>应用程序指定导入</li>
</ol>
<p>每种分组中, 应该根据每个模块的完整包路径按字典序排序, 忽略大小写.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> foo</span><br><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> bar</span><br><span class="line"><span class="keyword">from</span> foo.bar <span class="keyword">import</span> baz</span><br><span class="line"><span class="keyword">from</span> foo.bar <span class="keyword">import</span> Quux</span><br><span class="line"><span class="keyword">from</span> Foob <span class="keyword">import</span> ar</span><br></pre></td></tr></table></figure>

<h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><blockquote>
<p>在Python中, 对于琐碎又不太重要的访问函数, 你应该直接使用公有变量来取代它们, 这样可以避免额外的函数调用开销. 当添加更多功能时, 你可以用属性(property)来保持语法的一致性.</p>
</blockquote>
<p>另一方面, 如果访问更复杂, 或者变量的访问开销很显著, 那么你应该使用像 get_foo() 和 set_foo() 这样的函数调用. 如果之前的代码行为允许通过属性(property)访问 , 那么就不要将新的访问函数与属性绑定. 这样, 任何试图通过老方法访问变量的代码就没法运行, 使用者也就会意识到复杂性发生了变化.</p>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><blockquote>
<p>Tip: module_name, package_name, ClassName, method_name, ExceptionName, function_name, GLOBAL_VAR_NAME, instance_var_name, function_parameter_name, local_var_name.</p>
</blockquote>
<p>应该避免的名称</p>
<ul>
<li>单字符名称, 除了计数器和迭代器.</li>
<li>包/模块名中的连字符(-)</li>
<li>双下划线开头并结尾的名称(Python保留, 例如<strong>init</strong>)</li>
</ul>
<p>命名约定</p>
<ul>
<li>所谓”内部(Internal)”表示仅模块内可用, 或者, 在类内是保护或私有的.</li>
<li>用单下划线(_)开头表示模块变量或函数是protected的(使用<code>from x import x</code>时不会包含).</li>
<li>用双下划线(__)开头的实例变量或方法表示类内私有.</li>
<li>将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块.</li>
<li>对类名使用大写字母开头的单词(如CapWords, 即Pascal风格), 但是模块名应该用小写加下划线的方式(如lower_with_under.py). 尽管已经有很多现存的模块使用类似于CapWords.py这样的命名, 但现在已经不鼓励这样做, 因为如果模块名碰巧和类名一致, 这会让人困扰.</li>
</ul>
<p>Python之父Guido推荐的规范</p>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Public</th>
<th align="center">Internal</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Modules</td>
<td align="center">lower_with_under</td>
<td align="center">_lower_with_under</td>
</tr>
<tr>
<td align="center">Packages</td>
<td align="center">lower_with_under</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Classes</td>
<td align="center">CapWords</td>
<td align="center">_CapWords</td>
</tr>
<tr>
<td align="center">Exceptions</td>
<td align="center">CapWords</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Functions</td>
<td align="center">lower_with_under()</td>
<td align="center">_lower_with_under()</td>
</tr>
<tr>
<td align="center">Global/Class Constants</td>
<td align="center">CAPS_WITH_UNDER</td>
<td align="center">_CAPS_WITH_UNDER</td>
</tr>
<tr>
<td align="center">Global/Class Variables</td>
<td align="center">lower_with_under</td>
<td align="center">_lower_with_under</td>
</tr>
<tr>
<td align="center">Instance Variables</td>
<td align="center">lower_with_under</td>
<td align="center">_lower_with_under (protected) or __lower_with_under (private)</td>
</tr>
<tr>
<td align="center">Method Names</td>
<td align="center">lower_with_under()</td>
<td align="center">_lower_with_under() (protected) or __lower_with_under() (private)</td>
</tr>
<tr>
<td align="center">Function/Method Parameters</td>
<td align="center">lower_with_under</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Local Variables</td>
<td align="center">lower_with_under</td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h4><blockquote>
<p>Tip: 即使是一个打算被用作脚本的文件, 也应该是可导入的. 并且简单的导入不应该导致这个脚本的主功能(main functionality)被执行, 这是一种副作用. 主功能应该放在一个main()函数中.</p>
</blockquote>
<p>在Python中, pydoc以及单元测试要求模块必须是可导入的. 你的代码应该在执行主程序前总是检查<code>if __name__ == &#39;__main__&#39;</code>, 这样当模块被导入时主程序就不会被执行.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>所有的顶级代码在模块导入时都会被执行. 要小心不要去调用函数, 创建对象, 或者执行那些不应该在使用pydoc时执行的操作.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>请务必保持代码的一致性。</p>
<p>如果你正在编辑代码, 花几分钟看一下周边代码, 然后决定风格. 如果它们在所有的算术操作符两边都使用空格, 那么你也应该这样做. 如果它们的注释都用标记包围起来, 那么你的注释也要这样.</p>
<p>制定风格指南的目的在于让代码有规可循, 这样人们就可以专注于”你在说什么”, 而不是”你在怎么说”. 我们在这里给出的是全局的规范, 但是本地的规范同样重要. 如果你加到一个文件里的代码和原有代码大相径庭, 它会让读者不知所措. 避免这种情况.</p>
]]></content>
      <categories>
        <category>内功心法</category>
        <category>编码规范</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>代码风格</tag>
        <tag>CleanCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+TravisCI: 专心写博客吧</title>
    <url>/posts/c9cf/</url>
    <content><![CDATA[<p>相信大家都有自己的博客，也都体会过那几天折腾博客的成就感。利用<code>Github Pages</code> + <code>Hexo</code>可以很容易的搭建一个属于自己的个性化博客主页。同时，你只需要关心自己文章的内容，以及基本的markdown排版即可，<code>Hexo</code>可以解析md生成对应的html，进而展示在你的博客主页。</p>
<p>发布博客的步骤不算繁琐，但是重复性较高，而且需要安装相关环境(<code>npm</code>、<code>hexo-cli</code>…)，当我们需要在不同的电脑上发布博客的时候，是不是会觉得很麻烦呢？很多小伙伴只想关心如何写文章的内容，希望写完之后，只需要<code>git push</code>一下就可以在主页上看到新发布的文章。</p>
<p>本文介绍了如何通过<code>Travis CI</code>简化发布流程，让大家可以专心的写自己的博客！</p>
<p>Let’s go~</p>
<blockquote>
<p>偷懒是创造力的源泉</p>
</blockquote>
<h1 id="事前准备"><a href="#事前准备" class="headerlink" title="事前准备"></a>事前准备</h1><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><ol>
<li>上传博客源码到github仓库。笔者这里是直接把博客源码推到Github Pages项目的<code>blog</code>分支了，这样做的好处是可以集中管理一个项目。同时把<code>*.github.io</code>项目的默认分支设置成<code>blog</code>，这样可以在项目主页上显示README。<br><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/006tNc79gy1fvbjmen5zoj30l004jmxk.jpg"></li>
<li>生成<a href="https://github.com/settings/tokens/new"><code>access token</code></a>。为了TravisCI可以读写我们的项目，这里token的权限只选择控制repo就好。<br><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/006tNc79gy1fvbk2r34mxj30l6069diu.jpg"></li>
</ol>
<h2 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis-CI"></a>Travis-CI</h2><ol>
<li>开启<a href="https://travis-ci.org/profile">TravisCI</a>，打开刚才托管的博客源码仓库同步开关（采用不同分支管理，则开启<code>*.github.io</code>项目；采用不同项目管理，则开启对应的项目）<br><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20180916205509.png"></li>
<li>设置<code>Environment Variables</code>，将上一步在Github生成的access token保存到环境变量中，便于之后在脚本中使用。同时可以设置<code>hexo deploy</code>时使用的git用户名和邮箱。<br><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20180916210526.png"></li>
</ol>
<h1 id="CI-yaml配置"><a href="#CI-yaml配置" class="headerlink" title="CI yaml配置"></a>CI yaml配置</h1><p><code>.travis.yml</code>是一个指示ci触发后如何进行构建的配置文件。</p>
<p>进入项目根目录，执行</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">cd</span> <span class="string">leosocy.github.io</span></span><br><span class="line"><span class="string">touch</span> <span class="string">.travis.yml</span></span><br></pre></td></tr></table></figure>

<p>具体配置如下（部分配置需要根据个人情况修改）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">6.14</span><span class="number">.3</span></span><br><span class="line"><span class="attr">sudo:</span> <span class="string">required</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">node_modules</span>  <span class="comment"># npm install will still run on every build and will update/install any new packages added to your package.json file.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">only:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">blog</span>  <span class="comment"># 只有blog分支的提交才会触发ci。如果是不同项目管理的博客则不需要此配置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">export</span> <span class="string">TZ=&#x27;Asia/Shanghai&#x27;</span>   <span class="comment"># 设置时区，用于提交到github pages的master分支时显示准确的commit时间</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span> <span class="string">--save</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo</span> <span class="string">--save</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-deployer-git</span> <span class="string">--save</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除缓存，重新生成部署文件</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">$&#123;GIT_USER_NAME&#125;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">$&#123;GIT_USER_EMAIL&#125;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&quot;s/GITHUB_TOKEN/$&#123;GITHUB_TOKEN&#125;/g&quot;</span> <span class="string">_config.yml</span>   <span class="comment"># 替换hexo配置文件中的deploy配置`</span></span><br></pre></td></tr></table></figure>

<p><code>_config.yml</code>中的deploy设置如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://GITHUB_TOKEN@github.com/yourname/your_github_pages.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/Leosocy/leosocy.github.io/blob/blog/.travis.yml">我的travis-ci配置</a></p>
<p>将<code>.travis.yml</code>和<code>_config.yml</code>的变更push到独立的分支或者项目中去，我们就能在travis-ci上看到对应的构建了</p>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20180916224800.png"></p>
<p>CI成功之后，刷新一下你的博客主页，就能看到刚刚写的文章喽(<em>^▽^</em>)</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>CI</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown认识与入门</title>
    <url>/posts/ceb0/</url>
    <content><![CDATA[<h1 id="一、认识Markdown"><a href="#一、认识Markdown" class="headerlink" title="一、认识Markdown"></a><hw id="1">一、认识Markdown</h2></h1><p>Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。</p>
<span id="more"></span>

<p>Markdown优点。</p>
<ul>
<li>不用关心排版，让你更注重文字。</li>
<li>语法简单，易读写。</li>
<li>纯文本，兼容所有的文本编辑器。</li>
</ul>
<h1 id="二、Markdown语法"><a href="#二、Markdown语法" class="headerlink" title="二、Markdown语法"></a>二、Markdown语法</h1><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><ul>
<li>用#表示  </li>
</ul>
<h1 id="可以表示最高6级标题，-的数量对应标题的级数"><a href="#可以表示最高6级标题，-的数量对应标题的级数" class="headerlink" title="可以表示最高6级标题，#的数量对应标题的级数"></a>可以表示最高6级标题，#的数量对应标题的级数</h1><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="2-引用"><a href="#2-引用" class="headerlink" title="2.引用"></a>2.引用</h3><p>在要引用块的句首添加&gt;符号</p>
<blockquote>
<p>这是引用  </p>
</blockquote>
<p>引用是可以嵌套的  </p>
<blockquote>
<p>这是外层</p>
<blockquote>
<p>这是内层</p>
</blockquote>
</blockquote>
<h3 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h3><h4 id="3-1无序列表"><a href="#3-1无序列表" class="headerlink" title="3.1无序列表"></a>3.1无序列表</h4><p>无序列表使用*、+或者-作为列表的标记（注意要在这些符号后面加上空格）</p>
<ul>
<li>一</li>
</ul>
<ul>
<li>二</li>
</ul>
<ul>
<li>三</li>
</ul>
<h4 id="3-2-有序列表"><a href="#3-2-有序列表" class="headerlink" title="3.2 有序列表"></a>3.2 有序列表</h4><p>有序列表使用 数字+.+空格作为列表的标记，而且数字并不决定列表的顺序</p>
<ol>
<li>一</li>
<li>二</li>
<li>三</li>
</ol>
<h4 id="3-3-无序列表中插入有序列表"><a href="#3-3-无序列表中插入有序列表" class="headerlink" title="3.3 无序列表中插入有序列表"></a>3.3 无序列表中插入有序列表</h4><ul>
<li>菜单一<ol>
<li>子菜单1</li>
<li>子菜单2</li>
</ol>
</li>
<li>菜单二</li>
</ul>
<h4 id="3-3-列表中插入其他元素"><a href="#3-3-列表中插入其他元素" class="headerlink" title="3.3 列表中插入其他元素"></a>3.3 列表中插入其他元素</h4><p>列表中有引用</p>
<ol>
<li>列表中的引用<blockquote>
<p>这是列表中的引用</p>
</blockquote>
</li>
</ol>
<p>列表中有代码块</p>
<ol>
<li><p>列表中的代码块</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;This is code inside list. &quot;</span> );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>列表中有列表</p>
<ol>
<li><p>列表1</p>
<ul>
<li>列表2</li>
</ul>
<h3 id="4-代码块"><a href="#4-代码块" class="headerlink" title="4.代码块"></a>4.代码块</h3></li>
</ol>
<p>用一个反引号`加载一行代码  </p>
<p><code>printf( &quot;%s&quot;, &quot;Use single load one line code. &quot; )</code></p>
<p>用三个反引号包含一段代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;Code line one.&quot;</span> );</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;Code line two.&quot;</span> );</span><br></pre></td></tr></table></figure>

<h3 id="5-链接"><a href="#5-链接" class="headerlink" title="5.链接"></a>5.链接</h3><h4 id="5-1图片链接"><a href="#5-1图片链接" class="headerlink" title="5.1图片链接"></a>5.1图片链接</h4><p>使用<code>![图片解释文字](图片地址)</code>加载一幅图片</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://i.loli.net/2017/07/12/5966274890d20.png" alt="图片解释"></p>
<p>改变图片的大小并居中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;url&quot;</span> <span class="attr">width</span>=<span class="string">&quot;x&quot;</span> <span class="attr">height</span>=<span class="string">&quot;y&quot;</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2网页链接"><a href="#5-2网页链接" class="headerlink" title="5.2网页链接"></a>5.2网页链接</h4><p>使用<code>[链接文字](网页地址)</code>创建一个网页链接</p>
<p><a href="https://github.com/">Github</a></p>
<h3 id="6-强调"><a href="#6-强调" class="headerlink" title="6.强调"></a>6.强调</h3><p>斜体<code>*斜体*</code></p>
<p><em>我是斜体</em></p>
<p>粗体<code>**粗体**</code></p>
<p><strong>我是粗体</strong></p>
<p>粗提+斜体<code>***粗体+斜体***</code></p>
<p><strong><em>我是粗体+斜体</em></strong>`</p>
<p>删除线<code>~~删除我~~</code></p>
<p><del>删除我</del></p>
<h3 id="7-表格"><a href="#7-表格" class="headerlink" title="7.表格"></a>7.表格</h3><p>在第二列中，冒号在左面表明左对齐，在右面表明右对齐，两边都有表明居中。默认左居中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|姓名|部门|</span><br><span class="line">|:--:|:--:|</span><br><span class="line">|张三|无线|</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">姓名</th>
<th align="center">部门</th>
</tr>
</thead>
<tbody><tr>
<td align="center">张三</td>
<td align="center">无线</td>
</tr>
</tbody></table>
<h3 id="8-Some-Tips"><a href="#8-Some-Tips" class="headerlink" title="8.Some Tips"></a>8.Some Tips</h3><h4 id="结束先前的格式状态"><a href="#结束先前的格式状态" class="headerlink" title="结束先前的格式状态"></a>结束先前的格式状态</h4><p>在改变格式时，添加一个空行。</p>
<h3 id="9-页内跳转"><a href="#9-页内跳转" class="headerlink" title="9.页内跳转"></a>9.页内跳转</h3><ol>
<li>设置跳转点 <code>[标签](#地址)</code></li>
<li>设置锚点 <code>&lt;h2 id=&quot;地址&quot;&gt;内容&lt;/h2&gt;</code></li>
</ol>
<p>e.g.</p>
<p><a href="#9.1">跳转到示例</a></p>
<h2 id="9.1">跳转到这</h2>

<blockquote>
<p>跳转点和锚点均支持Markdown的其他语法</p>
</blockquote>
<h4 id="跳转到-认识Markdown"><a href="#跳转到-认识Markdown" class="headerlink" title="跳转到 认识Markdown"></a><a href="#1">跳转到 <strong><em>认识Markdown</em></strong></a></h4>]]></content>
      <categories>
        <category>编程语言</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Pipenv——它是Python包管理的大救星</title>
    <url>/posts/34a2/</url>
    <content><![CDATA[<p><code>Pipenv</code>是Python的一个打包工具，它使用<code>pip</code>、<code>virtualenv</code>和旧式的<code>requirements.txt</code>解决了与典型工作流相关的一些常见问题。</p>
<p>除了解决一些常见问题之外，它还将开发过程合并并简化为单个命令行工具。</p>
<p>本指南将介绍Pipenv解决了哪些问题，以及如何管理与Pipenv的Python依赖关系。此外，它还将介绍如何从以前的requirements.txt转为使用Pipenv管理包。</p>
<span id="more"></span>

<h2 id="Pipenv为何而生"><a href="#Pipenv为何而生" class="headerlink" title="Pipenv为何而生"></a>Pipenv为何而生</h2><p>要理解Pipenv的好处，了解Python中打包和依赖管理的当前方法是很重要的。</p>
<p>让我们从处理第三方包的典型情况开始。然后，我们将构建部署完整Python应用程序的方法。</p>
<h3 id="使用requirements-txt进行依赖管理"><a href="#使用requirements-txt进行依赖管理" class="headerlink" title="使用requirements.txt进行依赖管理"></a>使用<code>requirements.txt</code>进行依赖管理</h3><p>假设你正在处理一个使用flask等第三方包的Python项目。您需要指定该需求，以便其他开发人员和自动化系统能够运行您的应用程序。</p>
<p>你决定在requirements.txt中包含flask的依赖</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">flask</span><br></pre></td></tr></table></figure>

<p>很好，一切都在本地运行良好，在对应用程序进行了一段时间的黑客攻击之后，您决定将其转移到生产环境中。可怕的事情开始了。。。</p>
<p>上面的requirements.txt并没有指定flask的版本。这种情况下，<code>pip install -r requirements.txt</code>将默认安装最新的版本。</p>
<p>对于这个例子，我们假设已经发布了flask的一个新版本。但是，它与开发期间使用的版本不向后兼容。</p>
<p>现在，假设您将应用程序部署到生产环境中，并执行<code>pip install -r requirements.txt</code>，pip得到了最新的、不向后兼容的flask版本，就像这样，您的应用程序在生产过程中崩溃了。</p>
<blockquote>
<p>程序员小哥内心OS：这在我本地跑的好好地，怎么一发生产就崩了呢，我***</p>
</blockquote>
<p>现在，您知道在开发过程中使用的flask版本运行良好。因此，为了修复问题，您需要在requirements.txt中更加具体一些。你指定了一个flask的版本。这也称为固定依赖项:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">flask==0.12.1</span><br></pre></td></tr></table></figure>

<p>固定flask的版本确保了<code>pip install -r requirements.txt</code>可以安装flask的精确版本。但是这就万事大吉了吗？</p>
<p>请记住，flask本身也有依赖项(pip会自动安装这些依赖项)。但是，flask本身并没有为它的依赖项指定精确的版本。例如，它允许任何版本的Werkzeug&gt;=0.14。</p>
<p>同样，为了这个例子，我们假设发布了一个新的Werkzeug版本，但是它给您的应用程序引入了一个停止显示的bug。</p>
<p>当你执行<code>pip install -r requirements.txt</code>，你将会安装<code>flask==0.12.1</code>因为你已经固定了该版本。然而，不幸的是，您将得到最新的、有bug的Werkzeug版本。同样，产品在生产过程中出现故障。</p>
<p>这里真正的问题是构建不是确定性的。我的意思是，给定相同的输入(requirements.txt文件)，pip并不总是生成相同的环境。目前，您无法轻松复制开发的环境到生产上去。</p>
<p>这个问题的典型解决方案是使用<code>pip freeze</code>。该命令允许您获得当前安装的所有第三方库的准确版本，包括自动安装的子依赖项pip。因此，您可以冻结开发中的所有内容，以确保在生产环境中拥有相同的环境。</p>
<p>执行<code>pip freeze</code>会得到固定的依赖关系</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">click==6.7</span><br><span class="line">Flask==0.12.1</span><br><span class="line">itsdangerous==0.24</span><br><span class="line">Jinja2==2.10</span><br><span class="line">MarkupSafe==1.0</span><br><span class="line">Werkzeug==0.14.1</span><br></pre></td></tr></table></figure>

<p>有了这些固定的依赖项，您可以确保安装在生产环境中的包与开发环境中的包完全匹配，这样您的产品就不会意外地损坏。不幸的是，这种“解决方案”会导致一系列全新的问题。</p>
<p>现在您已经指定了每个第三方包的确切版本，您负责使这些版本保持最新，即使它们是flask的子依赖项。如果在Werkzeug==0.14.1中发现了一个安全漏洞，包维护人员立即在Werkzeug==0.14.2中修补了这个漏洞，该怎么办?您确实需要更新到Werkzeug==0.14.2，以避免由早期未打补丁的Werkzeug版本引起的任何安全问题。</p>
<p>首先，您需要意识到您的版本有问题。然后，在有人利用安全漏洞之前，您需要在生产环境中获得新版本。所以，你必须改变requirements.txt手动指定新版本Werkzeug==0.14.2。正如您在这种情况下所看到的，保持必要更新的责任落在了您的身上。</p>
<p>事实是，只要不破坏您的代码，您实际上并不关心安装了什么版本的Werkzeug。事实上，您可能希望最新的版本能够确保您得到了bug修复、安全补丁、新特性、更多优化等等。</p>
<p>真正的问题是:“如何在不承担更新子依赖项版本的责任的情况下为Python项目提供确定性构建?”</p>
<h3 id="开发具有不同依赖关系的项目"><a href="#开发具有不同依赖关系的项目" class="headerlink" title="开发具有不同依赖关系的项目"></a>开发具有不同依赖关系的项目</h3><p>让我们稍微转换一下话题，讨论在处理多个项目时出现的另一个常见问题。假设ProjectA需要django==1.9，但是ProjectB需要django==1.10。</p>
<p>默认情况下，Python试图将所有第三方包存储在系统范围内的位置。这意味着每次在ProjectA和ProjectB之间切换时，都必须确保安装了正确的django版本。这使得在项目之间切换非常痛苦，因为您必须卸载和重新安装包来满足每个项目的需求。</p>
<p>标准的解决方案是使用具有自己的Python可执行文件和第三方包存储的<a href="https://realpython.com/python-virtual-environments-a-primer/"><code>virtual environment</code></a>。这样，ProjectA和ProjectB就可以充分分离。现在您可以轻松地在项目之间切换，因为它们不共享相同的包存储位置。PackageA可以在它自己的环境中拥有它需要的django的任何版本，而PackageB可以完全独立拥有它需要的任何版本。一个非常常用的工具是virtualenv(或Python 3中的venv)。</p>
<h3 id="依赖解析"><a href="#依赖解析" class="headerlink" title="依赖解析"></a>依赖解析</h3><p>依赖性解析是什么意思?假设你有一个requirements.txt文件看起来像这样:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">package_a</span><br><span class="line">package_b</span><br></pre></td></tr></table></figure>

<p>假设package_a有一个子依赖项package_c, package_a需要这个包的特定版本:package_c&gt;=1.0。反过来，package_b具有相同的子依赖关系，但需要package_c&lt;=2.0。</p>
<p>理想情况下，当您尝试安装package_a和package_b时，安装工具将查看package_c的需求(&gt;=1.0和&lt;=2.0)并选择满足这些需求的版本。您希望该工具能够解决依赖关系，以便您的程序最终能够工作。这就是我所说的“依赖解析”。</p>
<p>不幸的是，pip本身目前还没有真正的依赖性解决方案。pip处理上述情况的方法如下:</p>
<ol>
<li>它安装package_a并寻找满足第一个需求的package_c版本(package_c&gt;=1.0)。</li>
<li>然后，pip安装package_c的最新版本来满足这个需求。假设package_c的最新版本是3.1。</li>
</ol>
<p>这就是麻烦开始的地方。</p>
<p>如果pip选择的package_c版本不符合未来的需求(例如package_b需要package_c&lt;=2.0)，则安装将失败。</p>
<p>这个问题的“解决方案”是在requirements.txt中指定子依赖项(package_c)所需的范围。这样，pip就可以解决这个冲突，并安装一个满足这些要求的包:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">package_c&gt;=1.0,&lt;=2.0</span><br><span class="line">package_a</span><br><span class="line">package_b</span><br></pre></td></tr></table></figure>

<p>就像以前一样，您现在直接关注子依赖项(package_c)。这样做的问题是，如果package_a在您不知道的情况下更改了它们的需求，那么您指定的需求(package_c&gt;=1.0，&lt;=2.0)可能不再可以接受，并且安装可能再次失败……真正的问题是，您要再次负责满足子依赖项的需求。</p>
<p>理想情况下，您的安装工具足够智能，可以安装满足所有需求的包，而无需显式指定子依赖项版本。</p>
<h2 id="Pipenv介绍"><a href="#Pipenv介绍" class="headerlink" title="Pipenv介绍"></a>Pipenv介绍</h2><p>让我们看看Pipenv如何解决它们。</p>
<p>首先，安装Pipenv</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install pipenv</span><br></pre></td></tr></table></figure>

<p>一旦你这样做了，你就丢点pip了，因为Pipenv实际上是一个替代品。它还引入了两个新文件，Pipfile(用于替代requirements.txt)和Pipfile.lock(支持确定性构建)。</p>
<p>Pipenv在底层使用pip和virtualenv，但通过一个命令行接口简化了它们的使用。</p>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>让我们从头开始创建您出色的Python应用程序。首先，在virtual env中衍生一个shell，隔离这个app的开发:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv shell</span><br></pre></td></tr></table></figure>

<p>如果一个环境还不存在的话将创建一个虚拟环境。您可以使用参数–two/–three强制创建Python2或3环境。否则，Pipenv将使用virtualenv找到的任何默认值。</p>
<p>现在你可以安装你需要的第三方软件包flask。但是你知道你需要的是0.12.1版本，而不是最新的版本，所以请具体说明:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv install flask==0.12.1</span><br></pre></td></tr></table></figure>

<p>您应该在终端中看到如下内容:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Adding flask==0.12.1 to Pipfile&#x27;s [packages]...</span><br><span class="line">Pipfile.lock not found, creating...</span><br></pre></td></tr></table></figure>

<p>您会注意到创建了两个文件，一个<code>Pipfile</code>和<code>Pipfile.lock</code>。我们稍后会更仔细地看这些。让我们安装另一个第三方软件包numpy来处理一些数据。你不需要一个特定的版本，所以不要指定一个:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv install numpy</span><br></pre></td></tr></table></figure>

<p>你也可以从Github上安装某些依赖，例如安装<code>requests</code>库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv install -e git+https://github.com/requests/requests.git#egg=requests</span><br></pre></td></tr></table></figure>

<p>假设您还为这个出色的应用程序进行了一些单元测试，您希望使用pytest来运行它们。在生产环境中不需要pytest，因此可以指定这个依赖关系只用于开发，使用—dev参数:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv install pytest --dev</span><br></pre></td></tr></table></figure>

<p>提供——dev参数将把依赖项放在Pipfile中一个特殊的[dev-package]位置。只有在使用pipenv install指定—dev参数时，才会安装这些开发包。</p>
<p>不同的部分将仅用于开发的依赖项与用于基本代码实际工作的依赖项分开。通常，这可以通过附加的requirements文件(如dev-requirements.txt或test-requirements.txt)来完成。现在，在不同的部分中，所有内容都被合并到一个Pipfile中。</p>
<p>好了，假设您已经在本地开发环境中完成了所有工作，并且准备将其投入生产。要做到这一点，您需要锁定您的环境，以便确保在生产中拥有相同的环境:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv lock</span><br></pre></td></tr></table></figure>

<p>这将创建/更新您的Pipfile.lock，您永远不需要(也永远不打算)手动编辑。您应该始终使用生成的文件。</p>
<p>现在，在生产环境中获得了代码和Pipfile.lock，您应该安装最后成功记录的环境:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv install --ignore-pipfile</span><br></pre></td></tr></table></figure>

<p>这告诉Pipenv在安装时忽略Pipfile，而使用Pipfile.lock中的内容。根据Pipfile.lock，Pipenv将创建与运行<code>pipenv lock</code>时完全相同的环境，子依赖项等等。</p>
<p>锁文件通过获取环境中包的所有版本的快照(类似于pip freeze结果)来支持确定性构建。</p>
<p>现在，假设另一个开发人员希望对您的代码进行一些添加。在这种情况下，他们会得到代码，包括Pipfile，并使用这个命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv install --dev</span><br></pre></td></tr></table></figure>

<p>这将安装开发所需的所有依赖项，包括常规依赖项和安装期间使用<code>--dev</code>参数指定的依赖项。</p>
<p>当Pipfile中没有指定确切的版本时，install命令为依赖项(和子依赖项)提供了更新它们的版本的机会。</p>
<p>这是一个重要的注意事项，因为它解决了前面讨论的一些问题。为了演示，假设您的某个依赖项的新版本可用。因为不需要这个依赖项的特定版本，所以不需要在Pipfile中指定确切的版本。当您安装pipenv时，依赖项的新版本将安装在您的开发环境中。</p>
<p>现在，您对代码进行了更改，并运行了一些测试，以验证一切都按预期工作。(你有单元测试，对吧?)现在，和以前一样，使用<code>pipenv lock</code>锁定环境。Pipfile.lock将与依赖项的新版本一起生成。与以前一样，您可以在生产环境中使用锁文件复制这个新环境。</p>
<p>正如您从这个场景中看到的，您不再需要强制执行您并不真正需要的确切版本，以确保开发和生产环境是相同的。你也不需要时刻关注你“不关心”的子依赖关系的更新。Pipenv的这个工作流，结合您出色的测试，解决了手工执行所有依赖管理的问题。</p>
<h3 id="Pipenv的依赖性解决方法"><a href="#Pipenv的依赖性解决方法" class="headerlink" title="Pipenv的依赖性解决方法"></a>Pipenv的依赖性解决方法</h3><p>Pipenv将尝试安装满足核心依赖项所有需求的子依赖项。但是，如果存在相互冲突的依赖关系(package_a需要package_c&gt;=1.0, package_b需要package_c&lt;1.0)， Pipenv将无法创建锁文件，并将输出如下错误:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Warning: Your dependencies could not be resolved. You likely have a mismatch in your sub-dependencies.</span><br><span class="line">  You can use $ pipenv install --skip-lock to bypass this mechanism, then run $ pipenv graph to inspect the situation.</span><br><span class="line">Could not find a version that matches package_c&gt;=1.0,package_c&lt;1.0</span><br></pre></td></tr></table></figure>

<p>正如警告所说，您还可以显示一个依赖关系图来理解顶级依赖关系及其子依赖关系:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv graph</span><br></pre></td></tr></table></figure>

<p>这个命令将打印出一个树状结构，显示您的依赖项。这里有一个例子:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Flask==0.12.1</span><br><span class="line">  - click [required: &gt;=2.0, installed: 6.7]</span><br><span class="line">  - itsdangerous [required: &gt;=0.21, installed: 0.24]</span><br><span class="line">  - Jinja2 [required: &gt;=2.4, installed: 2.10]</span><br><span class="line">    - MarkupSafe [required: &gt;=0.23, installed: 1.0]</span><br><span class="line">  - Werkzeug [required: &gt;=0.7, installed: 0.14.1]</span><br><span class="line">numpy==1.14.1</span><br><span class="line">pytest==3.4.1</span><br><span class="line">  - attrs [required: &gt;=17.2.0, installed: 17.4.0]</span><br><span class="line">  - funcsigs [required: Any, installed: 1.0.2]</span><br><span class="line">  - pluggy [required: &lt;0.7,&gt;=0.5, installed: 0.6.0]</span><br><span class="line">  - py [required: &gt;=1.5.0, installed: 1.5.2]</span><br><span class="line">  - setuptools [required: Any, installed: 38.5.1]</span><br><span class="line">  - six [required: &gt;=1.10.0, installed: 1.11.0]</span><br><span class="line">requests==2.18.4</span><br><span class="line">  - certifi [required: &gt;=2017.4.17, installed: 2018.1.18]</span><br><span class="line">  - chardet [required: &gt;=3.0.2,&lt;3.1.0, installed: 3.0.4]</span><br><span class="line">  - idna [required: &gt;=2.5,&lt;2.7, installed: 2.6]</span><br><span class="line">  - urllib3 [required: &lt;1.23,&gt;=1.21.1, installed: 1.22]</span><br></pre></td></tr></table></figure>

<p>从<code>pipenv graph</code>的输出中，您可以看到我们之前安装的顶级依赖项(Flask、numpy、pytest和请求)，在下面您可以看到它们所依赖的包。</p>
<p>另外，您可以反转树来显示与需要它的父类的子依赖关系:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv graph --reverse</span><br></pre></td></tr></table></figure>

<p>当您试图找出相互冲突的子依赖关系时，此反向树可能更有用。</p>
<h3 id="Pipfile"><a href="#Pipfile" class="headerlink" title="Pipfile"></a>Pipfile</h3><p>Pipfile出现的意图是替代<code>requirements.txt</code>。Pipenv是目前使用Pipfile的参考实现。pip本身似乎很可能能够处理这些文件。此外，值得注意的是，Pipenv甚至是Python本身推荐的官方包管理工具。</p>
<p>Pipfile的语法是<a href="https://github.com/toml-lang/toml">TOML</a>，文件分为几个部分。[dev-packages]只用于开发包，[package]用于最低需求的包，[require]用于其他需求，如Python的特定版本。请看下面的示例文件:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[[source]]</span></span><br><span class="line"><span class="attr">url</span> = <span class="string">&quot;https://pypi.python.org/simple&quot;</span></span><br><span class="line"><span class="attr">verify_ssl</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;pypi&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dev-packages]</span></span><br><span class="line"><span class="attr">pytest</span> = <span class="string">&quot;*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[packages]</span></span><br><span class="line"><span class="attr">flask</span> = <span class="string">&quot;==0.12.1&quot;</span></span><br><span class="line"><span class="attr">numpy</span> = <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="attr">requests</span> = &#123;git = <span class="string">&quot;https://github.com/requests/requests.git&quot;</span>, editable = <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">[requires]</span></span><br><span class="line"><span class="attr">python_version</span> = <span class="string">&quot;3.6&quot;</span></span><br></pre></td></tr></table></figure>

<p>理想情况下，在Pipfile中不应该有任何子依赖项。我的意思是您应该只包含您实际导入和使用的包。不需要仅仅因为<code>chardet</code>是请求的子依赖项就将它保存在Pipfile中。(Pipenv会自动安装。)Pipfile应该传递包所需的顶级依赖项。</p>
<h3 id="Pipfile-lock"><a href="#Pipfile-lock" class="headerlink" title="Pipfile.lock"></a>Pipfile.lock</h3><p>该文件通过指定复制环境的确切需求来支持确定性构建。它包含包和散列的精确版本，以支持更安全的验证，pip本身现在也支持这种验证。示例文件可能如下所示。注意这个文件的语法是JSON，我用…排除了部分文件:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_meta&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;default&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;flask&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;hashes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;sha256:6c3130c8927109a08225993e4e503de4ac4f2678678ae211b33b519c622a7242&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;sha256:9dce4b6bfbb5b062181d3f7da8f727ff70c1156cbb4024351eafd426deb5fb88&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;==0.12.1&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;requests&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;editable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;git&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://github.com/requests/requests.git&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ref&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4ea09e49f7d518d365e7c6f7ff6ed9ca70d6ec2e&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;werkzeug&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;hashes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;sha256:d5da73735293558eb1651ee2fddc4d0dedcfa06538b8813a2e20011583c9e49b&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;sha256:c3fd7a7d41976d9f44db327260e263132466836cef6f91512889ed60ad26557c&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;==0.14.1&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;develop&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pytest&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;hashes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;sha256:8970e25181e15ab14ae895599a0a0e0ade7d1f1c4c8ca1072ce16f25526a184d&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;sha256:9ddcb879c8cc859d2540204b5399011f842e5e8823674bf429f70ada281b3cc6&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;==3.4.1&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>请注意为每个依赖项指定的确切版本。甚至像werkzeug这样不在Pipfile中的子依赖项也会出现在这个Pipfile.lock中。散列用于确保检索的包与在开发中检索的包相同。</p>
<p>值得再次注意的是，永远不要手工更改此文件。它是用<code>pipenv lock</code>生成的。</p>
<h3 id="Pipenv额外特性"><a href="#Pipenv额外特性" class="headerlink" title="Pipenv额外特性"></a>Pipenv额外特性</h3><p>使用以下命令在默认编辑器中打开第三方包:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv open flask</span><br></pre></td></tr></table></figure>

<p>这将在默认编辑器中打开flask包，或者您可以使用编辑器环境变量指定程序。</p>
<hr>
<p>您可以在虚拟环境中运行命令，而无需启动shell:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv run &lt;insert command here&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>现在，假设您不再需要一个包。你可以卸载它:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv uninstall numpy</span><br></pre></td></tr></table></figure>

<p>另外，假设您希望从虚拟环境中完全删除所有已安装的包:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv uninstall --all</span><br></pre></td></tr></table></figure>

<p>您可以用<code>--all-dev</code>替换<code>--dev</code>来删除所有开发包。</p>
<hr>
<p>当顶级目录中存在.env文件时，Pipenv支持自动加载环境变量。这样，当您pipenv shell打开虚拟环境时，它将从文件中加载环境变量。env文件只包含键-值对:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">SOME_ENV_CONFIG=some_value</span><br><span class="line">SOME_OTHER_ENV_CONFIG=some_other_value</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="如何从requirements-txt转为Pipfile"><a href="#如何从requirements-txt转为Pipfile" class="headerlink" title="如何从requirements.txt转为Pipfile"></a>如何从<code>requirements.txt</code>转为Pipfile</h2><p>如果您运行pipenv安装，它应该自动检测requirements.txt并将其转换为Pipfile，输出如下所示:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">requirements.txt found, instead of Pipfile! Converting…</span><br><span class="line">Warning: Your Pipfile now contains pinned versions, if your requirements.txt did.</span><br><span class="line">We recommend updating your Pipfile to specify the &quot;*&quot; version, instead.</span><br></pre></td></tr></table></figure>

<p>如果您已经在您的需求中固定了精确的版本。您可能希望将Pipfile更改为仅指定您真正需要的确切版本。这会让你从转变中获得真正的好处。例如，假设您拥有以下内容，但实际上并不需要精确的numpy版本:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[packages]</span></span><br><span class="line"><span class="attr">numpy</span> = <span class="string">&quot;==1.14.1&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果您对依赖项没有任何特定的版本需求，您可以使用通配符*告诉Pipenv任何版本都可以安装:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[packages]</span></span><br><span class="line"><span class="attr">numpy</span> = <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果您对允许任何带有*的版本感到紧张，通常可以安全地指定大于或等于您已经使用的版本，这样您仍然可以利用新版本:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[packages]</span></span><br><span class="line"><span class="attr">numpy</span> = <span class="string">&quot;&gt;=1.14.1&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<p>您还可以使用-r参数从requirement文件中安装:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv install -r requirements.txt</span><br></pre></td></tr></table></figure>

<p>如果您有<code>dev-requirements.txt</code>或类似的东西，您也可以将它们添加到Pipfile。只要添加–dev参数，它就会被放到正确的部分:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pipenv install -r dev-requirements.txt --dev</span><br></pre></td></tr></table></figure>

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://realpython.com/pipenv-guide/#dependency-resolution">Pipenv: A Guide to the New Python Packaging Tool</a></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>包管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Protobuf——更高、更快、更强</title>
    <url>/posts/5513/</url>
    <content><![CDATA[<p>Protobuf（全称Protocol Buffers）用于序列化数据结构，描述数据组织结构，支持大部分目前流行的语言。相较于XML，Protobuf使用更简单，清晰，序列化后的数据占用空间小3~10倍，解析速度快20~100倍。</p>
<span id="more"></span>

<h2 id="PB3语法"><a href="#PB3语法" class="headerlink" title="PB3语法"></a>PB3语法</h2><h3 id="定义message"><a href="#定义message" class="headerlink" title="定义message"></a>定义message</h3><h4 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h4><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> = test_message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">MessageName</span> &#123;</span><br><span class="line">    [FieldRule] FieldType FieldName = FieldNumber; <span class="comment">//Comment</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一行指定使用的是<code>proto3</code>语法。不指定则默认使用<code>proto2</code>的语法。</li>
<li><code>package</code>用于防止使用不同的proto文件时，消息或者服务冲突。</li>
</ul>
<h4 id="FieldType"><a href="#FieldType" class="headerlink" title="FieldType"></a>FieldType</h4><p>可以使用标准类型，也可以使用自定义的字段类型，包括<code>枚举</code>和<code>其他消息类型</code></p>
<h5 id="Scalar-Value-Types"><a href="#Scalar-Value-Types" class="headerlink" title="Scalar Value Types"></a>Scalar Value Types</h5><table>
<thead>
<tr>
<th align="center">.proto Type</th>
<th align="center">Notes</th>
<th align="center">Python Type</th>
<th align="center">C++Type</th>
</tr>
</thead>
<tbody><tr>
<td align="center">double</td>
<td align="center"></td>
<td align="center">float</td>
<td align="center">double</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center"></td>
<td align="center">float</td>
<td align="center">float</td>
</tr>
<tr>
<td align="center">int32</td>
<td align="center">使用变长编码。编码负数的效率很低，如果字段可能有负值，则使用<code>sint32</code>代替</td>
<td align="center">int</td>
<td align="center">int32</td>
</tr>
<tr>
<td align="center">int64</td>
<td align="center">使用变长编码。如果字段可能有负值，则使用<code>sint64</code>代替</td>
<td align="center">int</td>
<td align="center">int64</td>
</tr>
<tr>
<td align="center">uint32</td>
<td align="center">使用变长编码</td>
<td align="center">int/long</td>
<td align="center">uint32</td>
</tr>
<tr>
<td align="center">uint64</td>
<td align="center">使用变长编码</td>
<td align="center">int/long</td>
<td align="center">uint64</td>
</tr>
<tr>
<td align="center">sint32</td>
<td align="center">使用变长编码，比<code>int32</code>更有效的编码负数</td>
<td align="center">int</td>
<td align="center">int32</td>
</tr>
<tr>
<td align="center">sint64</td>
<td align="center">使用变长编码，比<code>int64</code>更有效的编码负数</td>
<td align="center">int/long</td>
<td align="center">int64</td>
</tr>
<tr>
<td align="center">fixed32</td>
<td align="center">总是4字节。如果值通常大于pow(2, 28)，则比<code>uint32</code>更有效</td>
<td align="center">int</td>
<td align="center">uint32</td>
</tr>
<tr>
<td align="center">fixed64</td>
<td align="center">总是8字节。如果值通常大于pow(2, 58)，则比<code>uint64</code>更有效</td>
<td align="center">int/long</td>
<td align="center">uint64</td>
</tr>
<tr>
<td align="center">sfixed32</td>
<td align="center">总是使用4字节</td>
<td align="center">int</td>
<td align="center">int32</td>
</tr>
<tr>
<td align="center">sfixed64</td>
<td align="center">总是使用8字节</td>
<td align="center">int/long</td>
<td align="center">int64</td>
</tr>
<tr>
<td align="center">bool</td>
<td align="center"></td>
<td align="center">bool</td>
<td align="center">bool</td>
</tr>
<tr>
<td align="center">string</td>
<td align="center">字符串必须始终包含UTF-8编码或7位ASCII文本</td>
<td align="center">str/unicode</td>
<td align="center">string</td>
</tr>
<tr>
<td align="center">bytes</td>
<td align="center">可以包含任意字节序列</td>
<td align="center">str</td>
<td align="center">BytesString</td>
</tr>
</tbody></table>
<h5 id="Enumerations"><a href="#Enumerations" class="headerlink" title="Enumerations"></a>Enumerations</h5><p>举例</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">enum </span><span class="title class_">Corpus</span> &#123;</span><br><span class="line">    UNIVERSAL = <span class="number">0</span>;</span><br><span class="line">    WEB = <span class="number">1</span>;</span><br><span class="line">    IMAGES = <span class="number">2</span>;</span><br><span class="line">    LOCAL = <span class="number">3</span>;</span><br><span class="line">    NEWS = <span class="number">4</span>;</span><br><span class="line">    PRODUCTS = <span class="number">5</span>;</span><br><span class="line">    VIDEO = <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Corpus corpus = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，枚举的第一个值<strong>必须是0</strong>。</p>
<p>如果想通过为不同的enum常量分配相同的值来定义别名，需要在枚举中设置<code>option allow_alias = true;</code></p>
<p>e.g.</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum </span><span class="title class_">EnumAllowingAlias</span> &#123;</span><br><span class="line">  <span class="keyword">option</span> allow_alias = <span class="literal">true</span>;</span><br><span class="line">  UNKNOWN = <span class="number">0</span>;</span><br><span class="line">  STARTED = <span class="number">1</span>;</span><br><span class="line">  RUNNING = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Field-Numbers"><a href="#Field-Numbers" class="headerlink" title="Field Numbers"></a>Field Numbers</h4><p>消息定义中的每个字段都有唯一的编号。其中，1~15编码时占用1字节，16~2047占用2字节，以此类推，Field Number范围为1~pow(2, 29)-1。不用使用protobuf的<code>系统保留编号（19000~19999）</code>以及消息中定义的<code>保留编号</code></p>
<h4 id="Field-Rules"><a href="#Field-Rules" class="headerlink" title="Field Rules"></a>Field Rules</h4><ul>
<li>singular:一个格式良好的消息可以有这个字段的零或一个(但不多于一个)。</li>
<li>repeated:此字段可以在格式良好的消息中重复任意次数(包括零次)。重复值的顺序将被保留。</li>
</ul>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>和C/C++注释的方法相同，使用<code>//</code>或者<code>/*...*/</code>注释</p>
<h4 id="Reserved-Fields"><a href="#Reserved-Fields" class="headerlink" title="Reserved Fields"></a>Reserved Fields</h4><p>如果一个字段被删除或注释掉，未来的用户可以在更新类型时重用字段号。如果以后加载相同.proto的旧版本，则会导致严重的问题(包括数据损坏、隐私bug等)。确保不会发生这种情况的一种方法是指定已删除字段的字段号(和/或名称，这也可能导致JSON序列化问题)<code>reserved</code>。如果将来的用户试图使用这些字段标识符，protobuf编译器将会报错。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Foo</span> &#123;</span><br><span class="line">    reserved <span class="number">5</span>, <span class="number">7</span>;</span><br><span class="line">    reserved <span class="string">&quot;type&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，不能在同一个保留语句中混合字段名和字段号。e.g.<code>reserved 5, &quot;type&quot;</code></p>
<h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>可以通过导入其他.proto文件使用定义。要导入另一个.proto的定义，请在文件顶部添加一条import语句:</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;myproject/other_protos.proto&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><code>import public</code>可以将所有导入转发到对应的proto文件中，这个特性可以用于proto文件的迁移。</p>
<h4 id="嵌套定义"><a href="#嵌套定义" class="headerlink" title="嵌套定义"></a>嵌套定义</h4><p>类似于C/C++中的结构体，proto也支持嵌套定义message</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchResponse</span> &#123;</span><br><span class="line">  <span class="keyword">message </span><span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="type">string</span> url = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> title = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">repeated</span> Result results = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想在另一个message中使用Result，需要指定子message的完整路径</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SomeOtherMessage</span> &#123;</span><br><span class="line">    SearchResponse.Result result = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何更新正在使用的message"><a href="#如何更新正在使用的message" class="headerlink" title="如何更新正在使用的message"></a>如何更新正在使用的message</h4><p>如果需要修改已经在使用的message，例如增加额外的字段，需要注意一下几点才不会破坏现有的代码：</p>
<ul>
<li>不要更改任何现有字段的字段编号。</li>
<li>如果您添加了新的字段，那么使用您的“旧”消息格式序列化的任何消息仍然可以通过您的新生成的代码进行解析。您应该记住这些元素的默认值，以便新代码可以与旧代码生成的消息进行适当的交互。类似地，新代码创建的消息可以通过旧代码进行解析:旧二进制文件在解析时忽略新字段。</li>
<li>字段可以被删除，只要在更新的消息类型中不再使用字段编号。您可能希望重命名该字段，可能添加前缀“OBSOLETE_”，或者保留字段号，以便.proto的未来用户不会意外地重用该数字。</li>
<li>int32、uint32、int64、uint64和bool都是兼容的——这意味着您可以在不破坏向前或向后兼容性的情况下将字段从这些类型之一更改为另一个类型。如果从不适合相应类型的连接中解析一个数字，您将得到与在c++中将该数字转换为该类型相同的效果(例如，如果一个64位的数字被读为int32，那么它将被截断为32位)。</li>
<li>sint32和sint64相互兼容，但与其他整数类型不兼容。</li>
<li>字符串和字节是兼容的，只要字节是有效的UTF-8。</li>
<li>如果字节包含消息的编码版本，则嵌入的消息与字节兼容。</li>
<li>fixed32与sfixed32兼容，sfixed64与sfixed64兼容。</li>
</ul>
<h4 id="Unknown-Field"><a href="#Unknown-Field" class="headerlink" title="Unknown Field"></a>Unknown Field</h4><p>Unknown Field表示解析器无法识别的字段。例如，当一个旧的二进制文件解析由一个新二进制文件发送的带有新字段的数据时，这些新字段就成为旧二进制文件中的未知字段。</p>
<p>Proto3实现可以成功地解析带有未知字段的消息，但是，实现可能支持也可能不支持保存这些未知字段。您不应该依赖于被保存或删除的未知字段。对于大多数protobuf实现，在proto3中无法通过相应的proto运行时访问未知字段，并且在反序列化时被删除和遗忘。</p>
<h4 id="Oneof"><a href="#Oneof" class="headerlink" title="Oneof"></a>Oneof</h4><p>Oneof类似于C中的union。如果您有一个包含多个字段的消息，并且最多同时设置一个字段，那么您可以使用oneof特性强制执行此行为并保存内存。</p>
<p>除了共享内存中的所有字段外，其中一个字段类似常规字段，最多可以同时设置一个字段。设置oneof的任何成员将自动清除所有其他成员。您可以使用一个特殊的case()或哪个of()方法，根据您所选择的语言，检查其中一个值的设置(如果有的话)。</p>
<h5 id="使用Oneof"><a href="#使用Oneof" class="headerlink" title="使用Oneof"></a>使用Oneof</h5><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SampleMessage</span> &#123;</span><br><span class="line">  <span class="keyword">oneof</span> test_oneof &#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">4</span>;</span><br><span class="line">    SubMessage sub_message = <span class="number">9</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>oneof中可以添加任何类型的字段，但不能使用repeated。</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>设置oneof字段的一个成员将自动清除该字段所有其他成员。因此，如果设置了几个成员的值，那么只有最后一个成员具有值。</li>
<li>如果解析器在连接中遇到同一成员的多个成员，则在解析消息中只使用最后一个成员。</li>
<li>oneof不能被<code>repeated</code>修饰</li>
</ul>
<h4 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h4><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">map&lt;key_type, value_type&gt; map_field = N;</span><br></pre></td></tr></table></figure>

<p><code>key_type</code>可以是任何<code>integral</code>或<code>string</code>(因此，除了浮点类型和字节之外的任何标量类型)。注意，enum不是一个有效的<code>key_type</code>。<code>value_type</code>可以是除其<code>map</code>之外的任何类型。</p>
<h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ul>
<li>map字段不能是<code>repeated</code></li>
<li>在为.proto生成文本格式时，映射是按键排序的。数字键按数字排序。</li>
<li>当编码时，如果有重复的映射键，则使用最后一个键。当解码时，如果有重复的键，解析可能失败。</li>
<li>如果只提供了map的key，没有提供value，那么value_type的默认值将会被序列化。</li>
</ul>
<h4 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h4><p>用于防止消息类型冲突。使用举例</p>
<p>bar.proto</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> foo.bar;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">Open</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;bar.proto&quot;</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Foo</span> &#123;</span><br><span class="line">  foo.bar.Open open = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包说明符影响生成代码的方式取决于您选择的语言:</p>
<ul>
<li>在C++中，生成的class在C++的namespace中。例如<code>Open</code>会在foo::bar明明空间下。</li>
<li>在Java中，package被用作Java包，除非在proto文件中显示的定义了<code>option java_package</code></li>
<li>在Python中，包指令被忽略，因为Python模块是根据它们在文件系统中的位置来组织的。</li>
<li>在Go中，package被用作Go的包名，除非在proto文件中显示的定义了<code>option go_package</code></li>
</ul>
<h3 id="定义Services"><a href="#定义Services" class="headerlink" title="定义Services"></a>定义Services</h3><p>如果您想在RPC(Remote Procedure Call)系统中使用您的消息类型，您可以在.proto文件中定义一个RPC服务接口，protobuf编译器将用您选择的语言生成service interface和stubs。因此，例如，如果您想用获取<code>SearchRequest</code>并返回<code>SearchResponse</code>的方法定义一个RPC服务，您可以在.proto文件中定义它，如下所示:</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">SearchService</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> Search(SearchReq) <span class="keyword">returns</span> (SearchRes)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与protobuf一起使用的最直接的RPC系统是gRPC:在谷歌开发的与语言和平台无关的开放源码RPC系统。gRPC在协议缓冲区中工作得特别好，允许您使用特殊的protobuf编译器插件直接从.proto文件生成相关的RPC代码。</p>
<p>当然，也可以使用其他的RPC框架（rpcx、go std rpc等等）</p>
<h3 id="JSON-Mapping"><a href="#JSON-Mapping" class="headerlink" title="JSON Mapping"></a>JSON Mapping</h3><p>如果一个值在json编码的数据中丢失，或者它的值为<code>null</code>，那么在解析到protobuf时，它将被解释为适当的**<em>默认值**</em>。如果一个字段在protobuf中具有默认值，则默认情况下将在json编码的数据中省略该字段以节省空间。</p>
<p><a href="https://developers.google.com/protocol-buffers/docs/proto3#JSON%20Mapping">具体映射关系</a></p>
<h3 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h3><p>一些选项是文件级选项，这意味着它们应该在顶级范围内编写，而不是在任何消息、枚举或服务定义中。有些选项是消息级别的选项，这意味着它们应该写在消息定义中。有些选项是字段级选项，这意味着它们应该写在字段定义中。选项也可以写在枚举类型、枚举值、服务类型和服务方法上;但是，目前没有任何有用的选项。</p>
<ul>
<li><code>java_package</code> (file选项):您希望为生成的Java类使用的包。如果.proto文件中没有给出明确的java_package选项，那么默认情况下将使用proto包(使用.proto文件中的“package”关键字指定)。但是，proto包通常不会成为好的Java包，因为预计proto包不会以反向域名开始。如果不生成Java代码，则此选项无效。</li>
<li><code>optimize_for</code> (file选项):可以设置为SPEED、CODE_SIZE或LITE_RUNTIME。这将以以下方式影响c++和Java代码生成器(可能还有第三方生成器):<ul>
<li><code>SPEED</code>(默认):protobuf编译器将生成用于序列化、解析和执行消息类型的其他常见操作的代码。这段代码是高度优化的。</li>
<li><code>CODE_SIZE</code>:protobuf编译器将生成最小的类，并将依赖于共享的、基于反射的代码来实现序列化、解析和各种其他操作。因此生成的代码会比速度小得多，但是操作会更慢。类仍然会实现与在SPEED模式下完全相同的公共API。在包含大量.proto文件的应用程序中，这种模式最有用，而且不需要所有文件都非常快。</li>
<li><code>LITE_RUNTIME</code>:protobuf编译器将生成仅依赖于“lite”运行时库(libprotobuf-lite而不是libprotobuf)的类。lite运行时比完整的库要小得多(大约一个数量级)，但是忽略了某些特性，比如描述符和反射。这对于在移动电话等受限平台上运行的应用程序尤其有用。编译器仍然会生成所有方法的快速实现，就像在SPEED模式中那样。生成的类只会在每种语言中实现MessageLite接口，它只提供完整消息接口方法的一个子集。</li>
</ul>
</li>
<li><code>deprecated</code>:如果设置为true，表明该字段已被弃用，新代码不应使用该字段。在大多数语言中，这没有实际效果。在Java中，这成为一个@Deprecated注释。将来，其他特定于语言的代码生成器可能会在字段的访问器上生成弃用注释，这反过来会导致编译试图使用该字段的代码时发出警告。如果任何人都不使用字段，并且希望防止新用户使用该字段，请考虑使用<code>reserved</code>。</li>
</ul>
<h3 id="Generating-Classes"><a href="#Generating-Classes" class="headerlink" title="Generating Classes"></a>Generating Classes</h3><p>要生成Java、Python、c++、Go、Ruby、Objective-C或C#代码，您需要使用.proto文件中定义的消息类型，您需要在.proto文件上运行protobuf编译器protoc。如果您还没有安装编译器，请<a href="https://developers.google.com/protocol-buffers/docs/downloads">下载这个包</a>并遵循README中的说明。对于Go，您还需要为编译器安装一个特殊的代码生成器插件:您可以在GitHub上的<a href="https://github.com/golang/protobuf/">golang/protobuf</a>存储库中找到这个和安装说明。</p>
<p>编译器调用如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR --go_out=DST_DIR --ruby_out=DST_DIR --objc_out=DST_DIR --csharp_out=DST_DIR path/to/file.proto</span><br></pre></td></tr></table></figure>

<p>或者可以安装python gPRC tools</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install grpcio-tools</span><br><span class="line">python -m grpc_tools.protoc -I../../protos --python_out=. --grpc_python_out=. ../../protos/helloworld.proto</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>-I</code>和<code>--proto_path</code>相同，表示proto文件的搜索路径</li>
<li><code>--python_out</code>表示<code>*_pb2.py</code>生成的路径，该文件包含自动生成的<code>request</code>和<code>response</code>类</li>
<li><code>--grpc_python_out</code>表示<code>*_pb2_grpc.py</code>生成的路径，该文件包含自动生成的<code>client</code>和<code>class</code>类</li>
</ul>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>Protobuf</tag>
        <tag>序列化</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>epoll深入学习</title>
    <url>/posts/6e3c/</url>
    <content><![CDATA[<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20190319010209.png"></p>
<blockquote>
<p>图片转自<a href="https://blog.csdn.net/dog250/article/details/80837278">这里</a>**</p>
</blockquote>
<p>以前就一直听说事件模型中，epoll比select的效率高出一个量级，epoll的一些优点网上也有很多的文章阐述解释。但是至于为什么epoll如此高效？内核是怎么实现的？我并没有深入研究，所以为了更加深入的了解epoll，近期一直在研究epoll的内核源码（头一次读内核源码还是有些吃力）。大致弄懂了实现原理后才发现，网上的一些解释有的并不是很准确。本篇文章概括了epoll的实现机制，并引出epoll中的惊群问题以及一些解决方法。</p>
<span id="more"></span>

<h2 id="Linux-epoll实现机制"><a href="#Linux-epoll实现机制" class="headerlink" title="Linux epoll实现机制"></a>Linux epoll实现机制</h2><p>对于具体实现分析网上已经有很多文章阐述了，我就不再这里赘述。这里贴一篇<a href="https://blog.csdn.net/dog250/article/details/80837278">文章</a>，我觉得说的很清楚并且是按照源码分析的。</p>
<p>简单来说epoll的实现主要有以下几个逻辑</p>
<ol>
<li><code>epoll_create</code>: 创建epollevent结构体并初始化相关数据结构。创建fd并绑定到epoll对象上。</li>
<li><code>epoll_ctl</code>: <strong>从用户空间拷贝</strong>event到内核空间，创建<code>epitem</code>并初始化，将要监听的fd绑定到epitem</li>
<li>通过监听fd的poll回调，设置等待队列的entry调用函数为<code>ep_poll_callback</code>，并将entry插入到监听fd的“睡眠队列”上。</li>
<li><code>epoll_ctl</code>的最后将epitem插入到第一步创建的epollevent的红黑树中。</li>
<li><code>epoll_wait</code>: 如果ep的就绪链表为空，根据当前进程初始化一个等待entry并插入到ep的等待队列中。设置当前进程为<code>TASK_INTERRUPTIBLE</code>即可被中断唤醒，然后进入”睡眠”状态，让出CPU。</li>
<li>当监听的fd有对应事件发生，则唤醒相关文件句柄睡眠队列的entry，并调用其回调，即<code>ep_poll_callback</code></li>
<li>将发生事件的epitem加入到ep的“就绪链表”中，唤醒阻塞在epoll_wait系统调用的task去处理。</li>
<li><code>epoll_wait</code>被调度继续执行，判断就绪链表中有就绪的item，会调用<code>ep_send_events</code>向用户态上报事件，即那些epoll_wait返回后能获取的事件。</li>
<li><code>ep_send_events</code>会调用传入的<code>ep_send_events_proc</code>函数，真正执行将就绪事件从内核空间拷贝到用户空间的操作。</li>
<li>拷贝后会判断对应事件是<code>ET</code>还是<code>LT</code>模式，如果是LT则无论如何都会将epi重新加回到“就绪链表”，等待下次<code>epoll_wait</code>重新再调用监听fd的poll以确认是否仍然有未处理的事件。</li>
<li><code>ep_send_events_proc</code>返回后，在<code>ep_send_events</code>中会判断，如果“就绪链表”上仍有未处理的epi，且有进程阻塞在epoll句柄的睡眠队列，则唤醒它！(<strong>这就是LT惊群的根源</strong>)，详情可见<a href="https://code.woboq.org/linux/linux/fs/eventpoll.c.html#733">源码此处</a>。</li>
</ol>
<h2 id="LT，ET以及惊群问题"><a href="#LT，ET以及惊群问题" class="headerlink" title="LT，ET以及惊群问题"></a>LT，ET以及惊群问题</h2><p>上一节我们提到了LT（水平触发）和ET（边缘触发），简单解释下就是：</p>
<ol>
<li><code>LT水平触发</code>：如果监听的事件发生了，不管一次性发生了几个，只要仍然有未处理的事件，epoll_wait就会<strong>一直返回</strong>给你。</li>
<li><code>ET</code>边沿触发：如果监听的事件发生了，不管一次性发生了几个，epoll_wait只会<strong>返回一次</strong>，除非下一个事件到来，否则epoll_wait将不会阻塞。</li>
</ol>
<h3 id="惊群模式有什么危害"><a href="#惊群模式有什么危害" class="headerlink" title="惊群模式有什么危害"></a>惊群模式有什么危害</h3><ol>
<li>不必要的内存拷贝，将事件从内核空间拷贝到用户空间。</li>
<li>增加CPU负载，唤醒进程后accept返回EAGAIN。</li>
</ol>
<h3 id="LT模式惊群效应示例"><a href="#LT模式惊群效应示例" class="headerlink" title="LT模式惊群效应示例"></a>LT模式惊群效应示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">set_socket_nonblock(listen_fd);</span><br><span class="line"><span class="type">int</span> epfd = epoll_create(<span class="number">1</span>);</span><br><span class="line">event.data.fd = listen_fd;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, listen_fd, &amp;event);</span><br><span class="line"><span class="keyword">while</span> (keep_running) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> nfds = epoll_wait(epfd, rd_events, <span class="number">10</span>, timeout_ms);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rd_events[i].events &amp; EPOLLIN)</span><br><span class="line">            &amp;&amp; (rd_events[i].data.fd == listen_fd)) &#123;</span><br><span class="line">            <span class="comment">// 这里如果有多个进程共享同一个epfd并调用epoll_wait，那么它们也将被唤醒！</span></span><br><span class="line">            <span class="comment">// 1. 如果accept队列中有n个请求，则仅有n个进程能成功，其他将全部返回EAGAIN</span></span><br><span class="line">            <span class="comment">// 2. 如果并发连接进一步增大，虽然返回EAGAIN的比例会降低，但这些进程也并不一定取到epoll_wait返回的当下的那个预期的请求</span></span><br><span class="line">            <span class="type">int</span> conn_fd = accept(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;addrlen);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看一个场景举例。假设LT模式下有4个进程共享同一个epoll fd，此时来了一个请求client进入到accept队列，进程唤醒过程如下：</p>
<ol>
<li>进程A的epoll_wait首先被ep_poll_callback唤醒，内核拷贝event到用户空间，然后将epi重新加回就绪链表，内核发现就绪链表上仍有就绪的epi，则继续唤醒进程B。</li>
<li>进程B在处理<code>ep_scan_ready_list</code>时发现依然满足上述条件，于是继续唤醒进程C。</li>
<li>上面1、2两个过程会一直持续到某个进程完成accept，此时下一个被唤醒的进程在<code>ep_scan_ready_list</code>中的<code>ep_item_poll</code>调用中将得不到任何时间，也就不会再将epi将会就绪链表了。</li>
<li>LT水平触发就此结束。</li>
</ol>
<h3 id="ET模式下面临的新问题"><a href="#ET模式下面临的新问题" class="headerlink" title="ET模式下面临的新问题"></a>ET模式下面临的新问题</h3><p>上一节我们解释了为什么LT模式下会造成惊群问题，究其原因就是内核重新将epi加回到了就绪链表。ET模式下不会将已经上报的事件epi重新加回就绪链表，所以也就不会有惊群的问题。那是不是我们将事件设置成ET模式就万事大吉了呢？我们来接着看</p>
<p>ep_poll_callback所做的事情仅仅是将该epi自身加入到epoll句柄的“就绪链表”，同时唤醒在epoll句柄睡眠队列上的task，所以这里并不对事件的细节进行计数，比如说，如果ep_poll_callback在将一个epi加入“就绪链表”之前发现它已经在“就绪链表”了，那么就不会再次添加，因此可以说，一个epi可能pending了多个事件。</p>
<p>这个在LT模式下没有任何问题，因为获取事件的epi总是会被重新添加回“就绪链表”，那么如果还有事件，在下次epoll_wait的时候总会取到。然而对于ET模式，仅仅将epi从“就绪链表”删除并将事件本身上报后就返回了，因此如果该epi里还有事件，则<strong>只能等待再次发生事件</strong>，进而调用ep_poll_callback时将该epi加入“就绪队列”。</p>
<p>所以当使用ET模式时，epoll_wait的调用进程必须自己在获取到事件后将其处理干净才可再次调用epoll_wait，否则epoll_wait不会返回，而是必须等到下次产生事件的时候方可返回。依然以accept为例，必须这样做：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">set_socket_nonblock(listen_fd);</span><br><span class="line"><span class="type">int</span> epfd = epoll_create(<span class="number">1</span>);</span><br><span class="line">event.data.fd = listen_fd;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, listen_fd, &amp;event);</span><br><span class="line"><span class="keyword">while</span> (keep_running) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> nfds = epoll_wait(epfd, rd_events, <span class="number">10</span>, timeout_ms);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((rd_events[i].events &amp; EPOLLIN)</span><br><span class="line">            &amp;&amp; (rd_events[i].data.fd == listen_fd)) &#123;</span><br><span class="line">            <span class="type">int</span> conn_fd;</span><br><span class="line">            <span class="keyword">while</span> ((conn_fd = accept(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;addrlen) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="来点Demo"><a href="#来点Demo" class="headerlink" title="来点Demo"></a>来点Demo</h2><p>下面我们来几个Demo以及测试来巩固一下上面提到的理论。</p>
<p>具体<a href="https://github.com/Leosocy/epoll-example">源码</a>可以见我的github，这里就不贴具体代码了，只根据不同配置给出测试的结果及结论。其中测试socket链接使用的是<a href="https://www.cnblogs.com/zhunl/articles/7543318.html">webbench</a>工具。</p>
<p>测试参数统一配置为<code>webbench -c 10 -t 5 http://localhost:6250/</code>。这里我们只测试了socket链接，然后直接close了，所以看bench的结果好像不太准确，这里我们通过统计log来看socket连接成功数以及进程惊群数。</p>
<ul>
<li>accept数：<code>cat log | grep accept | wc -l</code></li>
<li>惊群次数：<code>cat log | grep thunder | wc -l</code></li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">解释</th>
<th align="center">结果统计</th>
<th align="center">结果说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>./server --mode 0 --port 6250 &gt; log</code></td>
<td align="center">LT模式惊群</td>
<td align="center">accept数：95139  惊群次数：733</td>
<td align="center">可以发现进程被”惊群“效应唤起了很多次</td>
</tr>
<tr>
<td align="center"><code>./server --mode 0 --port 6250 --et &gt; log</code></td>
<td align="center">ET模式丢失事件</td>
<td align="center">accept数：37159  惊群次数：0</td>
<td align="center">可以发现虽然没有发生”惊群“现象，但是socket连接事件丢失现象也很严重</td>
</tr>
<tr>
<td align="center"><code>./server --mode 0 --port 6250 --et --sleep 1 &gt; log</code></td>
<td align="center">ET模式在epoll_wait和accept之间增加sleep操作，这样可以在调用accept之前积累更多的未处理事件</td>
<td align="center">accept数：17  惊群次数：0</td>
<td align="center">可以发现只有十几个连接建立成功了，事件丢失的相当严重</td>
</tr>
<tr>
<td align="center"><code>./server --mode 0 --port 6250 --et --loop-accept &gt; log</code></td>
<td align="center">ET模式循环accept</td>
<td align="center">accept数：96120  惊群次数：0</td>
<td align="center">可以发事件丢失现象已经解决</td>
</tr>
</tbody></table>
<h2 id="3-9内核中的socket-reuse-port"><a href="#3-9内核中的socket-reuse-port" class="headerlink" title="3.9内核中的socket reuse port"></a>3.9内核中的socket reuse port</h2><p>上面一节总结了Linux下基于epoll事件的网络变成”惊群“现象。曾经，为了发挥多核的优势，可以hold住更高的并发连接，出现了两种常见的网络编程模型</p>
<ol>
<li>单进程创建socket，并进行listen和accept，接收到连接后创建进程和线程处理连接</li>
<li>单进程创建socket，并进行listen，预先创建好多个工作进程或线程accept()在同一个服务器套接字</li>
</ol>
<p>但是以上两种模型均存在以下问题：</p>
<ol>
<li>单一listener工作线程在高速的连接接入处理时会成为瓶颈</li>
<li>很难做到CPU之间的负载均衡</li>
<li>随着核数的扩展，性能并没有随着提升</li>
</ol>
<p>于是为了解决上面的问题，Linux Kernel在3.9引入了<code>SO_REUSEPORT</code>特性，主要提供了以下功能：</p>
<ol>
<li>允许多个套接字 bind()/listen() 同一个TCP/UDP端口，这样每个进程都拥有了自己的服务器套接字</li>
<li>内核层面实现负载均衡</li>
</ol>
<p>在reuseport机制下，惊群问题就不攻自破了。因为监听同一个ip:port的多个socket本身在socket层就是相互隔离的，在它们之间的事件分发是内核于TCP/IP协议栈完成的，所以不会再有惊群发生。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li>服务器内核大于3.9，支持<code>SO_REUSEPORT</code>：选择LT模式，不会有惊群效应，代码逻辑简单</li>
<li>服务器内核小于3.9，不支持<code>SO_REUSEPORT</code><ul>
<li>并发连接数较小，CPU负载不高：选择LT模式，代码逻辑简单，不会遗漏事件</li>
<li>并发连接数较大，CPU负载较高：选择ET模式，提升epoll效率</li>
</ul>
</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://blog.csdn.net/dog250/article/details/80837278">https://blog.csdn.net/dog250/article/details/80837278</a></li>
<li><a href="https://blog.csdn.net/dog250/article/details/50528373">https://blog.csdn.net/dog250/article/details/50528373</a></li>
<li><a href="https://www.cnblogs.com/Anker/p/7076537.html">https://www.cnblogs.com/Anker/p/7076537.html</a></li>
</ul>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>操作系统</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>epoll</tag>
        <tag>并发连接</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker容器的日志是如何存储的</title>
    <url>/posts/9e84/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>基础知识</category>
        <category>操作系统</category>
        <category>云原生</category>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转树莓派 —— Getting Started</title>
    <url>/posts/667d/</url>
    <content><![CDATA[<h2 id="烧录系统镜像"><a href="#烧录系统镜像" class="headerlink" title="烧录系统镜像"></a>烧录系统镜像</h2><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>由于笔者用的是4B 8G版，所以镜像选择arm64（2021-05-07-raspios-buster-arm64.img）。</p>
<p>官网下载速度太慢，所以我们选择了<a href="https://mirrors.tuna.tsinghua.edu.cn/raspberry-pi-os-images/raspios_arm64/images/raspios_arm64-2021-05-28/">清华源</a>。</p>
<h3 id="使用命令行烧录"><a href="#使用命令行烧录" class="headerlink" title="使用命令行烧录"></a>使用命令行烧录</h3><p>在MacOS上烧录镜像有两种方式</p>
<ol>
<li>使用Raspberry Pi Imager，优点是使用简单</li>
<li>命令行模式，使用<code>dd</code>命令</li>
</ol>
<p>作为爱折腾的程序员，当然是选择命令行模式了，还可以顺便研究下启动镜像的原理</p>
<ol>
<li><code>diskutil list</code>找到SD Card所在磁盘号 N</li>
<li><code>diskutil unmountDisk /dev/diskN</code>，只有当成功卸载后，才可以使用dd将镜像文件写入SD Card，否则会报Resource busy错误</li>
<li><code>sudo dd bs=1m if=/Users/leosocy/Downloads/2021-05-07-raspios-buster-arm64.img of=/dev/rdiskN; sync </code></li>
</ol>
<blockquote>
<p>将上面的N替换为SD Card对应的序号</p>
</blockquote>
<p>稍等几分钟之后，镜像烧录完成，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">3564+0 records in</span><br><span class="line">3564+0 records out</span><br><span class="line">3737124864 bytes transferred in 359.440753 secs (10397054 bytes/sec)</span><br><span class="line"></span><br><span class="line">➜ diskutil list</span><br><span class="line">/dev/disk2 (external, physical):</span><br><span class="line"><span class="meta prompt_">   #</span><span class="language-bash">:                       TYPE NAME                    SIZE       IDENTIFIER</span></span><br><span class="line">   0:     FDisk_partition_scheme                        *248.4 GB   disk2</span><br><span class="line">   1:             Windows_FAT_32 ⁨boot⁩                    268.4 MB   disk2s1</span><br><span class="line">   2:                      Linux ⁨⁩                        3.5 GB     disk2s2</span><br><span class="line">                    (free space)                         244.7 GB   -</span><br></pre></td></tr></table></figure>

<h3 id="几个小疑问"><a href="#几个小疑问" class="headerlink" title="几个小疑问"></a>几个小疑问</h3><h4 id="为什么dd成功之后，SD-Card自动就有了几个分区？"><a href="#为什么dd成功之后，SD-Card自动就有了几个分区？" class="headerlink" title="为什么dd成功之后，SD Card自动就有了几个分区？"></a>为什么dd成功之后，SD Card自动就有了几个分区？</h4><h4 id="树莓派的BIOS怎么识别到烧录进SD-Card的操作系统的？"><a href="#树莓派的BIOS怎么识别到烧录进SD-Card的操作系统的？" class="headerlink" title="树莓派的BIOS怎么识别到烧录进SD Card的操作系统的？"></a>树莓派的BIOS怎么识别到烧录进SD Card的操作系统的？</h4><p>计算机的启动过程大致分为以下几个步骤</p>
<ol>
<li>按下开机键，CPU将PC寄存器的值强制初始化为<code>0xffff0</code>，这个位置是BIOS程序的入口地址</li>
<li>该入口地址处是一个跳转指令，跳转到<code>0xfe05b</code>位置，开始执行真正的BIOS程序</li>
<li>BIOS按照启动区的顺序，读取这些启动盘中位于0盘0道1扇区的内容，该内容一共有512字节，如果末尾的两个字节分别是<code>0x55</code>和<code>0xaa</code>，那么BIOS就会认为它是个启动区</li>
<li>BIOS找到启动区之后把512字节的内容，全部复制到内存的<code>0x7c00</code>这个位置，然后将PC寄存器的值改为<code>0x7c00</code></li>
<li>启动区代码主要是加载操作系统内核，最后跳转到加载处</li>
</ol>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20210912154004.png"></p>
<p>以上内容参考自：<a href="https://mp.weixin.qq.com/s/cXbCd_nK4_VssJaUREiPmA">《全网最硬核讲解计算机的启动过程》</a></p>
<h2 id="预置必要配置"><a href="#预置必要配置" class="headerlink" title="预置必要配置"></a>预置必要配置</h2><p>烧录镜像成功后，需要新增/修改 boot文件夹下的配置</p>
<ol>
<li>开启SSH：增加一个空的<code>ssh.txt</code>文件</li>
<li>配置WiFi：增加<code>wpa_supplicant.conf</code>文件，内容如下</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">country=CN</span><br><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">	ssid=&quot;填写wifi的名字&quot;</span><br><span class="line">	psk=&quot;填写wifi的密码&quot;</span><br><span class="line">	priority=1</span><br><span class="line">&#125;</span><br><span class="line">network=&#123;</span><br><span class="line">	ssid=&quot;填写wifi的名字&quot;</span><br><span class="line">	psk=&quot;填写wifi的密码&quot;</span><br><span class="line">	priority=2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ssid：填写wifi的名称</li>
<li>psk：填写wifi的密码</li>
<li>priority：该wifi的连接优先级，值越大优先级越高</li>
<li>可以输入多个network</li>
</ul>
<ol start="3">
<li>修改显示配置，config.txt最后增加<code>hdmi_cvt=2560 1440 60 3 0 0 0</code></li>
</ol>
<p>笔者用的是4K显示器，但是如果设置成4K对应的分辨率字体太小，所以这里设置成了<code>2560 x 1440</code>。</p>
<p>修改完成后，执行<code>diskutil unmountDisk /dev/diskN</code>，最后<code>diskutil eject /dev/diskN</code>推出设备。</p>
<h2 id="修改部分配置"><a href="#修改部分配置" class="headerlink" title="修改部分配置"></a>修改部分配置</h2><p>带安装完成后，<code>ssh pi@YOUR_PI_IP</code>登录到机器，进行部分配置的修改</p>
<h3 id="修改键盘布局"><a href="#修改键盘布局" class="headerlink" title="修改键盘布局"></a>修改键盘布局</h3><ol>
<li>sudo raspi-config</li>
<li>选择  localisation options</li>
<li>选择 Change Keyboard layout</li>
<li>选择 Generic 104-key PC</li>
<li>选择 Other</li>
<li>选择 Chinese</li>
<li>选择 Chinese</li>
<li>选择 The default for the keyboard layout</li>
<li>选择 no compose key</li>
</ol>
<h3 id="修改用户名-hostname"><a href="#修改用户名-hostname" class="headerlink" title="修改用户名/hostname"></a>修改用户名/hostname</h3><ol>
<li>启用root账号，然后切换至root</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo passwd root  #设置root用户密码</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入新的UNIX密码：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">再输入一次密码：</span></span><br><span class="line"></span><br><span class="line">sudo passwd --unlock root #启用root用户</span><br><span class="line">su root # 切换成root用户</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改用户名</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">usermod -l yourname pi #修改用户名为你的名字</span><br><span class="line">groupmod -n yourname pi #修改组名pi为你的名字</span><br><span class="line">mv /home/pi /home/yourname #更改pi的home目录为你的名字的home目录</span><br><span class="line">usermod -d /home/yourname yourname #修改/etc/passwd中yourname用户的home目录地址</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">有的可能需要允许你的名字的用户使用sudo命令，需要编辑/etc/sudoers文件，将末尾的</span></span><br><span class="line">pi ALL=(ALL) NOPASSWD: ALL</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">改为</span></span><br><span class="line">yourname ALL=(ALL) NOPASSWD: ALL #此操作需要查看配置文件是否限制了用户权限</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改密码</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo passwd yourname  #修改yourname用户密码</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入新的UNIX密码：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">再输入一次密码：</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可重新锁定root用户</span></span><br><span class="line">sudo passwd -l root</span><br></pre></td></tr></table></figure>

<h3 id="修改软件源"><a href="#修改软件源" class="headerlink" title="修改软件源"></a>修改软件源</h3><p>由于科学上网的原因，很多国外的软件源都没办法访问，所以这里我们把常用的源换成国内的。</p>
<p>由于raspberry源对64位Pi OS支持不完全， <strong>sources.list</strong>需要使用debian源，而32位的直接使用raspberry源就行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把原来的内容注释掉（最前面加 <span class="comment"># 号），在文件最顶部添加下面的内容：</span></span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian buster main contrib non-free</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian-security/ buster/updates main contrib non-free</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian buster-updates main contrib non-free</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改 raspi.list 文件，用以下内容替换(树莓派基金会单独提供的源，与32位Pi OS的一致)：</span></span><br><span class="line">sudo vim /etc/apt/sources.list.d/raspi.list</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同步更新源、软件包</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装必要的库和包</span></span><br><span class="line">sudo apt-get install build-essential cmake make gcc</span><br></pre></td></tr></table></figure>

<p>如遇到以下报错，可以通过导入对应仓库的公钥来解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get:1 http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian buster InRelease [15.0 kB]</span><br><span class="line">Hit:2 http://mirrors.tuna.tsinghua.edu.cn/raspberrypi buster InRelease</span><br><span class="line">Err:1 http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian buster InRelease</span><br><span class="line">  The following signatures couldn&#x27;t be verified because the public key is not available: NO_PUBKEY 9165938D90FDDD2E</span><br><span class="line">Reading package lists... Done</span><br><span class="line">W: GPG error: http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian buster InRelease: The following signatures couldn&#x27;t be verified because the public key is not available: NO_PUBKEY 9165938D90FDDD2E</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpg --keyserver keyserver.ubuntu.com --recv-keys 9165938D90FDDD2E</span><br><span class="line">gpg --export --armor 9165938D90FDDD2E | sudo apt-key add -</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<h3 id="改为静态IP"><a href="#改为静态IP" class="headerlink" title="改为静态IP"></a>改为静态IP</h3><p>由于通过DHCP分配的IP有可能会变，这对我们后续的SSH登录、端口转发等都会造成影响，所以这里需要改成静态IP。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑dhcp配置</span></span><br><span class="line">sudo vim /etc/dhcpcd.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在文件最后增加</span></span><br><span class="line">interface eth0</span><br><span class="line">static ip_address=192.168.1.200/24	# 笔者路由器配置的DHCP池为100~199，所以这里规划静态IP从200开始</span><br><span class="line">static routers=192.168.1.1</span><br><span class="line">static domain_name_servers=192.168.1.1 223.5.5.5 8.8.8.8</span><br></pre></td></tr></table></figure>

<p>其中<code>eth0</code>代表有线以太网接口，如要配置无线网，使用<code>wlan0</code>；<code>ip_address</code>就是IP地址，根据实际情况配置；<code>routers</code>是网关地址；<code>domain_name_servers</code>是DNS服务器的地址。</p>
<h2 id="配置基础开发环境"><a href="#配置基础开发环境" class="headerlink" title="配置基础开发环境"></a>配置基础开发环境</h2><p>笔者的目标是利用树莓派搭建一个服务器集群，使用k3s进行服务编排，在上面运行自己的博客、FaaS以及其他一些小服务。同时能够在上面编译运行Go、Python等代码。</p>
<h3 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h3><h4 id="访问github失败的解决方法"><a href="#访问github失败的解决方法" class="headerlink" title="访问github失败的解决方法"></a>访问github失败的解决方法</h4><p>如果访问<code>raw.githubusercontent.com</code>失败，需要用国内的资源来安装</p>
<ol>
<li>从gitee上下载安装脚本 <code>wget https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh</code></li>
<li>编辑install.sh，修改下面内容，然后执行<code>sh install.sh</code></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到</span></span><br><span class="line">REPO=$&#123;REPO:-ohmyzsh/ohmyzsh&#125;</span><br><span class="line">REMOTE=$&#123;REMOTE:-https://github.com/$&#123;REPO&#125;.git&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">改为</span></span><br><span class="line">REPO=$&#123;REPO:-mirrors/oh-my-zsh&#125;</span><br><span class="line">REMOTE=$&#123;REMOTE:-https://gitee.com/$&#123;REPO&#125;.git&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改仓库地址</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/.oh-my-zsh</span><br><span class="line">git remote set-url origin https://gitee.com/mirrors/oh-my-zsh.git</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h4 id="配置zsh插件"><a href="#配置zsh插件" class="headerlink" title="配置zsh插件"></a>配置zsh插件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br><span class="line"></span><br><span class="line">git clone https://github.com/zsh-users/zsh-completions $&#123;ZSH_CUSTOM:=~/.oh-my-zsh/custom&#125;/plugins/zsh-completions</span><br><span class="line"></span><br><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br><span class="line"></span><br><span class="line">plugins=(</span><br><span class="line">        git</span><br><span class="line">        docker</span><br><span class="line">        kubectl</span><br><span class="line">        z</span><br><span class="line">        sudo</span><br><span class="line">        extract</span><br><span class="line">        zsh-autosuggestions</span><br><span class="line">        zsh-syntax-highlighting</span><br><span class="line">        zsh-completions</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="安装编程语言"><a href="#安装编程语言" class="headerlink" title="安装编程语言"></a>安装编程语言</h2><p>这里推荐一个非常好用的多版本包管理工具<a href="https://github.com/asdf-vm/asdf"><code>asdf</code></a>，它可以把我们平常用到的pyenv、jenv、goenv等多版本管理的工具融合成一个，方便的安装和管理。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装asdf工具</span></span><br><span class="line">git clone https://github.com/asdf-vm/asdf.git ~/.asdf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加plugin</span></span><br><span class="line">asdf plugin add golang</span><br><span class="line">asdf plugin add python</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">选择安装plugin的某个版本</span></span><br><span class="line">asdf install golang 1.16.8</span><br><span class="line">asdf install python 3.8.9</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全局切换plugin版本</span></span><br><span class="line">asdf global golang 1.16.8</span><br></pre></td></tr></table></figure>

<p>笔者在安装python的过程中遇到了下面的报错，可以通过安装<code>sudo apt install libssl-dev</code>解决。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Installing Python-3.8.9...</span><br><span class="line">WARNING: The Python bz2 extension was not compiled. Missing the bzip2 lib?</span><br><span class="line">WARNING: The Python readline extension was not compiled. Missing the GNU readline lib?</span><br><span class="line">ERROR: The Python ssl extension was not compiled. Missing the OpenSSL lib?</span><br><span class="line"></span><br><span class="line">Please consult to the Wiki page to fix the problem.</span><br><span class="line">https://github.com/pyenv/pyenv/wiki/Common-build-problems</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BUILD FAILED (Debian 10 using python-build 2.0.7-19-g9ecfdd10)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>玩转树莓派</category>
      </categories>
  </entry>
  <entry>
    <title>玩转树莓派 —— 安装k3s和openfaas</title>
    <url>/posts/8dc4/</url>
    <content><![CDATA[<h1 id="k3s"><a href="#k3s" class="headerlink" title="k3s"></a>k3s</h1><p><a href="https://landscape.cncf.io/">CNCF Landspace</a></p>
<h2 id="Why-k3s"><a href="#Why-k3s" class="headerlink" title="Why k3s"></a>Why k3s</h2><ol>
<li>production-ready，完全通过CNCF认证的<code>Kubernetes</code>产品</li>
<li>完全实现了k8s的接口，意味着仍旧可以使用kubectl控制集群，学习成本低</li>
<li>移除了k8s中一些只有在大型集群才用得到的组件，比如默认使用SQLite替代ETCD，同时将这些driver做成可配置的</li>
<li>安装包只有40mb，并且包含所有需要的底层组件，例如<code>containerd</code>、<code>runc</code>等</li>
<li>CPU/Mem资源占用低，适合边缘设备（例如IOT/RPI等）运行</li>
</ol>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/2023/11/d9a51180723d9fe415f0691051a80af3.png"></p>
<blockquote>
<p>k3s的名字怎么来的：We wanted an installation of Kubernetes that was half the size in terms of memory footprint. Kubernetes is a 10-letter word stylized as K8s. So something half as big as Kubernetes would be a 5-letter word stylized as K3s. There is no long form of K3s and no official pronunciation.</p>
</blockquote>
<h2 id="安装k3s"><a href="#安装k3s" class="headerlink" title="安装k3s"></a>安装k3s</h2><p>开启内核的container特性，编辑<code>/boot/cmdline.txt</code>，在文件末尾（注意不要换行）增加如下配置，然后重启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cgroup_enable=cpuset cgroup_memory=1 cgroup_enable=memory</span><br></pre></td></tr></table></figure>

<p>执行<code>curl -sfL https://get.k3s.io | sh -</code>，开始安装。</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/install-k3s.png"></p>
<p>安装成功后：</p>
<ol>
<li>K3s 服务将配置为在节点重新启动后或者进程崩溃或被终止时自动重新启动（通过systemd）</li>
<li>将安装其他实用程序，包括 kubectl、crictl、ctr、k3s-killall.sh 和 k3s-uninstall.sh</li>
<li>kubeconfig 文件将被写入 /etc/rancher/k3s/k3s.yaml，K3s 安装的 kubectl 将自动使用它</li>
</ol>
<p>如果遇到执行<code>k get nodes</code>，可能会报如下错误，通过<code>sudo chmod 600 /etc/rancher/k3s/k3s.yaml</code>解决。</p>
<p>使用其他工具比如openfaas、kubectl可能会报错<code>Error:  Kubernetes cluster unreachable: Get &quot;http://localhost:8080/version?timeout=32s&quot;: dial tcp [::1]:8080: connect: connection refused</code>。这是因为默认使用的是<code>~/.kube/config</code>文件，所以需要修改<code>KUBECONFIG</code>环境变量值为<code>/etc/rancher/k3s/k3s.yaml</code>的路径，可以在zshrc中配置<code>export KUBECONFIG=/etc/rancher/k3s/k3s.yaml</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">k get nodes</span></span><br><span class="line">WARN[2021-09-13T01:38:43.154515572+08:00] Unable to read /etc/rancher/k3s/k3s.yaml, please start server with --write-kubeconfig-mode to modify kube config permissions </span><br><span class="line">error: error loading config file &quot;/etc/rancher/k3s/k3s.yaml&quot;: open /etc/rancher/k3s/k3s.yaml: permission denied</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">k get pods --all-namespaces</span></span><br><span class="line">NAMESPACE     NAME                                      READY   STATUS      RESTARTS   AGE</span><br><span class="line">kube-system   coredns-7448499f4d-9jdsr                  1/1     Running     0          13m</span><br><span class="line">kube-system   local-path-provisioner-5ff76fc89d-zqd69   1/1     Running     0          13m</span><br><span class="line">kube-system   metrics-server-86cbb8457f-kp6ml           1/1     Running     0          13m</span><br><span class="line">kube-system   helm-install-traefik-crd-vnggw            0/1     Completed   0          13m</span><br><span class="line">kube-system   helm-install-traefik-kl4kv                0/1     Completed   1          13m</span><br><span class="line">kube-system   svclb-traefik-ph5n4                       2/2     Running     0          11m</span><br><span class="line">kube-system   traefik-97b44b794-48kjb                   1/1     Running     0          11m</span><br></pre></td></tr></table></figure>

<h3 id="加入其他agent节点"><a href="#加入其他agent节点" class="headerlink" title="加入其他agent节点"></a>加入其他agent节点</h3><p>在另一台服务器上（运行在笔者小主机PVE上的一台Ubuntu虚拟机），执行 <code>curl -sfL https://get.k3s.io | K3S_URL=https://myserver:6443 K3S_TOKEN=mynodetoken sh -</code>，作为agent加入k3s集群。</p>
<p>设置<code>K3S_URL</code>参数会导致安装程序将 K3s 配置为代理，而不是服务器。 K3s 代理将向监听提供的 URL 的 K3s 服务器注册。用于 K3S_TOKEN 的值存储在服务器节点上的<code>/var/lib/rancher/k3s/server/node-token</code>中。</p>
<p>执行成功后，执行<code>k get node</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">k get node</span></span><br><span class="line">NAME            STATUS   ROLES                  AGE     VERSION</span><br><span class="line">leo-cluster-1   Ready    control-plane,master   2y52d   v1.21.4+k3s1</span><br><span class="line">leo-cluster-2   Ready    &lt;none&gt;                 2m34s   v1.27.7+k3s1</span><br></pre></td></tr></table></figure>

<h2 id="部属个微服务试试"><a href="#部属个微服务试试" class="headerlink" title="部属个微服务试试"></a>部属个微服务试试</h2><p>现在我们成功的创建了一个集群，下面我们来部署一个<code>figlet</code>服务，这个服务可以将HTTP请求体中的字符串转成<code>ASCII</code>格式的。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">openfaas-figlet</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">   <span class="attr">app:</span> <span class="string">openfaas-figlet</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">openfaas-figlet</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">openfaas-figlet</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">openfaas-figlet</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">functions/figlet:latest-armhf</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">openfaas-figlet</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">openfaas-figlet</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">31111</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">openfaas-figlet</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">leosocy @ leo-cluster-1 <span class="keyword">in</span> ~/workspace/k8s [2:15:54]</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -n <span class="string">&quot;I like <span class="subst">$(users)</span>&quot;</span> | curl --data-binary @- http://127.0.0.1:31111</span></span><br><span class="line"> ___   _ _ _          _                                 </span><br><span class="line">|_ _| | (_) | _____  | | ___  ___  ___  ___   ___ _   _ </span><br><span class="line"> | |  | | | |/ / _ \ | |/ _ \/ _ \/ __|/ _ \ / __| | | |</span><br><span class="line"> | |  | | |   &lt;  __/ | |  __/ (_) \__ \ (_) | (__| |_| |</span><br><span class="line">|___| |_|_|_|\_\___| |_|\___|\___/|___/\___/ \___|\__, |</span><br><span class="line">                                                  |___/</span><br></pre></td></tr></table></figure>

<h1 id="Arkade"><a href="#Arkade" class="headerlink" title="Arkade"></a>Arkade</h1><p><a href="https://github.com/alexellis/arkade">arkade</a>提供了一个便携式的marketplace，通过单个命令就可以下载想要的CLI和helm charts。</p>
<h2 id="安装arkade"><a href="#安装arkade" class="headerlink" title="安装arkade"></a>安装arkade</h2><p>可能是被墙的原因，在树莓派上使用官方的安装方式一致pending，所以我直接把安装的shell脚本源码贴到机器上执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装脚本的源码</span></span><br><span class="line">https://raw.githubusercontent.com/alexellis/arkade/master/get.sh</span><br><span class="line"></span><br><span class="line">sudo sh get_arkada.sh</span><br><span class="line">aarch64</span><br><span class="line">Downloading package https://github.com/alexellis/arkade/releases/download/0.8.2/arkade-arm64 as /tmp/arkade-arm64</span><br><span class="line">Download complete.</span><br><span class="line"></span><br><span class="line">Running with sufficient permissions to attempt to move arkade to /usr/local/bin</span><br><span class="line">New version of arkade installed to /usr/local/bin</span><br><span class="line">Creating alias &#x27;ark&#x27; for &#x27;arkade&#x27;.</span><br><span class="line">            _             _      </span><br><span class="line">  __ _ _ __| | ____ _  __| | ___ </span><br><span class="line"> / _` | &#x27;__| |/ / _` |/ _` |/ _ \</span><br><span class="line">| (_| | |  |   &lt; (_| | (_| |  __/</span><br><span class="line"> \__,_|_|  |_|\_\__,_|\__,_|\___|</span><br><span class="line"></span><br><span class="line">Get Kubernetes apps the easy way</span><br><span class="line"></span><br><span class="line">Version: 0.8.2</span><br><span class="line">Git Commit: 8b3fbc0994129f6c14daef467593ae02799409c0</span><br></pre></td></tr></table></figure>

<h2 id="安装常用cli和app"><a href="#安装常用cli和app" class="headerlink" title="安装常用cli和app"></a>安装常用cli和app</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装helm cli</span></span><br><span class="line">ark get helm</span><br></pre></td></tr></table></figure>

<h1 id="OpenFaaS"><a href="#OpenFaaS" class="headerlink" title="OpenFaaS"></a>OpenFaaS</h1><h2 id="Why-OpenFaaS"><a href="#Why-OpenFaaS" class="headerlink" title="Why OpenFaaS"></a>Why OpenFaaS</h2><p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/2023/11/60aefca718a9bdc5765272aeabf96cf6.png"></p>
<ol>
<li>用任何语言编写函数并将其打包到 Docker/OCI 格式的容器中</li>
<li>易于使用 - 内置 UI、强大的 CLI 和一键安装</li>
<li>随时扩展 - 处理流量高峰，并在空闲时缩小规模</li>
<li>生态系统 - 函数和语言模板的社区市场</li>
</ol>
<h2 id="安装OpenFaaS"><a href="#安装OpenFaaS" class="headerlink" title="安装OpenFaaS"></a>安装OpenFaaS</h2><p>安装 faas-cli 来管理OpenFaaS并部署functions</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ark get faas-cli</span><br></pre></td></tr></table></figure>

<p>安装  OpenFaaS CE，并配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ark install openfaas</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If basic auth is enabled, you can now <span class="built_in">log</span> into your gateway:</span></span><br><span class="line">PASSWORD=$(kubectl get secret -n openfaas basic-auth -o jsonpath=&quot;&#123;.data.basic-auth-password&#125;&quot; | base64 --decode; echo)</span><br><span class="line">echo -n $PASSWORD | faas-cli login --username admin --password-stdin</span><br><span class="line"></span><br><span class="line">faas-cli store deploy figlet</span><br><span class="line">faas-cli list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For Raspberry Pi</span></span><br><span class="line">faas-cli store list \</span><br><span class="line">--platform armhf</span><br><span class="line"></span><br><span class="line">faas-cli store deploy figlet \</span><br><span class="line">--platform armhf</span><br></pre></td></tr></table></figure>

<h2 id="部署一个Function"><a href="#部署一个Function" class="headerlink" title="部署一个Function"></a>部署一个Function</h2><p>可以使用openfaas的gateway-external service对应的NodePort访问UI，也可以通过port-forward gateway ClusterIP访问UI。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">k get svc -n openfaas</span></span><br><span class="line">NAME               TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">prometheus         ClusterIP   10.43.44.77     &lt;none&gt;        9090/TCP         173m</span><br><span class="line">gateway            ClusterIP   10.43.10.152    &lt;none&gt;        8080/TCP         173m</span><br><span class="line">gateway-external   NodePort    10.43.112.150   &lt;none&gt;        8080:31112/TCP   173m</span><br><span class="line">alertmanager       ClusterIP   10.43.229.238   &lt;none&gt;        9093/TCP         173m</span><br><span class="line">nats               ClusterIP   10.43.89.8      &lt;none&gt;        4222/TCP         173m</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>玩转树莓派</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>使用kingshard + peewee过程中遇到的一些“坑”</title>
    <url>/posts/98f0/</url>
    <content><![CDATA[<p>当产品用户量、日活与日俱增，后端数据库的负载通常也会越来越大，此时单纯的增加索引已经无法解决亿级数据的CRUD操作了。通常我们会选择分库+分表来解决数据库的瓶颈。使用proxy可以做到对业务层透明，业务无需关心数据库如何shard，SQL如何分发数据如何聚合。我们自己的业务使用的是<a href="https://github.com/flike/kingshard">kingshard</a>这个用Go实现的开源数据库代理，然后ORM一直使用的是<a href="http://docs.peewee-orm.com/en/latest/">peewee</a>。在使用的过程中遇到了一些稀奇古怪的问题，这里记录一下排查的过程，以及其中的具体原因，最后给出可行的解决方案。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>根据kingshard<a href="https://github.com/flike/kingshard/blob/master/doc/KingDoc/how_to_use_kingshard.md#2-%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E5%8A%A8%E8%AF%B4%E6%98%8E">官方文档</a>，在本地搭建具有两个Node的数据库‘集群’。同时创建好<code>test_shard_hash</code>分表，这里我们以<code>user_id</code>作为shard_key。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql root@localhost:ks1&gt; show create table test_shard_hash_0001;</span><br><span class="line">+----------------------+-------------------------------------------+</span><br><span class="line">| Table                | Create Table                              |</span><br><span class="line">+----------------------+-------------------------------------------+</span><br><span class="line">| test_shard_hash_0001 | CREATE TABLE `test_shard_hash_0001` (     |</span><br><span class="line">|                      |   `id` bigint(64) unsigned NOT NULL,      |</span><br><span class="line">|                      |   `user_id` bigint(64) unsigned NOT NULL, |</span><br><span class="line">|                      |   `name` varchar(255) NOT NULL,           |</span><br><span class="line">|                      |   `age` smallint(6) NOT NULL,             |</span><br><span class="line">|                      |   PRIMARY KEY (`user_id`,`id`)            |</span><br><span class="line">|                      | ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4   |</span><br><span class="line">+----------------------+-------------------------------------------+</span><br></pre></td></tr></table></figure>

<p>pip安装playhouse, peewee, pymysql等package。ipython启动并链接kingshard。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> peewee <span class="keyword">as</span> pw</span><br><span class="line">In [<span class="number">2</span>]: <span class="keyword">from</span> playhouse <span class="keyword">import</span> db_url</span><br><span class="line">In [<span class="number">3</span>]: db = db_url.connect(<span class="string">&quot;mysql://127.0.0.1&quot;</span>, port=<span class="number">9696</span>, user=<span class="string">&quot;root&quot;</span>, password=<span class="string">&quot;root&quot;</span>, database=<span class="string">&quot;ks1&quot;</span>)</span><br><span class="line">In [<span class="number">4</span>]: db.get_tables()</span><br><span class="line">Out[<span class="number">4</span>]:</span><br><span class="line">[<span class="string">&#x27;test_shard_hash_0000&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;test_shard_hash_0001&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;test_shard_hash_0002&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;test_shard_hash_0003&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;test_shard_range_0000&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;test_shard_range_0001&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;test_shard_range_0002&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;test_shard_range_0003&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>创建对应表结构的model，并绑定到db实例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">6</span>]: <span class="keyword">class</span> <span class="title class_">UserInfo</span>(pw.Model):</span><br><span class="line">   ...:     <span class="built_in">id</span> = pw.BigIntegerField()</span><br><span class="line">   ...:     user_id = pw.BigIntegerField()</span><br><span class="line">   ...:     name = pw.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">   ...:     age = pw.SmallIntegerField()</span><br><span class="line">   ...:     <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">   ...:         primary_key = pw.CompositeKey(<span class="string">&quot;user_id&quot;</span>, <span class="string">&quot;id&quot;</span>)</span><br><span class="line">   ...:         table_name = <span class="string">&quot;test_shard_hash&quot;</span></span><br><span class="line">In [<span class="number">7</span>]: UserInfo.bind(db)</span><br><span class="line">Out[<span class="number">7</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>下面我们打开kingshard sql日志，试一下CRUD等操作。</p>
<p>create</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: UserInfo.create(user_id=<span class="number">1</span>, <span class="built_in">id</span>=<span class="number">1</span>, name=<span class="string">&quot;&quot;</span>, age=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">10</span>]: &lt;UserInfo: (<span class="number">1</span>, <span class="number">1</span>)&gt;</span><br><span class="line"></span><br><span class="line">kingshard日志</span><br><span class="line">OK - <span class="number">1.0</span>ms - <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">59593</span>-&gt;<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3306</span>:insert  into test_shard_hash_0001(<span class="built_in">id</span>, user_id, name, age) values (<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">测试一下插入冲突</span><br><span class="line">In [<span class="number">11</span>]: UserInfo.create(user_id=<span class="number">1</span>, <span class="built_in">id</span>=<span class="number">1</span>, name=<span class="string">&quot;&quot;</span>, age=<span class="number">0</span>)   <span class="comment"># IntegrityError: (1062, &quot;Duplicate entry &#x27;1-1&#x27; for key &#x27;PRIMARY&#x27;&quot;)</span></span><br><span class="line">In [<span class="number">12</span>]: UserInfo.create(user_id=<span class="number">5</span>, <span class="built_in">id</span>=<span class="number">1</span>, name=<span class="string">&quot;&quot;</span>, age=<span class="number">0</span>)   <span class="comment"># InternalError: (1105, &#x27;transaction in multi node&#x27;)</span></span><br><span class="line">我们发现kingshard报错了，原因是一个事务跨node了，但是我们这里并没有显式开启事务，这是为什么呢？我们下面会分析。</span><br></pre></td></tr></table></figure>

<p>select</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: u = UserInfo.select().where(UserInfo.user_id == <span class="number">1</span>).first()</span><br><span class="line">In [<span class="number">19</span>]: u.user_id</span><br><span class="line">Out[<span class="number">19</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">OK - <span class="number">0.9</span>ms - <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">59593</span>-&gt;<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3306</span>:select t1.<span class="built_in">id</span>, t1.user_id, t1.name, t1.age <span class="keyword">from</span> test_shard_hash_0001 <span class="keyword">as</span> t1 where (t1.user_id = <span class="number">1</span>) limit <span class="number">1</span></span><br><span class="line"></span><br><span class="line">跨node的select</span><br><span class="line">In [<span class="number">43</span>]: UserInfo.select() <span class="comment"># InternalError: (1105, &#x27;transaction in multi node&#x27;)</span></span><br><span class="line">发生了跟之前一样的问题。</span><br></pre></td></tr></table></figure>

<p>count</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">UserInfo.select().where(UserInfo.user_id == <span class="number">1</span>).count()  <span class="comment"># ProgrammingError: (1146, &quot;Table &#x27;ks1.test_shard_hash&#x27; doesn&#x27;t exist&quot;)</span></span><br><span class="line"></span><br><span class="line">ERROR - <span class="number">15.1</span>ms - <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">59593</span>-&gt;<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3306</span>:SELECT COUNT(<span class="number">1</span>) FROM (SELECT <span class="number">1</span> FROM `test_shard_hash` AS `t1` WHERE (`t1`.`user_id` = <span class="number">2</span>)) AS `_wrapped`</span><br><span class="line">这说明这种count方法kingshard没办法根据shard_key计算出发往哪张表。我们换一种方法试试：</span><br><span class="line">----------------------------------------------</span><br><span class="line">In [<span class="number">35</span>]: UserInfo.select(pw.fn.COUNT(<span class="string">&#x27;*&#x27;</span>)).where(UserInfo.user_id == <span class="number">1</span>).scalar()</span><br><span class="line">Out[<span class="number">35</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">OK - <span class="number">1.2</span>ms - <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">59593</span>-&gt;<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3306</span>:select count(<span class="string">&#x27;*&#x27;</span>) <span class="keyword">from</span> test_shard_hash_0001 <span class="keyword">as</span> t1 where (t1.user_id = <span class="number">1</span>)</span><br><span class="line">看来这种写法可行，我们测试一下跨node的count</span><br><span class="line">In [<span class="number">47</span>]: UserInfo.select(pw.fn.COUNT(<span class="string">&#x27;*&#x27;</span>)).scalar() <span class="comment"># InternalError: (1105, &#x27;transaction in multi node&#x27;)</span></span><br><span class="line">还是不行，看来kingshard的跨node基本的操作在peewee里都搞不起来，下面我们会一步步揭开它的神秘面纱。</span><br></pre></td></tr></table></figure>

<p>update</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">50</span>]: UserInfo.update(age=<span class="number">10</span>).where(UserInfo.user_id == <span class="number">1</span>).execute()</span><br><span class="line">Out[<span class="number">50</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">测试一下kingshard支持的跨node更新</span><br><span class="line">In [<span class="number">56</span>]: UserInfo.update(age=<span class="number">10</span>).where(UserInfo.user_id.in_((<span class="number">1</span>,<span class="number">5</span>))).execute()   <span class="comment"># InternalError: (1105, &#x27;transaction in multi node&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>通过这些例子我们发现，kingshard支持的一些跨node的操作</p>
<ul>
<li>范围select</li>
<li>批量update</li>
<li>count/sum</li>
<li>order by</li>
</ul>
<p>在peewee中都会报<code>transaction in multi node</code>的错误。</p>
<p>同时，如果上一条insert/update语句插入冲突报错，再次执行一条分发到另一个node的语句，同样也会报事务跨node的错误。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>kingshard报<code>transaction in multi node</code>的错误，本质上是因为我们显式或隐式的开启了一个事务，然后执行的SQL经过kingshard计算发现会操作不同的node，进而产生的报错。</p>
<h3 id="kingshard如何判断当前是否处于一个事务下"><a href="#kingshard如何判断当前是否处于一个事务下" class="headerlink" title="kingshard如何判断当前是否处于一个事务下"></a>kingshard如何判断当前是否处于一个事务下</h3><p>我们简单的分析一下kingshard如何判断事务跨node的</p>
<ol>
<li><a href="https://github.com/flike/kingshard/blob/master/proxy/server/conn.go#L306">dispatch</a>： 循环接收处理client请求</li>
<li><a href="https://github.com/flike/kingshard/blob/master/proxy/server/conn.go#L336">handleQuery</a>：处理CRUD操作，这里我们拿<code>select</code>来说，会走到<a href="https://github.com/flike/kingshard/blob/master/proxy/server/conn_select.go#L99">handleSelecte</a>。</li>
<li><a href="https://github.com/flike/kingshard/blob/master/proxy/router/router.go#L306">buildSelectPlan</a>根据SQL构建执行计划，决定要发到哪些node哪些表。</li>
<li><a href="https://github.com/flike/kingshard/blob/master/proxy/server/conn_select.go#L112">getShardConns</a>中，<em>如果in transaction</em>则会根据以下规则判断是否返回<code>transaction in multi node</code>错误<ol>
<li>一条执行计划中路由到node的数大于1</li>
<li>当前为事务下执行的第二条SQL，且未与上一条SQL分发到一个node上</li>
</ol>
</li>
</ol>
<p>下面我们来重点关注一下如何判断in transaction</p>
<ol>
<li><a href="https://github.com/flike/kingshard/blob/master/proxy/server/conn_tx.go#L22">isInTransaction</a>会先根据status按位计算如果大于0则表示in trans，这一位是在<a href="https://github.com/flike/kingshard/blob/master/proxy/server/conn_tx.go#L31">handleBegin</a>置上的，也就是显式begin一个事务。</li>
<li>然后如果上一个条件不满足，会根据<code>autocommit</code>的值来判断，如果autocommit=0，也算是在事务中。这一位是在<a href="https://github.com/flike/kingshard/blob/master/proxy/server/conn_set.go#L78">handleSetAutoCommit</a>置上的，也就是客户端执行<code>SET AUTOCOMMIT=x</code>。默认值<a href="https://github.com/flike/kingshard/blob/master/proxy/server/server.go#L342"><code>c.status = mysql.SERVER_STATUS_AUTOCOMMIT</code></a>，即autocommit=1</li>
</ol>
<p>也就是说如果client执行了<code>begin</code>，或者<code>set autocommit=0</code>，kingshard就会认为当前执行的sql在事务下。</p>
<p>根据上一节的例子，我们并没有显式的开启一个事务，所以一定是peewee建立数据库连接后设置了<code>set autocommit=0</code>，我们继续来看一下peewee在建立连接时做了什么。</p>
<h3 id="peewee建立连接时做了什么"><a href="#peewee建立连接时做了什么" class="headerlink" title="peewee建立连接时做了什么"></a>peewee建立连接时做了什么</h3><p>首先为了验证上一节的猜想，我们用wireshark抓包看一下client建立数据库连接后是不是主动设置了<code>SET AUTOCOMMIT=0</code></p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20190512222627.png"></p>
<p>通过上图我们发现，在建立会话后的第一条SQL命令之前，client主动发送了<code>SET AUTOCOMMIT=0</code>来禁用自动提交模式。</p>
<p>下面是执行了<code>UserInfo.select().where(UserInfo.user_id == 1).get()</code>的抓包结果，我们发现在client在select成功之后，又主动执行了commit语句。这也不难理解，毕竟当前session被设置成了autocommit=0，所以需要执行commit来提交当前事务，并开启下一个事务。</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20190512224121.png"></p>
<p>关于autocommit，截取了官网的说明</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20190512224716.png"></p>
<p>综上，我们推断出两点</p>
<ol>
<li>peewee（准确的说是peewee使用的db driver）在创建数据库连接后，默认会设置session的autocommit=0</li>
<li>如果不是显式的开启事务，默认情况下每执行一条SQL，会自动commit。</li>
</ol>
<p>下面我们通过peewee的源码分析一下</p>
<p>执行一条SQL最主要的入口可以从Database这个基类开始看</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Database</span>(<span class="title class_ inherited__">_callable_context_manager</span>):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute_sql</span>(<span class="params">self, sql, params=<span class="literal">None</span>, commit=SENTINEL</span>):</span><br><span class="line">        logger.debug((sql, params))</span><br><span class="line">        <span class="keyword">if</span> commit <span class="keyword">is</span> SENTINEL:</span><br><span class="line">            <span class="keyword">if</span> self.in_transaction():</span><br><span class="line">                commit = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> self.commit_select:</span><br><span class="line">                commit = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                commit = <span class="keyword">not</span> sql[:<span class="number">6</span>].lower().startswith(<span class="string">&#x27;select&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> __exception_wrapper__:</span><br><span class="line">            cursor = self.cursor(commit)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                cursor.execute(sql, params <span class="keyword">or</span> ())</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="keyword">if</span> self.autorollback <span class="keyword">and</span> <span class="keyword">not</span> self.in_transaction():</span><br><span class="line">                    self.rollback()</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> commit <span class="keyword">and</span> <span class="keyword">not</span> self.in_transaction():</span><br><span class="line">                    self.commit()</span><br><span class="line">        <span class="keyword">return</span> cursor</span><br></pre></td></tr></table></figure>

<p>通过上面一段代码，我们可以得出以下结论</p>
<ol>
<li>有以下两种情况peewee不会帮我们自动commit<ol>
<li>使用<code>db.atomic</code>等函数显式的开启一个事务</li>
<li>commit_select为False(MySQLDatabase设置为True)，并且当前执行的SQL是以<code>select</code>开头的</li>
</ol>
</li>
<li>如果MySQL Server执行SQL时抛错(Duplicate/Deadlock/kingshard一些报错)，并且没有设置<code>autorollback</code>，则<em>当前事务不会提交</em>，这也是为什么如果插入一条数据失败，再使用当前连接执行一个shard到不同node的SQL，同样也会报<code>transaction in multi node</code>。</li>
</ol>
<p>接着看到<code>cursor = self.cursor(commit)</code>这一行，这个函数内部调用了<code>_connect</code>方法，而这个方法是不同的派生类有不同的实现，我们以MySQL举例，实现代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysql_passwd = <span class="literal">False</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> pymysql <span class="keyword">as</span> mysql</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">import</span> MySQLdb <span class="keyword">as</span> mysql</span><br><span class="line">        mysql_passwd = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        mysql = <span class="literal">None</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_connect</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> mysql <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> ImproperlyConfigured(<span class="string">&#x27;MySQL driver not installed!&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> mysql.connect(db=self.database, **self.connect_params)</span><br></pre></td></tr></table></figure>

<p>其实是使用的对应的包提供的方法，我们看一下pymsql的<code>connect</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Connect</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Connect to the database; see connections.Connection.__init__() for</span></span><br><span class="line"><span class="string">    more information.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">from</span> .connections <span class="keyword">import</span> Connection</span><br><span class="line">    <span class="keyword">return</span> Connection(*args, **kwargs)</span><br><span class="line">...</span><br><span class="line">connect = Connection = Connect</span><br><span class="line">...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Connection</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ..., autocommit=<span class="literal">False</span>, ...</span>):</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># specified autocommit mode. None means use server default.</span></span><br><span class="line">        self.autocommit_mode = autocommit</span><br><span class="line">        ...</span><br><span class="line">        self.connect()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, sock=<span class="literal">None</span></span>):</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> self.autocommit_mode <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.autocommit(self.autocommit_mode)</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">autocommit</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.autocommit_mode = <span class="built_in">bool</span>(value)</span><br><span class="line">        current = self.get_autocommit()</span><br><span class="line">        <span class="keyword">if</span> value != current:</span><br><span class="line">            self._send_autocommit_mode()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_send_autocommit_mode</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Set whether or not to commit after every execute()&quot;&quot;&quot;</span></span><br><span class="line">        self._execute_command(COMMAND.COM_QUERY, <span class="string">&quot;SET AUTOCOMMIT = %s&quot;</span> %</span><br><span class="line">                              self.escape(self.autocommit_mode))</span><br><span class="line">        self._read_ok_packet()</span><br></pre></td></tr></table></figure>

<p>终于找到了<code>SET AUTOCOMMIT=0</code>的来源了，由于peewee去除了autocommit参数，所以这段逻辑默认是一定会走到的。</p>
<h3 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h3><p>我们已经看过了源码，这里可以设置autocommit=1，以支持kingshard支持的一些跨node SQL</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: db.connect_params.update(autocommit=<span class="literal">True</span>)</span><br><span class="line">In [<span class="number">2</span>]: db.close()</span><br><span class="line">Out[<span class="number">2</span>]: <span class="literal">True</span></span><br><span class="line">In [<span class="number">3</span>]: db.connect()</span><br><span class="line">Out[<span class="number">3</span>]: <span class="literal">True</span></span><br><span class="line">In [<span class="number">4</span>]: UserInfo.bind(db)</span><br><span class="line">Out[<span class="number">4</span>]: <span class="literal">False</span></span><br><span class="line">In [<span class="number">5</span>]: UserInfo.select(pw.fn.COUNT(<span class="string">&#x27;*&#x27;</span>)).scalar()</span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>kingshard报错<code>transaction in multi node</code>，有一个前提，就是当前session<em>显式的开启一个事务begin/start transaction</em>或者*设置了<code>autocommit=0</code>*。</p>
<p>peewee默认情况下做了如下操作</p>
<ol>
<li>设置session<code>autocommit = 0</code></li>
<li>不显式开启事务(<code>with db.atomic()</code>)的情况下，每条SQL<em>执行成功后</em>都会执行<code>commit</code></li>
</ol>
<p>MySQL的autocommit有如下机制</p>
<ol>
<li>如果开启，MySQL将在每个SQL语句执行成功之后执行提交；如果执行失败，到底是提交还是回滚<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-autocommit-commit-rollback.html">取决于error类型</a>；如果想在一个事务下执行多条SQL，则需显式的begin/start transaction</li>
<li>如果禁用，则会话始终会打开一个事务，COMMIT或ROLLBACK语句结束当前事务，并启动一个新的事务。如果禁用自动提交的会话在没有显式提交最终事务的情况下结束，MySQL将回滚该事务</li>
</ol>
<p>综合以上结论，也就不难得出<a href="#%E5%A4%8D%E7%8E%B0">复现</a>那一节种种报错的原因了。</p>
<p>那知道了原因，我们如何解决呢？</p>
<p>简单点处理的话，可以实现一个<code>PooledKingshardDatabase</code>类，继承<code>PooledMySQLDatabase</code>类，并重写<code>_connect</code>方法，传入<code>autocommit=True</code>，设置kingshard的autocommit，这样做使用起来是不会出什么问题的，因为</p>
<ol>
<li>常见的select是快照读，本来就不需要加锁，在不在事务下无所谓</li>
<li>指定shard_key的update/delete操作，由kingshard计算发往指定node，kingshard会将指定后端数据库连接设置成<code>autocommit=1</code>，这样这条语句的执行逻辑与peewee并无差异。<ol>
<li>kingshard在和node建立连接时是根据MySQL在Response OK返回的Server Status判断对应的连接是否是autocommit，<a href="https://github.com/flike/kingshard/blob/master/backend/backend_conn.go#L183">对应代码</a></li>
<li>如果不是autocommit，kingshard会主动执行<code>set autocommit = 1</code>，<a href="https://github.com/flike/kingshard/blob/master/backend/backend_conn.go#L115">对应代码</a></li>
<li>不过这里mysql server有一个bug，即使启动时指定了<code>autocommit=0</code>，Server Status返回的autocommit对应位也是1，所以kingshard的机制在这里并不生效。<a href="https://bugs.mysql.com/bug.php?id=66884">对应issue</a>，我自己抓包试了一下确实还是存在这个问题。所以还是使用server默认的autocommit=1这个配置吧。</li>
</ol>
</li>
<li>跨节点的select/update/delete/count/sum/orderby等操作都可以支持，不过count操作要重新实现以下。</li>
<li>显式的开启事务逻辑与peewee的无异，只不过多了条限制就是不能跨node。</li>
</ol>
]]></content>
      <categories>
        <category>后端技能</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>分库分表</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解Linux - COW写时拷贝实现原理</title>
    <url>/posts/6d47/</url>
    <content><![CDATA[<p>为了节约物理内存，减少进程创建时资源和时间的消耗，父进程在调用fork()生成子进程时，子进程与父进程会共享同一内存区。<em>只有当其中一进程进行写操作时</em>，系统才会为其另外分配内存页面。这就是写时复制机制(copy on write)的意思。那么Linux内核是如何实现这种机制的呢，今天我们来简要的分析一下。</p>
<span id="more"></span>

<h2 id="fork系统调用流程"><a href="#fork系统调用流程" class="headerlink" title="fork系统调用流程"></a>fork系统调用流程</h2><p><code>sys_fork -&gt; _do_fork(SIGCHLD, 0, 0, NULL, NULL, 0) -&gt; copy_process() -&gt; copy_mm(clone_flags, p)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_mm</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">oldmm</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_VM) &#123;</span><br><span class="line">        mmget(oldmm);</span><br><span class="line">        mm = oldmm;</span><br><span class="line">        <span class="keyword">goto</span> good_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    retval = -ENOMEM;</span><br><span class="line">    mm = dup_mm(tsk);</span><br><span class="line">    ...</span><br><span class="line">good_mm:</span><br><span class="line">    tsk-&gt;mm = mm;</span><br><span class="line">    tsk-&gt;active_mm = mm;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail_nomem:</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>copy_mm的逻辑为，如果clone_flags指定了CLONE_VM，对应的clone()系统调用创建线程，则共享父进程的mm结构；否则属于创建进程需要调用dup_mm，dup_mm进而调用dup_mmap函数。</p>
<p>dup_mm先给子进程分配了一个新的结构体，然后调用dup_mmap拷贝父进程地址空间，所以我们再进入 dup_mmap看看拷贝了什么东西，因为dup_mmap函数代码太长就不贴出来了，直接看copy_page_range函数，这个函数负责页表得拷贝，我们知道Linux从2.6.11开始采用四级分页模型，分别是pgd、pud、pmd、pte，所以从copy_page_range一直调用到copy_pte_range都是拷贝相应的页表条目，最后我们再来看看copy_pte_range调用的copy_one_pte函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">copy_one_pte</span><span class="params">(<span class="keyword">struct</span> mm_struct *dst_mm, <span class="keyword">struct</span> mm_struct *src_mm,</span></span><br><span class="line"><span class="params">        <span class="type">pte_t</span> *dst_pte, <span class="type">pte_t</span> *src_pte, <span class="keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">int</span> *rss)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_flags = vma-&gt;vm_flags;</span><br><span class="line">    <span class="type">pte_t</span> pte = *src_pte;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If it&#x27;s a COW mapping, write protect it both</span></span><br><span class="line"><span class="comment">     * in the parent and the child</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (is_cow_mapping(vm_flags)) &#123;</span><br><span class="line">        ptep_set_wrprotect(src_mm, addr, src_pte);</span><br><span class="line">        pte = pte_wrprotect(pte);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">out_set_pte:</span><br><span class="line">    set_pte_at(dst_mm, addr, dst_pte, pte);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码判断如果父进程的页支持写时复制，就将父子进程的页都置为写保护，清除pte的_PAGE_BIT_RW标记。</p>
<p>至此fork系统调用就完成了，那么当父进程或者子进程尝试写共享物理页时，内核是怎么拷贝物理页面的呢？</p>
<h2 id="写共享物理页"><a href="#写共享物理页" class="headerlink" title="写共享物理页"></a>写共享物理页</h2><p>当父进程A或子进程B任何一方对这些已共享的物理页面执行写操作时，都会产生页面出错异常（page_fault int14）中断，会将<code>flags &amp; FAULT_FLAG_WRITE</code>，然后通过<code>do_page_fault() -&gt; handle_mm_fault() -&gt; handle_pte_fault()</code>调用链解决这个异常。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">vm_fault_t</span> <span class="title function_">handle_pte_fault</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (vmf-&gt;flags &amp; FAULT_FLAG_WRITE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pte_write(entry))</span><br><span class="line">            <span class="keyword">return</span> do_wp_page(vmf);</span><br><span class="line">        entry = pte_mkdirty(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pte_write会根据pte_flags(pte) &amp; _PAGE_RW判断页是否有写保护，这个标记是之前fork时clear掉的，所以会接着调用<code>do_wp_page</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This routine handles present pages, when users try to write</span></span><br><span class="line"><span class="comment"> * to a shared page. It is done by copying the page to a new address</span></span><br><span class="line"><span class="comment"> * and decrementing the shared-page counter for the old page.</span></span><br><span class="line"><span class="comment"> * 当用户试图写入共享页面时，此例程处理当前页面。将页面复制到一个新地址并减少旧页面的共享页面计数器。</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">vm_fault_t</span> <span class="title function_">do_wp_page</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span></span><br><span class="line">    __<span class="title function_">releases</span><span class="params">(vmf-&gt;ptl)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> wp_page_copy(vmf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Handle the case of a page which we actually need to copy to a new page.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Called with mmap_sem locked and the old page referenced, but</span></span><br><span class="line"><span class="comment"> * without the ptl held.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * High level logic flow:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - Allocate a page, copy the content of the old page to the new one.</span></span><br><span class="line"><span class="comment"> * - Handle book keeping and accounting - cgroups, mmu-notifiers, etc.</span></span><br><span class="line"><span class="comment"> * - Take the PTL. If the pte changed, bail out and release the allocated page</span></span><br><span class="line"><span class="comment"> * - If the pte is still the way we remember it, update the page table and all</span></span><br><span class="line"><span class="comment"> *   relevant references. This includes dropping the reference the page-table</span></span><br><span class="line"><span class="comment"> *   held to the old page, as well as updating the rmap.</span></span><br><span class="line"><span class="comment"> * - In any case, unlock the PTL and drop the reference we took to the old page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">vm_fault_t</span> <span class="title function_">wp_page_copy</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span></span><br></pre></td></tr></table></figure>

<p>wp_page_copy函数就不具体分析了，主要就是分配一个页面，将旧页面的内容复制到新页面。</p>
<p>至此，父进程子进程各自拥有一块内容相同的物理页面。最后，从异常处理函数中返回时，CPU就会重新执行刚才导致异常的写入操作指令，使进程继续执行下去。</p>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>CopyOnWrite</tag>
        <tag>写时拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>深入剖析Linux和Docker容器的buffered机制</title>
    <url>/posts/679e/</url>
    <content><![CDATA[<p>最近在查证一个生产环境上Pod数据打点没有被记录到ES的问题，起初怀疑是Docker容器的输出缓冲区问题导致打点输出还没有写入日志文件上，所以查了很多关于python输出缓冲、标准输入输出缓冲、容器日志缓冲相关的知识。尽管最后问题定位到了并不是因为输出缓冲引起的，但是还是在此记录下经过一些测试以及资料阅读了解到的Linux下I/O的buffer机制。不想看验证过程的老铁们可以查看<a href="#%E7%BB%93%E8%AE%BA">结论</a>。</p>
<span id="more"></span>

<h2 id="Linux下的三种缓冲模式"><a href="#Linux下的三种缓冲模式" class="headerlink" title="Linux下的三种缓冲模式"></a>Linux下的三种缓冲模式</h2><ul>
<li>unbuffered: 顾名思义，不缓冲输入输出，有多少读写多少</li>
<li>fully-buffered: 当缓冲区被填满时，发生一次flush</li>
<li>line-buffered: 遇到换行(一般就是’\n’)或者当缓冲区满时，发生一次flush</li>
</ul>
<p>那每种模式对应哪些场景呢？接下来我们用python程序做一些验证。</p>
<h2 id="不同缓冲模式下的一些测试"><a href="#不同缓冲模式下的一些测试" class="headerlink" title="不同缓冲模式下的一些测试"></a>不同缓冲模式下的一些测试</h2><h3 id="与终端相关联的stdin-stdout"><a href="#与终端相关联的stdin-stdout" class="headerlink" title="与终端相关联的stdin/stdout"></a>与终端相关联的<code>stdin/stdout</code></h3><p><a href="https://www.zhihu.com/question/65280843">什么是终端？</a>。简单来说可以是本地打开terminal/xTerm<br>，或者ssh连接远程主机。</p>
<p>有下面一小段代码，执行后会发生什么呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sys.stdout.write(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>执行<code>python test1.py</code>，可以发现，终端半天没有输出一个<code>.</code>。而如果改为<code>.\n</code>或者改为<code>print(&quot;.&quot;)</code>，会每隔1s输出一个<code>.</code>，但是如果改为<code>print(&quot;.&quot;, end=&quot;&quot;)</code>，则不会输出<code>.</code>。所以推断，此时缓冲模式为<code>line-buffered</code>。</p>
<h3 id="不与终端相关联的stdin-stdout"><a href="#不与终端相关联的stdin-stdout" class="headerlink" title="不与终端相关联的stdin/stdout"></a>不与终端相关联的<code>stdin/stdout</code></h3><p>什么是不与终端相关联呢？例如pipe，redirect，fopen 打开的文件。</p>
<p>同样是上面一段代码，如果执行<code>python test2.py &gt; test2.log</code>(redirect模式)，在另一个终端查看文件，并没有发现test2.log随着时间增大。如果将代码改为如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sys.stdout.write(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line">    <span class="comment"># or</span></span><br><span class="line">    <span class="comment"># print(&quot;.&quot;, flush=True)</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到文件随着时间增大，所以此处<code>flush</code>用途与C语言的<code>fflush</code>相同，即将缓冲区输出。推断此时缓冲模式为<code>fully-buffered</code>。</p>
<h3 id="stderr的缓冲模式"><a href="#stderr的缓冲模式" class="headerlink" title="stderr的缓冲模式"></a>stderr的缓冲模式</h3><p>在Linux上，stderr通常是<code>unbuffered</code>的，这是为了可以及时输出错误的信息。</p>
<p>但是stderr可能在python2/3上有不同的表现，例如下面一段代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sys.stderr.write(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>首先执行<code>python3 test3.py</code>，发现并没有立即看到输出，而加上换行后又可以看到输出，所以在python3的实现中，stderr为<code>line-buffered</code>。</p>
<p>然后执行<code>python2.7 test3.py</code>，可以立即看到输出，所以stderr在python2中为<code>unbuffered</code>。</p>
<h3 id="看一个跟pipe相关的问题"><a href="#看一个跟pipe相关的问题" class="headerlink" title="看一个跟pipe相关的问题"></a>看一个跟pipe相关的问题</h3><p>logfile有如下内容</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>

<p>当我们执行<code>tail -f logfile | grep &quot;foo&quot; | awk &#39;&#123;print $1&#125;&#39;</code>，并没有看到期望的输出。这是为何？</p>
<p>tail的stdout buffer默认会做<code>fully-buffered</code>，由于加上了-f，表示会对输出流进行flush，所以tail -f这部分没什么问题。awk的stdout buffer跟终端相关联，所以默认是<code>line-buffered</code>。关键在grep的stdout buffer，它是<code>fully-buffered</code>，要等该buffer满了之后awk才会接收到数据。怎么解决这个问题呢？其实grep提供了<code>--line-buffered</code>。</p>
<p>除了grep，sed也有对应的<code>-u(–unbuffered)</code>，awk有<code>-W</code>选项，tcpdump有<code>-l</code>选项来将fully-buffered变成line-buffered或者unbuffered。</p>
<h2 id="Docker日志相关知识"><a href="#Docker日志相关知识" class="headerlink" title="Docker日志相关知识"></a>Docker日志相关知识</h2><p>上面一节我们介绍了不同流的缓冲机制，那你有没有想过，当执行<code>docker logs</code>时，输出是如何显示的？是否能立刻看到容器内进程的stdout呢？容器的stream是否也有有它自己的缓存呢？我们通过下面一段代码验证</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cat test.py</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sys.stdout.write(datetime.datetime.now().isoformat())</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>执行<code>docker run -d --rm -v $(pwd):/app -w /app --lo g-driver json-file --name test_logs python python test.py</code></p>
<p>按照我们上面说到的知识，我们预期此时执行<code>docker logs -f test_logs</code>可以每隔1s看到一次时间输出。但是如果你执行这个命令会发现并没有预期的输出。但是我们attach到容器却可以发现时间输出。</p>
<p><strong><em>所以我们推断，<code>docker logs</code>本身也有它的输出缓冲区</em></strong>，那么<code>docker logs</code>显示的数据到底是从何而来的呢？</p>
<h3 id="docker-logs机制"><a href="#docker-logs机制" class="headerlink" title="docker logs机制"></a>docker logs机制</h3><p>我们先来看一段<a href="https://docs.docker.com/config/containers/logging/">官网</a>上对<code>docker logs</code>的解释</p>
<p>The <code>docker logs</code> command batch-retrieves logs present at the time of execution.</p>
<p>意思是：<code>docker logs</code>命令批量检索执行时出现的日志。</p>
<p>那我不禁要问了，这个日志是哪来的呢？别急我们继续看，官网上罗列了一些支持的<a href="https://docs.docker.com/config/containers/logging/configure/">logging drivers</a>，默认使用的是<code>json-file</code> driver。并且除了<code>json-file</code>和<code>journald</code>之外，<code>docker logs</code>命令对其他驱driver不可用。</p>
<p>所以如果使用了json-file driver，Docker daemon会在container启动的时候创建一个<code>container.ID-json.log</code>文件，用于写入此container相关进程的STDOUT，见下面一段源码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> cfg.Type &#123;</span><br><span class="line"><span class="keyword">case</span> jsonfilelog.Name:</span><br><span class="line">    info.LogPath, err = container.GetRootResourcePath(fmt.Sprintf(<span class="string">&quot;%s-json.log&quot;</span>, container.ID))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    container.LogPath = info.LogPath</span><br></pre></td></tr></table></figure>

<p><a href="https://cloud.tencent.com/developer/article/1140079">这篇文章</a>有对logging-driver更详细的源码级分析。</p>
<p>下面一些截图是对上面文章的实践分析</p>
<p><code>ps -ef</code>查看container内进程与<code>docker daemon</code>的关系，可以发现容器内的进程是fork的docker守护进程。</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/buffered_io_docker_process.png"></p>
<p>docker daemon进程的fd，可以发现容器进程的stdout和stderr映射到了daemon进程的文件描述符。</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/buffered_io_docker_d_fd.png"></p>
<blockquote>
<p>Tips: 根据<a href="https://github.com/moby/moby/blob/master/container/container.go#L619">源码</a>，只有容器启动进程的输出才会被写入日志，也就是上图的*init-*。换个角度说，docker exec进入容器再创建别的线程(e.g <code>sh -c &quot;while true; do echo test; sleep 1; done&quot;</code>)的输出，是<em>不会</em>被写入日志的。</p>
</blockquote>
<h3 id="docker-logs怎么读入文件"><a href="#docker-logs怎么读入文件" class="headerlink" title="docker logs怎么读入文件"></a>docker logs怎么读入文件</h3><p>由于笔者也没使用过go语言，所以只能通过源码看个大概，下面我们通过源码一步步剖析这条语句是怎么从<code>*-json.log</code>中读入日志并显示的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">file: daemon/logs.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span></span> ContainerLogs(ctx context.Context, containerName <span class="type">string</span>, config *types.ContainerLogsOptions) (messages &lt;-<span class="keyword">chan</span> *backend.LogMessage, isTTY <span class="type">bool</span>, retErr <span class="type">error</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        cLog, cLogCreated, err := daemon.getLogger(container) <span class="comment">// 会获取container的LogDriver(在container初始化的时候定义了一个默认的json-file logger)</span></span><br><span class="line">        ...</span><br><span class="line">        logReader, ok := cLog.(logger.LogReader)    <span class="comment">//这里LogReader是一个interface，如果container的log driver没有实现这个接口，则会报错ErrReadLogsNotSupported</span></span><br><span class="line">        ...</span><br><span class="line">        logs := logReader.ReadLogs(readConfig)  <span class="comment">//默认会调用JSONFileLogger的ReadLogs方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file: daemon/logger/jsonfilelog/read.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *JSONFileLogger)</span></span> readLogs(watcher *logger.LogWatcher, config logger.ReadConfig) &#123;</span><br><span class="line">        ...</span><br><span class="line">        l.writer.ReadLogs(config, watcher)  <span class="comment">// writer是在logger注册的时候初始化的，下面会解释</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file: daemon/logger/jsonfilelog/jsonfilelog.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := logger.RegisterLogDriver(Name, New); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                logrus.Fatal(err)</span><br><span class="line">        &#125;   <span class="comment">// 注册到工厂，container StartLogger的时候会调用New方法</span></span><br><span class="line">        <span class="keyword">if</span> err := logger.RegisterLogOptValidator(Name, ValidateLogOpt); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                logrus.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(info logger.Info)</span></span> (logger.Logger, <span class="type">error</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        writer, err := loggerutils.NewLogFile(info.LogPath, capval, maxFiles, compress, marshalFunc, decodeFunc, <span class="number">0640</span>, getTailReader)   <span class="comment">// 这里的LogPath就是上面生成的路径</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &amp;JSONFileLogger&#123;</span><br><span class="line">                writer:  writer,</span><br><span class="line">                readers: <span class="built_in">make</span>(<span class="keyword">map</span>[*logger.LogWatcher]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">                tag:     tag,</span><br><span class="line">        &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file: daemon/logger/loggerutils/logfile.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *LogFile)</span></span> ReadLogs(config logger.ReadConfig, watcher *logger.LogWatcher) &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;   <span class="comment">// 上面l.writer.ReadLogs实际调用的就是这个方法</span></span><br></pre></td></tr></table></figure>

<h3 id="何时写入json-file？"><a href="#何时写入json-file？" class="headerlink" title="何时写入json-file？"></a>何时写入json-file？</h3><p>上一节我们从源码级别剖析了<code>docker logs</code>的traceback，那回到本节刚开始的问题，为什么没有看到任何输出？而cat该进程的stdout文件描述符却能看到输出？通过上面一部分我们可以推断一定是输出没有被写入到json-file中，我们如法炮制，看看源码吧</p>
<p>我们看到copier.go文件的<a href="https://github.com/moby/moby/blob/master/daemon/logger/copier.go#L21">第21行</a>, <a href="https://github.com/moby/moby/blob/master/daemon/logger/copier.go#L99">第99行</a>和<a href="https://github.com/moby/moby/blob/master/daemon/logger/copier.go#L133">第133行</a>，有如下发现</p>
<ol>
<li>每个容器都为stdout/stderr分配了一个16K的日志读缓冲区</li>
<li>遇到换行会将缓冲区换行前的数据格式化并写入日志文件</li>
<li>缓冲区满会将数据格式化并写入日志文件</li>
</ol>
<p>读到这终于恍然大悟了，由于本节开始的那一段代码并没有输出换行，所以copier要等到缓冲区满之后才会将输出写入日志文件。如果在输出时间后加一句<code>sys.stdout.write(&quot;\n&quot;)</code>，就会实时的看到输出啦！</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><em>Linux下Buffered IO规则：</em></p>
<ol>
<li>stdin/stdout stream如果不与终端相关联，比如pipe/redirect，则是<code>fully-buffered</code>；反之为<code>line-buffered</code>。</li>
<li>stderr是unbuffered。</li>
</ol>
<p><em>Python 2和3对于sys.stderr的处理不同，2是<code>unbuffered</code>，3是<code>line-buffered</code></em></p>
<p><em><code>docker logs</code>显示的数据是一定已经写入json-file了</em></p>
<p><em><code>docker daemon</code>将stream的输出写入日志文件有如下两种情况</em></p>
<ol>
<li>遇到换行</li>
<li>16K stream buffer写满</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://stackoverflow.com/questions/39536212/what-are-the-rules-of-automatic-flushing-stdout-buffer-in-c">https://stackoverflow.com/questions/39536212/what-are-the-rules-of-automatic-flushing-stdout-buffer-in-c</a></li>
<li><a href="http://jaseywang.me/2015/04/01/stdio-%E7%9A%84-buffer-%E9%97%AE%E9%A2%98/">http://jaseywang.me/2015/04/01/stdio-%E7%9A%84-buffer-%E9%97%AE%E9%A2%98/</a></li>
<li><a href="https://docs.docker.com/config/containers/logging/configure/">https://docs.docker.com/config/containers/logging/configure/</a></li>
<li><a href="https://github.com/moby/moby">https://github.com/moby/moby</a></li>
</ul>
]]></content>
      <categories>
        <category>基础知识</category>
        <category>操作系统</category>
        <category>云原生</category>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Buffered I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解MySQL——MDL</title>
    <url>/posts/57f6/</url>
    <content><![CDATA[<p>在MySQL使用过程中，不免有对表进行更改的<code>DDL</code>操作(alter/drop table)。有的时候我们会发现，一条简单的对表增加字段的操作，会执行很长时间，甚至导致整个数据库挂掉。这是为什么呢？本篇文章就来揭开其中奥秘。</p>
<span id="more"></span>

<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>试想有如下2个session</p>
<table>
<thead>
<tr>
<th align="center">session1</th>
<th align="center">session2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BEGIN</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">SELECT * FROM XXX</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">DROP TABLE XXX</td>
</tr>
<tr>
<td align="center">SELECT * FROM XXX</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>如果DROP TABLE成功执行了，那会话1的第二个select会出错，这明显不是我们想要的结果。所以为了避免此类问题，MySQL5.5版本加入了MDL(Metadata Lock)，当对一个表做CRUD操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</p>
<ul>
<li>读锁之间不互斥，因此可以有多个线程同时对一张表增删改查。</li>
<li>读写锁之间、写锁之间互斥，用来保证变更结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li>
</ul>
<h2 id="采坑实战"><a href="#采坑实战" class="headerlink" title="采坑实战"></a>采坑实战</h2><p>虽然MDL锁是MySQL Server层默认加的，但是却不能忽略这个机制。下面这个例子，我们将会看到MDL锁的威力</p>
<table>
<thead>
<tr>
<th align="center">session1</th>
<th align="center">session2</th>
<th align="center">session3</th>
<th align="center">session4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">select * from user limit 1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select * from user limit 1</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">alter table user add address varchar(32)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">select * from user limit 1</td>
</tr>
</tbody></table>
<p>session1启动，这里我们显示的启动事务，select语句会对user表加MDL读锁。而session2需要的也是MDL读锁，所以可以正常执行。</p>
<p>之后session3需要对表进行DDL操作，请求MDL写锁，但是session1的事务还没有提交，MDL读锁并没有释放，所以被阻塞。</p>
<p>最可怕的是，在session3之后的读请求都会被阻塞，也就是说user表现在完全不可以读写了。你们可能会问，session3也并没有拿到写锁啊，为什么会阻塞后面的读请求呢？这里读者猜想，应该是MySQL内部维护了一个MDL队列，避免MDL写锁一致请求不到。</p>
<p>如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session再请求的话，这个库的线程很快就会爆满。</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20181203221423.png"></p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20181203221700.png"></p>
<h2 id="另一个坑"><a href="#另一个坑" class="headerlink" title="另一个坑"></a>另一个坑</h2><p>上一节我们知道，如果一个事务没有提交，会阻塞后面的DDL操作。那么，是不是我们执行<code>select * from information_schema.innodb_trx</code>查询不到正在执行的事务，就不会出现MDL阻塞的情况了呢?</p>
<p>我们来看下面的例子，查询一个不存在的列</p>
<table>
<thead>
<tr>
<th align="center">session1</th>
<th align="center">session2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">select unknown from user;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">alter table user add column address varchar(20)</td>
</tr>
</tbody></table>
<p>我们发现，session2阻塞，等待获取MDL写锁。查看正在运行的事务，发现并没有事务在运行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_trx\G;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>因为<code>information_schema.innodb_trx</code>中<strong>不会记录</strong>执行失败的事务，但是在这个执行失败的事务回滚前，它依然持有MDL，所以DDL操作依然会被阻塞。</p>
<p>这个时候我们可以通过查找<code>performance_schema.events_statements_current</code>表来找到相关的语句和会话信息</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20181203220937.png"></p>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>当我们对一张表指定DDL操作时，如果执行时间过长，我们就需要警惕了，此时很有可能这张表上出现了长事务或者没有提交的事务。我们可以通过以下步骤依次排查解决</p>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">SQL</th>
<th align="center">原因</th>
<th align="center">处理</th>
</tr>
</thead>
<tbody><tr>
<td align="center">查看当前是否有正在执行的长事务或者未提交的事务</td>
<td align="center">select * from information_schema.innodb_trx\G</td>
<td align="center">显示(begin;)或者隐式(set autocommit=0)开启事务后未提交或回滚，MDL读锁未释放</td>
<td align="center">暂停DDL或者kill掉事务</td>
</tr>
<tr>
<td align="center">查看是否有执行失败的事务</td>
<td align="center">select <em>from performance_schema.events_statements_current\G  select</em> from performance_schema.threads where thread_id=xx\G</td>
<td align="center">表上有失败的查询事务，比如查询不存在的列，语句失败返回，但是事务没有提交</td>
<td align="center">kill掉</td>
</tr>
</tbody></table>
<h2 id="如何预防"><a href="#如何预防" class="headerlink" title="如何预防"></a>如何预防</h2><p>上一节讲到了如何解决MDL写锁等待超长的情况。我们知道DDL阻塞会影响后面正常的读写操作，这对一些业务场景来说是完全不可以接受的。所以有些时候我们在执行DDL操作之前，可以执行以下操作检查</p>
<ol>
<li>检查是否有长事务或者失败的事务未提交，如果有可以等待一段时间再执行</li>
<li>通过设置session的<code>lock_wait_timeout</code>，指定MDL锁等待时间，如果在这个指定的等待时间里面拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>长事务危害多多，业务中尽量少用。</li>
<li>即使没有显示的启动事务，也需要检查一下autocommit的值。</li>
<li>DDL操作之前先检查innodb_trx</li>
<li>通过<code>set lock_wait_timeout</code>设置session的MDL等待时间。</li>
</ol>
]]></content>
      <categories>
        <category>后端技能</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解MySQL——MySQL选错索引怎么办</title>
    <url>/posts/83c6/</url>
    <content><![CDATA[<p>最近线上的一个张表频繁的报慢查询告警，看了下日志发现一条语句执行要几秒钟，这还是在用了LIMIT的前提下，导致相关接口超时，一个功能对数据量大的用户完全不可用。COUNT了下这张表，一共有400多万的数据，EXPLAIN了慢日志SQL，发现走的索引并不是按照预期的更快的那一个，并且由于分段查询产生了filesort。那么MySQL选错索引的原因是什么呢？这个SQL有没有优化的空间呢？优化的效果如何呢？</p>
<span id="more"></span>

<h2 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h2><p>为了脱敏，我们先建一张与线上数据结构相同的表t，这张表有两个联合索引，其中一个为唯一索引，另一个为普通索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `group_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_t_user_id_group_id_a` (`user_id`,`group_id`,`a`),</span><br><span class="line">  KEY `idx_t_user_id_group_id_b` (`user_id`,`group_id`,`b`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>

<p>然后我们执行如下存储过程，这里构造了300万条数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span></span><br><span class="line">    definer <span class="operator">=</span> root@`<span class="operator">%</span>` <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> user_id <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">declare</span> group_id <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">declare</span> a <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">declare</span> b <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">set</span> group_id<span class="operator">=</span><span class="number">50</span>;</span><br><span class="line">    <span class="keyword">start</span> transaction;</span><br><span class="line">        while(group_id<span class="operator">&gt;</span><span class="number">0</span>)do   # 这边调换插入顺序为了增加回聚簇索引的随机IO成本，让走错索引耗时更长，尽量模拟线上环境</span><br><span class="line">            <span class="keyword">set</span> user_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            while(user_id<span class="operator">&lt;=</span><span class="number">20</span>)do</span><br><span class="line">                <span class="keyword">set</span> a<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">                while(a<span class="operator">&lt;=</span><span class="number">3000</span>)do</span><br><span class="line">                    <span class="keyword">set</span> b <span class="operator">=</span> a <span class="operator">%</span> <span class="number">30</span>;</span><br><span class="line">                    <span class="keyword">insert</span> <span class="keyword">into</span> t(user_id, group_id, a, b) <span class="keyword">values</span>(user_id, group_id, a, b);</span><br><span class="line">                    <span class="keyword">set</span> a<span class="operator">=</span>a<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span> while ;</span><br><span class="line">                <span class="keyword">set</span> user_id<span class="operator">=</span>user_id<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span> while ;</span><br><span class="line">            <span class="keyword">set</span> group_id<span class="operator">=</span>group_id<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">end</span> while ;</span><br><span class="line">    <span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>

<p>然后模拟线上的查询语句，这个语句在业务中的功能大致是：找到指定用户所有分组下不同的a对应的b的最大值，同时使用了分段查询，根据id排序，每次迭代1000条到内存中筛选最大值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">root<span class="variable">@localhost</span>:test<span class="operator">&gt;</span> <span class="keyword">select</span> id, user_id, group_id, a, b <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">and</span> user_id<span class="operator">=</span><span class="number">3</span> <span class="keyword">and</span> group_id <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, ..., <span class="number">50</span>) <span class="keyword">and</span> b <span class="operator">&gt;=</span> <span class="number">16</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">asc</span> limit <span class="number">1000</span> <span class="keyword">offset</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">1000</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span></span><br><span class="line"><span class="type">Time</span>: <span class="number">7.887</span>s</span><br></pre></td></tr></table></figure>

<p>我们看到这里一条语句耗时8s左右。在查看执行计划之前，我猜测这条语句会走<code>idx_t_user_id_group_id_b</code>索引，因为可以利用索引下推，将<code>b&gt;=16</code>这个条件判断交给引擎层，这样可以返回更少的id记录给服务层，就可以减少回聚簇索引的次数。</p>
<p>下面我们看下这条语句的执行计划，发现并没有按照我们的预期，而是走了唯一索引，这是为什么呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>[ <span class="number">1.</span> <span class="type">row</span> ]<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">id            <span class="operator">|</span> <span class="number">1</span></span><br><span class="line">select_type   <span class="operator">|</span> SIMPLE</span><br><span class="line"><span class="keyword">table</span>         <span class="operator">|</span> t</span><br><span class="line">type          <span class="operator">|</span> <span class="keyword">range</span></span><br><span class="line">possible_keys <span class="operator">|</span> <span class="keyword">PRIMARY</span>,uk_t_user_id_group_id_a,idx_t_user_id_group_id_b</span><br><span class="line">key           <span class="operator">|</span> uk_t_user_id_group_id_a</span><br><span class="line">key_len       <span class="operator">|</span> <span class="number">12</span></span><br><span class="line"><span class="keyword">ref</span>           <span class="operator">|</span> <span class="operator">&lt;</span><span class="keyword">null</span><span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">rows</span>          <span class="operator">|</span> <span class="number">13650</span></span><br><span class="line">Extra         <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span>; <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> MRR; <span class="keyword">Using</span> filesort</span><br></pre></td></tr></table></figure>

<h2 id="根据执行计划信息推断数据库查询过程"><a href="#根据执行计划信息推断数据库查询过程" class="headerlink" title="根据执行计划信息推断数据库查询过程"></a>根据执行计划信息推断数据库查询过程</h2><p>我们先不分析为什么MySQL没有选择<code>idx_t_user_id_group_id_b</code>索引，先来根据执行计划推断下MySQL内部是怎么执行这条SQL的</p>
<ol>
<li><p>根据user_id和group_id查询条件，到引擎层根据<code>uk_t_user_id_group_id_a</code>索引查询满足条件的行，命中索引的前两个字段，key_len为12也对的上</p>
</li>
<li><p>引擎层每查询到一行满足条件的索引记录，就返回一条给服务层，服务层根据剩下的查询条件，也就是<code>b&gt;=16</code>，做数据过滤</p>
</li>
<li><p>服务层根据过滤后记录中的主键id，到聚簇索引中查询完整数据。</p>
<blockquote>
<p>注意：这里存在一个优化，根据执行计划，Extra中有个叫MRR的策略，为什么会出现这个呢？因为我们在插入数据时故意让group_id递减，这导致根据<code>uk_t_user_id_group_id_a</code>索引查到的id不是顺序的，这样回表就会出现随机访问，性能相对较差。</p>
</blockquote>
</li>
</ol>
<p>  <strong>MRR全称Multi-Range Read，这个优化的目的是尽量使用顺序读盘。由于使用了MRR，所以服务层不会拿到一个id就回表查询，而是将id值放入<code>read_rnd_buffer</code>中，直到buffer放满然后对id进行递增排序，排序后的id数组依次到聚簇索引中查询，取出结果。</strong></p>
<ol start="4">
<li>上一步取出的结果还不能直接返回给客户端，还要对记录根据id排序。排序分以下两种，显然MySQL选择了第一种<ol>
<li>全字段排序：将select的字段以及order by的字段存入sort_buffer，对sort_buffer中的数据按照id进行快速排序，如果sort_buffer无法一次性存下所有数据，则需要借助临时文件辅助归并排序，sort_buffer的大小由sort_buffer_size控制</li>
<li>rowid排序：如果一条待排序数据字段数太多，就有可能造成sort_buffer中同时能够存放的行数很少，需要临时文件就更多，排序性能会很差。所以如果单行很大（根据<code>max_length_for_sort_data</code>判断，默认1024字节），只会将order by字段以及主键放入sort_buffer，排序后取前1000行，然后按照id的值回表取出select的字段</li>
</ol>
</li>
</ol>
<h2 id="MySQL优化器选择索引的原则"><a href="#MySQL优化器选择索引的原则" class="headerlink" title="MySQL优化器选择索引的原则"></a>MySQL优化器选择索引的原则</h2><p>上面我们分析了走<code>uk_t_user_id_group_id_a</code>索引的查询过程，不难发现这样会导致回表的次数比较多，因为<code>b&gt;=16</code>这个条件是在服务层判断的，而如果走<code>idx_t_user_id_group_id_b</code>索引，是可以直接在第一步就把不满足这个条件的数据过滤掉的，少了很多不必要的回表查询。那么为什么优化器放着更高效的索引不走，而选择了另外的索引呢？</p>
<h3 id="优化器的逻辑"><a href="#优化器的逻辑" class="headerlink" title="优化器的逻辑"></a>优化器的逻辑</h3><p>优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。当然，扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。我们这个查询不管走哪个索引都难免要排序，所以 MySQL 选错索引肯定是在判断扫描行数的时候出问题了。那么，问题就是：扫描行数是怎么判断的？</p>
<h3 id="索引的基数怎么算的"><a href="#索引的基数怎么算的" class="headerlink" title="索引的基数怎么算的"></a>索引的基数怎么算的</h3><p>索引的基数，通俗来讲就是索引的区分度，一个索引上不同的值越多，这个索引的区分度就越好。</p>
<p>准确的计算公式为 <code>COUNT(DISTINCT(field)) / COUNT(field)</code>，当然MySQL不可能通过这种方式统计基数，因为这样要扫描所有的数据页代价太高了。所以只能选择采样统计，InnoDB默认会选择N个数据也，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。而由于是采样统计，所以这个基数是很容易出现偏差的。</p>
<h3 id="EXPLAIN中的扫描行数rows如何估算的"><a href="#EXPLAIN中的扫描行数rows如何估算的" class="headerlink" title="EXPLAIN中的扫描行数rows如何估算的"></a>EXPLAIN中的扫描行数rows如何估算的</h3><p>首先找到第一个记录所在的page，记为<code>page_left</code>，统计<code>page_left</code>里的记录数，记为<code>records_page_left</code>，然后找到最后一个记录所在的page，记为<code>page_right</code>，统计<code>page_right</code>里的记录数，记为<code>records_page_right</code>，除了两个边界外，还沿着page_left往右连续查找8个page，最后按照如下公式计算</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">rows = (records_page_left + records_page_1 + records_page_2 + ... + records_page_8 + records_page_right) / 10 * page_number</span><br></pre></td></tr></table></figure>

<p>根据公式我们可以得出以下结论</p>
<ol>
<li>如果满足条件的总的page数目&lt;=10，那么预估的rows和真实的rows一致</li>
<li>索引的非顺序插入、频繁删除等操作会导致页分裂和数据不均，就会导致统计信息比实际数据少很多</li>
</ol>
<h2 id="选错索引了怎么办"><a href="#选错索引了怎么办" class="headerlink" title="选错索引了怎么办"></a>选错索引了怎么办</h2><p>其实大多数时候优化器都能找到正确的索引，但是偶尔还是会碰到扫描行数估算错误导致原本可以执行很快的语句，却比预想的慢得多。那此时应该怎么办呢？</p>
<ol>
<li>由于索引统计信息不准确导致的问题，可以用<code>analyze table</code>来解决，注意这个命令是<em>不需要MDL锁</em>的</li>
<li>采用force index强制选择一个索引。但是很多人不喜欢用这种语法，一来这种hard code不太优美，二来如果索引改了名字或被删除了，容易忘记更改代码</li>
<li>新建一个更合适的索引或删除误用的索引，帮助优化器作出正确的选择</li>
</ol>
<h2 id="SQL优化方向"><a href="#SQL优化方向" class="headerlink" title="SQL优化方向"></a>SQL优化方向</h2><p>上面几节我们分析了MySQL为什么没有走我们预期的索引。那么针对文章开始提到的SQL，我们有哪些优化手段呢？</p>
<ul>
<li><p>强制走预期索引：强制走<code>idx_t_user_id_group_id_b</code>索引，这样可以利用索引下推将<code>b &gt;= 16</code>这个条件下推到引擎层来判断，减少回表的次数</p>
</li>
<li><p>只查询需要的字段：只select a, b两个字段，可以减少单行占用空间，sort_buffer_size不变的情况下单次可以排序更多的数据行，减少了文件排序的次数</p>
</li>
<li><p>降低filesort成本，或去除filesort：代码中为了防止一次查询太多数据把pod的内存打爆，所以采用了根据id排序然后分段取的机制。但是仔细分析下来，这个场景是不需要担心这个问题的，原因如下</p>
<ul>
<li><p>MySQL取数据和发数据的流程如下，所以如果客户端没有及时的读取数据，服务器是会暂停数据查询及发送的</p>
<ol>
<li>获取一行，写到net_buffer中，这块内存的大小是由参数<code>net_buffer_length</code>定义的，默认是16k</li>
<li>重复获取行，制动net_buffer写满，调用网络接口发出去</li>
<li>如果发送成功，就清空net_buffer，然后继续取下一行，并写入net_buffer</li>
<li>如果发送函数返回 EAGAIN 或 WSAEWOULDBLOCK，就表示本地网络栈(socket send buffer)写满了，进入等待。知道网络栈重新可写，再继续发送</li>
</ol>
</li>
<li><p>一些ORM会缓存查询的返回数据，为了更高效的进行多次迭代、index等操作，但是应该也提供了可以关闭缓存的查询函数或配置(例如笔者使用的peewee)</p>
</li>
<li><p>业务场景上，我们只需要计算每个a对应的最大的b值，所以只会遍历所有数据，用一个字典存储a和b，不会占用太多pod内存</p>
</li>
</ul>
</li>
</ul>
<h2 id="peewee相关采坑"><a href="#peewee相关采坑" class="headerlink" title="peewee相关采坑"></a>peewee相关采坑</h2><p>如果你刚好用的<code>python+peewee</code>技术栈，那么这节有我实践的一些采坑记录，可以供你参考。</p>
<ul>
<li><p>如何指定索引：peewee不支持<code>USE INDEX</code>语法，只能利用<code>model.alias</code> + <code>from_</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alias_name = <span class="string">&quot;tbl&quot;</span></span><br><span class="line">alias_model = Model.alias(alias_name)</span><br><span class="line">table_name = Model._meta.table_name</span><br><span class="line">index_name = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">from_source = <span class="string">&quot;%s AS %s USE INDEX (%s)&quot;</span> % (table_name, alias_name, index_name)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> alias_model.select(xxx).from_(peewee.SQL(from_source)).where(xxx).iterator():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>MySQLdb或pymysql这些driver是不缓存数据行，但是peewee默认会缓存读取的数据：如果用<code>for row in query</code>这种遍历方法，会缓存每行数据，如果确认只会遍历一遍查询，可以使用<code>for row in query.iterator()</code>关闭缓存</p>
</li>
<li><p>使用model_alias查询，导致构造Model对象耗时太久：Model.select会使用ModelObjectCursorWrapper将返回的每行数据构造成model对象，默认情况下是不会在构造时调用<code>get_default_dict</code>方法的，但是由于使用了alias导致在<code>__init__</code>时调用了该方法（具体原因可以看源码），如果字段的default属性有耗时的操作（例如globalid生成），那么会有大量的时间浪费对象构造上。</p>
</li>
</ul>
<h2 id="实际效果"><a href="#实际效果" class="headerlink" title="实际效果"></a>实际效果</h2><p>这里我们直接用python代码实现上述需求，找到指定用户所有分组下不同的a对应的b的最大值</p>
<p>基本模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>(peewee.Model):</span><br><span class="line">    user_id = peewee.BigIntegerField()</span><br><span class="line">    group_id = peewee.IntegerField()</span><br><span class="line">    a = peewee.IntegerField()</span><br><span class="line">    b = peewee.IntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        database = db</span><br></pre></td></tr></table></figure>

<h3 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">iter_model</span>(<span class="params">model, conditions</span>):</span><br><span class="line">    start_id = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        query = (</span><br><span class="line">            model.select()</span><br><span class="line">            .where(model.<span class="built_in">id</span> &gt; start_id, *conditions)</span><br><span class="line">            .order_by(model.<span class="built_in">id</span>.asc())</span><br><span class="line">            .limit(<span class="number">1000</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">list</span>(query):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> query:</span><br><span class="line">            <span class="keyword">if</span> v.<span class="built_in">id</span> &gt; start_id:</span><br><span class="line">                start_id = v.<span class="built_in">id</span></span><br><span class="line">            <span class="keyword">yield</span> v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_mapping</span>():</span><br><span class="line">    mapping = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> iter_model(</span><br><span class="line">        T, [T.user_id == <span class="number">3</span>, T.group_id.in_([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">51</span>)]), T.b &gt;= <span class="number">16</span>]</span><br><span class="line">    ):</span><br><span class="line">        <span class="keyword">if</span> row.b &gt;= mapping[row.a]:</span><br><span class="line">            mapping[row.a] = row.b</span><br><span class="line">    <span class="keyword">return</span> mapping</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    rv = get_mapping_perf()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;cost time: %s&quot;</span> % (time.time() - start))</span><br></pre></td></tr></table></figure>

<p>为避免buffer_pool等缓存影响结果，执行前重启了server。执行三次，结果分别为 <code>11.72s</code>, <code>10.11s</code>, <code>10.16s</code>。</p>
<h3 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_mapping_perf</span>():</span><br><span class="line">    mapping = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    alias_name = <span class="string">&quot;tbl&quot;</span></span><br><span class="line">    alias_model = T.alias(alias_name)</span><br><span class="line">    table_name = T._meta.table_name</span><br><span class="line">    index_name = <span class="string">&quot;idx_t_user_id_group_id_b&quot;</span></span><br><span class="line">    from_source = <span class="string">&quot;%s AS %s USE INDEX (%s)&quot;</span> % (table_name, alias_name, index_name)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> (</span><br><span class="line">        alias_model.select(alias_model.a, alias_model.b)</span><br><span class="line">        .from_(peewee.SQL(from_source))</span><br><span class="line">        .where(</span><br><span class="line">            alias_model.user_id == <span class="number">3</span>,</span><br><span class="line">            alias_model.group_id.in_([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">51</span>)]),</span><br><span class="line">            alias_model.b &gt;= <span class="number">16</span>,</span><br><span class="line">        )</span><br><span class="line">        .tuples()</span><br><span class="line">        .iterator()</span><br><span class="line">    ):</span><br><span class="line">        a, b = row[<span class="number">0</span>], row[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> b &gt;= mapping[a]:</span><br><span class="line">            mapping[a] = b</span><br><span class="line">    <span class="keyword">return</span> mapping</span><br></pre></td></tr></table></figure>

<p>执行三次，结果分别为 <code>1.70s</code>, <code>1.44s</code>, <code>1.45s</code>。</p>
]]></content>
      <categories>
        <category>后端技能</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>源计划——重启博客</title>
    <url>/posts/f3db/</url>
    <content><![CDATA[<h1 id="博客的新家"><a href="#博客的新家" class="headerlink" title="博客的新家"></a>博客的新家</h1><p>折腾了一个周末，终于把原来博客的老窝翻新了一遍。心里暗自安慰自己，以前好久不写博文就是因为原来的博客样式太丑了，恩，一定是因为这个。</p>
<span id="more"></span>

<p>博客翻新的过程就不在这里赘述了，总的来说就是google几篇<a href="https://hexo.io/zh-cn/docs/">hexo</a>教程，选一个自己喜欢的themes。然后找几个做的比较好的博客，<code>F12</code>看一下源码，照着改一改就好了。</p>
<p>既然有了新家，就应该改头换面，重新。。。奋发图强！所以，我决定即日起，把平常学习、实践的一些总结，记录在博客上，一方面由于我的记性比较差，记录下来可以供自己以后温故知新，另一方面可以给有相同需求/疑问的coder们一点点参考。</p>
<p>希望能通过博客，结实更多的技术大拿。也希望自己可以通过博客给自己的技术多充充电！</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机知识体系总览</title>
    <url>/posts/133f/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="计算机原理"><a href="#计算机原理" class="headerlink" title="计算机原理"></a>计算机原理</h2><h3 id="冯·诺依曼体系结构"><a href="#冯·诺依曼体系结构" class="headerlink" title="冯·诺依曼体系结构"></a>冯·诺依曼体系结构</h3><h3 id="CPU组成"><a href="#CPU组成" class="headerlink" title="CPU组成"></a>CPU组成</h3><ul>
<li>控制单元（Control Unit）：</li>
<li>数据单元</li>
<li>运算单元</li>
</ul>
<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果以及一些CPU运行需要的信息。</p>
<p>下面几个tabs描述了x86-64架构中涉及到的不同类别的寄存器</p>
<div class="tabs" id="寄存器"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#寄存器-1">通用寄存器</button></li><li class="tab"><button type="button" data-href="#寄存器-2">标志寄存器</button></li><li class="tab"><button type="button" data-href="#寄存器-3">指令寄存器</button></li><li class="tab"><button type="button" data-href="#寄存器-4">控制寄存器</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="寄存器-1"><p>通用寄存器是程序执行过程中最常用、最基础的寄存器，大部分时间都是在操作这些寄存器完成指令功能。“通用”指的是这些寄存器没有特殊的用途，可以交给程序<strong>按照一定的规则</strong>（通用不是乱用）去使用。</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>Callee Save</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>%rax(Accumulator)</td>
<td></td>
<td>结果寄存器，通常用执行加法，存储函数调用的返回值，也会用于<code>idiv</code>和<code>imul</code>指令</td>
</tr>
<tr>
<td>%rbx</td>
<td>是</td>
<td>miscellaneous register</td>
</tr>
<tr>
<td>%rdi, %rsi, %rdx, %rcx, %r8, %r9</td>
<td></td>
<td>用作传递整型或指针参数到被调用函数，依次对应第1个参数、第2个参数 …。rdx也会用于<code>idiv</code>和<code>imul</code> 指令</td>
</tr>
<tr>
<td>%rsp(Stack Pointer)</td>
<td></td>
<td>栈指针寄存器，通常会指向栈顶位置，堆栈的pop和push操作就是通过改变rsp的值即移动堆栈指针的位置来实现的</td>
</tr>
<tr>
<td>%rbp(Base Pointer)</td>
<td>是</td>
<td>栈底指针，用于标识当前栈帧的起始位置，通常用rbp+偏移量来存取函数栈中的局部变量</td>
</tr>
<tr>
<td>%r10, %r11</td>
<td></td>
<td>miscellaneous registers</td>
</tr>
<tr>
<td>%r12, %r13, %r14, %r15</td>
<td>是</td>
<td>miscellaneous registers</td>
</tr>
</tbody></table>
<p>从上表我们可以还得出如下结论</p>
<ol>
<li>每个寄存器的用途并不是单一的</li>
<li>在<code>imul</code>指令中，两个64位的乘法最多会产生128位的结果，乘法结果需要<code>%rdx</code>存储高64位<code>%rax</code>存储低64位；在<code>idiv</code>指令中被除数是128位的，同样需要<code>%rax</code>和<code>%rdx</code>共同存储被除数</li>
<li>被标识为”miscellaneous”的寄存器属于通用性更广泛的寄存器，编译器可以根据需要存储任何数据</li>
</ol>
<p><code>Caller Save</code>和<code>Callee Save</code>的区别在于寄存器的值是由<code>调用者负责保存</code>还是<code>被调用者负责保存</code>。当产生函数调用时，子函数内也会使用到通用寄存器进行数据存储，此时这些寄存器中之前保存的父函数的值就会被覆盖。为了避免数据覆盖导致函数返回时寄存器的数据无法恢复，CPU体系结构中就规定了通用寄存器的保存方式。</p>
<p>如果一个寄存器被标识为<code>Caller Save</code>，那么在进行子函数调用前，就需要由调用者提前保存好这些寄存器的值，保存方法通常是把寄存器的值push到堆栈中，调用者保存完成后，在子函数中就可以随意覆盖这些寄存器的值了。如果一个寄存器被标识为<code>Callee Save</code>，那么在函数调用时，调用者就不必保存这些寄存器的值而直接进行子函数调用，进入子函数后，子函数在覆盖这些寄存器之前，需要先保存这些寄存器的值，即这些寄存器的值是由被调用者来保存和恢复的。</p><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="寄存器-2"><p>用里面的一个一个标记bit位，存放CPU进行算术或逻辑计算的结果，这些标志大多由CPU自动设置和修改</p>
<ul>
<li>零标志(Zero Flag)：如果运算结果为0，ZF=1，否则ZF=0</li>
<li>符号标志(Sign Flag)：与运算结果的最高位bit值一致</li>
<li>进位标志(Carry Flag)：在无符号运算时，记录了运算结果的最高有效位向更高位的进位值或从更高位借位，产生进位或借位时CF=1，否则CF=0</li>
<li>溢出标志(Overflow Flag)：有符号运算的结果是否发生了溢出，如果发生溢出OF=1,如果没有OF=0。正数+正数，负数+负数有可能发生溢出；正数-正数不可能发生溢出</li>
<li>奇偶标志(Parity Flag)：如果运算结果bit位中有偶数个1，则其值为1，否则其值为0。此指令主要用于检查数据传输过程中是否产生错误，比如典型的<a href="https://en.wikipedia.org/wiki/Parity_bit">奇偶校验</a></li>
</ul>
<blockquote>
<p>CF和OF的区别：CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位。比如：mov al, $7F; add al $01。add指令执行后CF=0，OF=1。</p>
</blockquote>
<p>举几个🌰</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">              <span class="built_in">al</span>                 CF    OF    SF    ZF    PF</span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">al</span>,<span class="built_in">al</span>     <span class="number">0x00</span>/<span class="number">0000</span> <span class="number">0000</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">1</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">10h</span>    <span class="number">0x10</span>/<span class="number">0001</span> <span class="number">0000</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">1</span>  <span class="comment">; mov不会改变任何标志寄存器的值</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">90h</span>    <span class="number">0xa0</span>/<span class="number">1010</span> <span class="number">0000</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">80h</span>    <span class="number">0x80</span>/<span class="number">1000</span> <span class="number">0000</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">80h</span>    <span class="number">0x00</span>/<span class="number">0000</span> <span class="number">0000</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">fch</span>    <span class="number">0xfc</span>/<span class="number">1111</span> <span class="number">1100</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">05h</span>    <span class="number">0x01</span>/<span class="number">0000</span> <span class="number">0001</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">7dh</span>    <span class="number">0x7d</span>/<span class="number">0111</span> <span class="number">1101</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>,<span class="number">0bh</span>    <span class="number">0x88</span>/<span class="number">1000</span> <span class="number">1000</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="寄存器-3"><ul>
<li>%rip(Instruction Pointer)：指令指针寄存器，又叫PC(Program Counter)，存放下一条待执行指令的内存地址。CPU的工作其实就是不断取出它指向的指令，然后执行这条指令。</li>
</ul><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="寄存器-4"><p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20201128172252.png"></p>
<ul>
<li>CR0：存储了CPU控制标记和工作状态。一些重要的标志位含义如下：<ul>
<li>PE(Protected Mode Enable)：1代表系统运行在保护模式下，否则为实模式</li>
<li>WP(Write Protect)：是否开启内存写保护，若开启，对只读页面进行写入会触发异常，这一机制常常被用于实现<a href="https://blog.leosocy.top/posts/6d47">写时复制COW</a>功能</li>
<li>AM(Alignment Mask)：是否启用内存对齐自动检查</li>
<li>CD(Cache Disable)：1代表关闭cache</li>
<li>PG(Paging)：1代表启用内存分页，同时使用CR3寄存器，否则不开启内存分页</li>
</ul>
</li>
<li>CR1：保留，访问它会导致CPU抛出未定义异常</li>
<li>CR2：发生缺页异常时保存导致异常的访问地址</li>
<li>CR3：用于存储页目录的物理内存基地址，比如Linux 64位中存储PGD的物理地址，在进程空间切换时，CR3也要同步切换</li>
<li>CR4：在保护模式下使用，存储了CPU工作相关以及当前任务的一些信息</li>
</ul><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h3 id="CPU指令"><a href="#CPU指令" class="headerlink" title="CPU指令"></a>CPU指令</h3><h4 id="指令分类"><a href="#指令分类" class="headerlink" title="指令分类"></a>指令分类</h4><table>
<thead>
<tr>
<th>指令类型</th>
<th>示例</th>
<th>示例汇编代码</th>
<th>含义</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>算术类指令</td>
<td>add</td>
<td>add $s1,$s2,$s3</td>
<td>$s1=$s2+$s3</td>
<td>将寄存器r2和r3中的数值相加后的结果放到寄存器r1中</td>
</tr>
<tr>
<td>数据传输类指令</td>
<td>load word</td>
<td>load $s1,10($s2)</td>
<td>$s1=memory[$s2+10]</td>
<td>取寄存器r2中的数，加上10字节偏移后，取出内存中对应的字(WORD 一般为4字节)，存入r1寄存器中</td>
</tr>
<tr>
<td>逻辑类指令</td>
<td>xor</td>
<td>xor $s1,$s2$s3</td>
<td>$s1=$s2 ^ $s3</td>
<td>将寄存器r2和r3中的数值按位取异或后的结果放到寄存器r1中</td>
</tr>
<tr>
<td>条件分支指令</td>
<td>branch on equal</td>
<td>beq $s1,$s2,10</td>
<td>if($s1==$s2) go to PC+10</td>
<td>如果r1和r2寄存器内的值相等，从程序计数器往后跳10</td>
</tr>
<tr>
<td>无条件跳转指令</td>
<td>jump</td>
<td>j 1000</td>
<td>go to 1000</td>
<td>跳转到1000这个目标地址</td>
</tr>
</tbody></table>
<h4 id="机器码的生成"><a href="#机器码的生成" class="headerlink" title="机器码的生成"></a>机器码的生成</h4><p>以最简单的<code>MIPS32</code>指令集为例<br><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20201117200420.png"></p>
<blockquote>
<p>R指令：用作算术和逻辑运算，rs/rt为读取数据寄存器，rd为写入数据寄存器。如果是逻辑位移操作，则对rs/rt中的数据根据位移量做位移操作，然后写入rd寄存器；否则偏移量为00000。最后的功能码，则是在前面的操作码不够的时候，扩展操作码表示对应的具体指令的。比如<code>add</code>和<code>xor</code>的opcode都是<code>000000</code>，而<code>add</code>的功能码为<code>100000</code>，<code>xor</code>的功能码为<code>100110</code></p>
</blockquote>
<blockquote>
<p>I指令：用作数据传输和条件分支，以及在运算时使用的并非变量而是常数。此时没有第三个寄存器、偏移量以及功能码，这三部分被合成了一个16Bit的<em>地址值</em>或<em>常数</em></p>
</blockquote>
<blockquote>
<p>J指令：用作跳转，除opcode外的26Bit都是一个跳转后的地址</p>
</blockquote>
<p>下面用一个简单的异或指令为例，看看一个机器码如何生成</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">xor $t0,$s2,$s1</span><br><span class="line"></span><br><span class="line">（为了方便，下面的数字都用10进制表示）对应MIPS32指令里，opcode为0，rs代表第一个寄存器s1，地址是17，rt代表第二个寄存器s2，地址是18，rd代表目标的临时寄存器t0，地址是8。因为不是位移操作，所以偏移量是0。功能码通过查表得到二进制为&#x27;100110&#x27;。</span><br><span class="line"></span><br><span class="line">| opcode |   rs  |   rt  |   rd  | shamt | funct  |</span><br><span class="line">| 000000 | 10001 | 10010 | 01000 | 00000 | 100110 |</span><br><span class="line"></span><br><span class="line">2进制表示为：0000 0010 0011 0010 0100 0000 0010 0110</span><br><span class="line">16进制表示为： 0x02324026</span><br></pre></td></tr></table></figure>

<h4 id="指令跳转"><a href="#指令跳转" class="headerlink" title="指令跳转"></a>指令跳转</h4><p>CPU如何执行指令的？</p>
<p>程序执行时，CPU会根据PC寄存器中的指令内存地址，从内存里把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令，这就要求指令必须是连续存储在内存空间中的。</p>
<p>而有些特殊的指令，比如<a href="#%E6%9C%BA%E5%99%A8%E7%A0%81%E7%9A%84%E7%94%9F%E6%88%90">上一小节</a>提到的J指令，也就是跳转指令，会修改PC寄存器里面的指令内存地址的值。这样下一条要执行的指令就不是顺序加载的了。正是因为有了跳转指令，我们才可以在程序中使用<code>if...else/switch...case</code>条件语句和<code>while/for</code>循环语句。</p>
<blockquote>
<p>注：本节汇编代码使用的编译器版本为：<code>Apple clang version 11.0.3 (clang-1103.0.32.59) </code></p>
</blockquote>
<h5 id="if…else-goto"><a href="#if…else-goto" class="headerlink" title="if…else + goto"></a>if…else + goto</h5><p><code>goto</code>属于指令跳转最简单的使用场景。<code>if else</code>通过<code>jne+jmp</code>实现分支跳转。</p>
<div class="tabs" id="ifelse"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ifelse-1">汇编代码</button></li><li class="tab"><button type="button" data-href="#ifelse-2">C代码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ifelse-1"><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; int main() &#123;</span></span><br><span class="line"> <span class="number">0</span>: <span class="number">55</span>                      pushq   %rbp            <span class="comment">; 将父函数栈帧的起始地址压入栈顶，即当前函数栈帧</span></span><br><span class="line"> <span class="number">1</span>: <span class="number">48</span> <span class="number">89</span> e5                <span class="keyword">movq</span>    %rsp, %rbp      <span class="comment">; 将栈指针的值复制到rbp里，而rsp始终会指向栈顶</span></span><br><span class="line"> <span class="number">4</span>: <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>             subq    <span class="number">$16</span>, %rsp       <span class="comment">; 栈顶向下扩展16个字节（栈是从高地址向低地址生长的），用于在发生函数调用时，存储当前函数内的局部变量</span></span><br><span class="line"> <span class="number">8</span>: <span class="number">31</span> c0                   xorl    %eax, %eax      <span class="comment">; rax的低4字节置0</span></span><br><span class="line"><span class="symbol"> a:</span> <span class="number">89</span> c7                   movl    %eax, %edi      <span class="comment">; 将rax的低4字节（即0）复制到rdi寄存器的低4字节。[寄存器](#寄存器)一节有学到rdi是用于存储函数调用的第1个参数值</span></span><br><span class="line"><span class="symbol"> c:</span> c7 <span class="number">45</span> fc <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl    <span class="number">$0</span>, -<span class="number">4</span>(%rbp)    <span class="comment">; 将[rbp-4, rbp]内存空间置0，暂时不知道用处</span></span><br><span class="line"><span class="comment">;  srand(time(NULL));</span></span><br><span class="line"><span class="number">13</span>: e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          callq   <span class="number">0</span> &lt;_main+<span class="number">0x18</span>&gt;  <span class="comment">; 调用time函数，参数的值存在edi寄存器，即0(NULL)</span></span><br><span class="line"><span class="number">18</span>: <span class="number">89</span> c7                   movl    %eax, %edi      <span class="comment">; 将time函数的返回值复制到rdi寄存器的低4字节，作为srand函数的第1个参数</span></span><br><span class="line">1a: e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          callq   <span class="number">0</span> &lt;_main+<span class="number">0x1f</span>&gt;  <span class="comment">; 调用srand函数</span></span><br><span class="line"><span class="comment">;  int r = rand() % 2;</span></span><br><span class="line">1f: e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          callq   <span class="number">0</span> &lt;_main+<span class="number">0x24</span>&gt;  <span class="comment">; 调用rand函数，返回值存到rax指针</span></span><br><span class="line"><span class="number">24</span>: <span class="number">99</span>                      cltd                    <span class="comment">; 将eax寄存器的值符号扩展32位到%edx寄存器，也就是说，如果eax寄存器的二进制序列的最高位为0，则cltd指令将把edx置为32个0，相反，如果%eax寄存器的二进制序列最高位为1，则cltd指令将会自从填充edx寄存器为32个1</span></span><br><span class="line"><span class="number">25</span>: b9 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          movl    <span class="number">$2</span>, %ecx        <span class="comment">; 将rcx的低4字节值置为2</span></span><br><span class="line">2a: f7 f9                   idivl   %ecx            <span class="comment">; 将edx（高32位和eax（低32位）中的64位数作为被除数，ecx值作为除数。指令将商存储在eax中，余数存储在edx中。</span></span><br><span class="line">2c: <span class="number">89</span> <span class="number">55</span> f8                movl    %edx, -<span class="number">8</span>(%rbp)  <span class="comment">; 将edx中存储的余数的值复制到[rbp-8, rpb-4]内存空间，即变量r的栈地址</span></span><br><span class="line"><span class="comment">;  if (r == 0) &#123;</span></span><br><span class="line">2f: <span class="number">83</span> <span class="number">7d</span> f8 <span class="number">00</span>             cmpl    <span class="number">$0</span>, -<span class="number">8</span>(%rbp)    <span class="comment">; 判断r的值是否为0，并根据结果更新ZF/OF/SF标志寄存器，如果r==0，则ZF=1</span></span><br><span class="line"><span class="number">33</span>: 0f <span class="number">85</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">jne</span>     <span class="number">5</span> &lt;_main+<span class="number">0x3e</span>&gt;  <span class="comment">; Jump if not equal，即当ZF!=1时，将PC寄存器值改为0x3e</span></span><br><span class="line"><span class="comment">;      goto label1;</span></span><br><span class="line"><span class="number">39</span>: e9 <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">jmp</span>     <span class="number">5</span> &lt;_main+<span class="number">0x43</span>&gt;  <span class="comment">; 如果r==0，将PC寄存器值改为0x43</span></span><br><span class="line"><span class="comment">;      goto label2;</span></span><br><span class="line">3e: e9 <span class="number">09</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">jmp</span>     <span class="number">9</span> &lt;_main+<span class="number">0x4c</span>&gt;  <span class="comment">; 将PC寄存器值改为0x4c</span></span><br><span class="line"><span class="comment">;  r += 1;</span></span><br><span class="line"><span class="number">43</span>: 8b <span class="number">45</span> f8                movl    -<span class="number">8</span>(%rbp), %eax  <span class="comment">; r==0会执行到这一条指令，将r的值复制到eax寄存器</span></span><br><span class="line"><span class="number">46</span>: <span class="number">83</span> c0 <span class="number">01</span>                addl    <span class="number">$1</span>, %eax        <span class="comment">; eax寄存器累加1</span></span><br><span class="line"><span class="number">49</span>: <span class="number">89</span> <span class="number">45</span> f8                movl    %eax, -<span class="number">8</span>(%rbp)  <span class="comment">; 将eax的值复制到变量r的栈地址空间</span></span><br><span class="line"><span class="comment">;  r += 2;</span></span><br><span class="line">4c: 8b <span class="number">45</span> f8                movl    -<span class="number">8</span>(%rbp), %eax  <span class="comment">; 将r的值复制到eax寄存器</span></span><br><span class="line">4f: <span class="number">83</span> c0 <span class="number">02</span>                addl    <span class="number">$2</span>, %eax        <span class="comment">; eax寄存器累加2</span></span><br><span class="line"><span class="number">52</span>: <span class="number">89</span> <span class="number">45</span> f8                movl    %eax, -<span class="number">8</span>(%rbp)  <span class="comment">; 将eax的值复制到变量r的栈地址空间</span></span><br><span class="line"><span class="comment">;  return r;</span></span><br><span class="line"><span class="number">55</span>: 8b <span class="number">45</span> f8                movl    -<span class="number">8</span>(%rbp), %eax  <span class="comment">; 将r的值复制到eax寄存器，作为函数的返回值</span></span><br><span class="line"><span class="number">58</span>: <span class="number">48</span> <span class="number">83</span> c4 <span class="number">10</span>             addq    <span class="number">$16</span>, %rsp       <span class="comment">; 栈顶向上缩减16个字节，即恢复刚开始开辟的16字节栈内存空间</span></span><br><span class="line">5c: <span class="number">5d</span>                      popq    %rbp            <span class="comment">; 将父函数栈帧的起始地址恢复到rbp寄存器</span></span><br><span class="line"><span class="number">5d</span>: c3                      retq                    <span class="comment">; 弹出当前栈顶元素（即父函数执行call指令时压入的PC寄存器的下一条指令地址），更新到PC寄存器中，将程序控制权返回到出栈后的栈顶</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ifelse-2"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="type">int</span> r = rand() % <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> label1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> label2;</span><br><span class="line">    &#125;</span><br><span class="line">label1:</span><br><span class="line">    r += <span class="number">1</span>;</span><br><span class="line">label2:</span><br><span class="line">    r += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h5 id="while-amp-for"><a href="#while-amp-for" class="headerlink" title="while &amp; for"></a>while &amp; for</h5><ul>
<li><code>for</code>： 先用<code>cmp+jg</code>判断是否满足if条件，不满足则跳出循环，否则执行if内代码，最后用<code>jmp</code>实现执行完if内代码后跳回<code>cmp+jg</code></li>
<li><code>while</code>： 和for一样</li>
<li><code>do...while</code>： 先执行do内代码，然后用<code>cmp+jle</code>判断是否满足while条件，满足则用<code>jmp</code>跳回do，否则结束循环</li>
</ul>
<div class="tabs" id="while"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#while-1">汇编代码</button></li><li class="tab"><button type="button" data-href="#while-2">C代码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="while-1"><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; int main() &#123;</span></span><br><span class="line"> <span class="number">0</span>: <span class="number">55</span>                      pushq   %rbp            </span><br><span class="line"> <span class="number">1</span>: <span class="number">48</span> <span class="number">89</span> e5                <span class="keyword">movq</span>    %rsp, %rbp</span><br><span class="line"> <span class="number">4</span>: c7 <span class="number">45</span> fc <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl    <span class="number">$0</span>, -<span class="number">4</span>(%rbp)      <span class="comment">; 这里发现了个有意思的现象，由于代码里没有调用其他函数，所以没有扩展栈顶的指令，具体原因下面的[函数调用及栈帧](#函数调用及栈帧)一节会分析</span></span><br><span class="line"><span class="comment">;  int a = 1;</span></span><br><span class="line"><span class="symbol"> b:</span> c7 <span class="number">45</span> f8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl    <span class="number">$1</span>, -<span class="number">8</span>(%rbp)      <span class="comment">; 将栈地址[rbp-8, rpb-4]内存空间，即变量a赋值为1</span></span><br><span class="line"><span class="comment">;  for (int i = 1; i &lt;= 3; ++i) &#123;                     ; 下面3条指令对应的是 i = 1; i &lt;= 3</span></span><br><span class="line"><span class="number">12</span>: c7 <span class="number">45</span> f4 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    movl    <span class="number">$1</span>, -<span class="number">12</span>(%rbp)     <span class="comment">; 将栈地址[rbp-12, rpb-8]内存空间，即变量i赋值为1</span></span><br><span class="line"><span class="number">19</span>: <span class="number">83</span> <span class="number">7d</span> f4 <span class="number">03</span>             cmpl    <span class="number">$3</span>, -<span class="number">12</span>(%rbp)     <span class="comment">; 比较i和3，并根据结果更新ZF/OF/SF标志寄存器，如果i&lt;=3，则ZF=1 SF!=OF</span></span><br><span class="line"><span class="number">1d</span>: 0f 8f <span class="number">17</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">jg</span>      <span class="number">23</span> &lt;_main+<span class="number">0x3a</span>&gt;   <span class="comment">; Jump if greater，即当i &gt; 3时，将PC寄存器值改为0x3a</span></span><br><span class="line"><span class="comment">;      a += i;</span></span><br><span class="line"><span class="number">23</span>: 8b <span class="number">45</span> f4                movl    -<span class="number">12</span>(%rbp), %eax   <span class="comment">; 将i的值复制到eax寄存器  </span></span><br><span class="line"><span class="number">26</span>: <span class="number">03</span> <span class="number">45</span> f8                addl    -<span class="number">8</span>(%rbp), %eax    <span class="comment">; 将a的值累加到eax寄存器</span></span><br><span class="line"><span class="number">29</span>: <span class="number">89</span> <span class="number">45</span> f8                movl    %eax, -<span class="number">8</span>(%rbp)    <span class="comment">; 将eax的值复制到变量a的栈地址空间</span></span><br><span class="line"><span class="comment">;  for (int i = 1; i &lt;= 3; ++i) &#123;                     ; 下面4条指令对应的是 ++i</span></span><br><span class="line">2c: 8b <span class="number">45</span> f4                movl    -<span class="number">12</span>(%rbp), %eax   <span class="comment">; 将i的值复制到eax寄存器</span></span><br><span class="line">2f: <span class="number">83</span> c0 <span class="number">01</span>                addl    <span class="number">$1</span>, %eax          <span class="comment">; eax寄存器累加1</span></span><br><span class="line"><span class="number">32</span>: <span class="number">89</span> <span class="number">45</span> f4                movl    %eax, -<span class="number">12</span>(%rbp)   <span class="comment">; 将eax的值复制到变量i的栈地址空间</span></span><br><span class="line"><span class="number">35</span>: e9 df ff ff ff          <span class="keyword">jmp</span>     -<span class="number">33</span> &lt;_main+<span class="number">0x19</span>&gt;  <span class="comment">; 将PC寄存器值改为0x19，即跳回判断 i &lt;= 3的逻辑</span></span><br><span class="line"><span class="comment">;  while (a &lt;= 10) &#123;</span></span><br><span class="line">3a: e9 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">jmp</span>     <span class="number">0</span> &lt;_main+<span class="number">0x3f</span>&gt;</span><br><span class="line">3f: <span class="number">83</span> <span class="number">7d</span> f8 0a             cmpl    <span class="number">$10</span>, -<span class="number">8</span>(%rbp)     <span class="comment">; 比较a和10</span></span><br><span class="line"><span class="number">43</span>: 0f 8f 0e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">jg</span>      <span class="number">14</span> &lt;_main+<span class="number">0x57</span>&gt;   <span class="comment">; 当 i &gt; 10时，将PC寄存器值改为0x57</span></span><br><span class="line"><span class="comment">;      ++a;</span></span><br><span class="line"><span class="number">49</span>: 8b <span class="number">45</span> f8                movl    -<span class="number">8</span>(%rbp), %eax    <span class="comment">; 将a的值复制到eax寄存器</span></span><br><span class="line">4c: <span class="number">83</span> c0 <span class="number">01</span>                addl    <span class="number">$1</span>, %eax          <span class="comment">; eax寄存器累加1</span></span><br><span class="line">4f: <span class="number">89</span> <span class="number">45</span> f8                movl    %eax, -<span class="number">8</span>(%rbp)    <span class="comment">; 将eax的值复制到变量a的栈地址空间</span></span><br><span class="line"><span class="comment">;  while (a &lt;= 10) &#123;</span></span><br><span class="line"><span class="number">52</span>: e9 e8 ff ff ff          <span class="keyword">jmp</span>     -<span class="number">24</span> &lt;_main+<span class="number">0x3f</span>&gt;  <span class="comment">; 将PC寄存器的值改为0x3f，即跳回判断 i &lt;= 10的逻辑</span></span><br><span class="line"><span class="comment">;  do &#123;</span></span><br><span class="line"><span class="number">57</span>: e9 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">jmp</span>     <span class="number">0</span> &lt;_main+<span class="number">0x5c</span>&gt;</span><br><span class="line"><span class="comment">;      a += 1;</span></span><br><span class="line">5c: 8b <span class="number">45</span> f8                movl    -<span class="number">8</span>(%rbp), %eax    <span class="comment">; 下面3句对应a+1，这里就不赘述了</span></span><br><span class="line">5f: <span class="number">83</span> c0 <span class="number">01</span>                addl    <span class="number">$1</span>, %eax</span><br><span class="line"><span class="number">62</span>: <span class="number">89</span> <span class="number">45</span> f8                movl    %eax, -<span class="number">8</span>(%rbp)</span><br><span class="line"><span class="comment">;  &#125; while (a &lt;= 10);</span></span><br><span class="line"><span class="number">65</span>: <span class="number">83</span> <span class="number">7d</span> f8 0a             cmpl    <span class="number">$10</span>, -<span class="number">8</span>(%rbp)     <span class="comment">; 比较a和10</span></span><br><span class="line"><span class="number">69</span>: 0f 8e ed ff ff ff       <span class="keyword">jle</span>     -<span class="number">19</span> &lt;_main+<span class="number">0x5c</span>&gt;  <span class="comment">; 当 a &lt;= 10时，将PC寄存器值改为0x5c，即跳回a+1操作</span></span><br><span class="line"><span class="comment">;  return a;</span></span><br><span class="line">6f: 8b <span class="number">45</span> f8                movl    -<span class="number">8</span>(%rbp), %eax    <span class="comment">; 将a的值复制到eax寄存器作为函数返回值</span></span><br><span class="line"><span class="number">72</span>: <span class="number">5d</span>                      popq    %rbp</span><br><span class="line"><span class="number">73</span>: c3                      retq</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="while-2"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        a += i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (a &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">        ++a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (a &lt;= <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h5 id="switch…case"><a href="#switch…case" class="headerlink" title="switch…case"></a>switch…case</h5><p>从逻辑上来讲，<code>switch...case</code>能实现的功能都可以用<code>if...else</code>替换。但是有一点区别在于，编译器会根据case的数量和值的稀疏程度，来编译优化switch语句生成不同的机器码，具体的规则为：</p>
<ul>
<li>如果<code>case分支数 &lt; 4</code>（default不算），或者<code>每两个case之间的差值 &gt; 阈值</code>，此时生成的汇编代码和if…else逻辑类似，都是对每一个条件进行<code>cmp</code>，然后<code>je/jne</code>进行跳转</li>
<li>否则，编译器会在目标文件的代码段中增加一个<code>jump table</code>。其本质上是一个数组，index对应<em>case值</em>与<em>case最小值</em>的差值，value对应<em>数组起始地址</em>与<em>case代码块起始地址</em>的差值（之所以要存相对值而非绝对值是因为指令的地址只有在加载到内存后才能确定）。通过计算switch值相对的index，取出跳转表对应的相对地址，然后jmp到代码块，实现<code>O(1)</code>时间复杂度的条件跳转，是典型的以空间换时间的优化方法。</li>
</ul>
<blockquote>
<p>switch语句适用场景</p>
<ol>
<li>判断的case条件针对<strong>同一个变量</strong>，且有确切值</li>
<li>分支较多，大于等于4个</li>
<li>case条件的值在一个较小的、连续的范围内，且跨度小于等于6</li>
</ol>
<p>if…else语句适用场景</p>
<ol>
<li>分支较少，小于4个</li>
<li>case条件值较为稀疏</li>
<li>判断的case条件<strong>不止有一个变量</strong>，或基于数值范围判断</li>
</ol>
</blockquote>
<div class="tabs" id="switch-case"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#switch-case-1">汇编代码</button></li><li class="tab"><button type="button" data-href="#switch-case-2">Jump Table</button></li><li class="tab"><button type="button" data-href="#switch-case-3">C代码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="switch-case-1"><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; void switch_demo(int x) &#123;</span></span><br><span class="line"> <span class="number">8</span>: <span class="number">89</span> <span class="number">7d</span> fc                movl    %edi, -<span class="number">4</span>(%rbp)          <span class="comment">; 将入参x的值复制到[rbp - 4, rbp]栈内存，因为rdi寄存器在调用其他函数时还要用到所以必须要把值保存到内存中</span></span><br><span class="line"><span class="comment">;  switch(x) &#123;</span></span><br><span class="line"><span class="symbol"> b:</span> 8b <span class="number">45</span> fc                movl    -<span class="number">4</span>(%rbp), %eax</span><br><span class="line"><span class="symbol"> e:</span> <span class="number">83</span> c0 fe                addl    $-<span class="number">2</span>, %eax               <span class="comment">; eax寄存器中的值-2，2为case最小值，这里是计算变量x对应跳转表的index</span></span><br><span class="line"><span class="number">11</span>: <span class="number">89</span> c1                   movl    %eax, %ecx              <span class="comment">; 将index的值写入ecx寄存器</span></span><br><span class="line"><span class="number">13</span>: <span class="number">83</span> e8 <span class="number">05</span>                subl    <span class="number">$5</span>, %eax                <span class="comment">; 将变量x减去case的最大值，如果大于0则跳转到default，无需查询跳转表</span></span><br><span class="line"><span class="number">16</span>: <span class="number">48</span> <span class="number">89</span> <span class="number">4d</span> f0             <span class="keyword">movq</span>    %rcx, -<span class="number">16</span>(%rbp)         <span class="comment">; 保存index的值到[rbp - 16, rbp - 8]栈内存</span></span><br><span class="line">1a: 0f <span class="number">87</span> 5b <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">ja</span>      <span class="number">91</span> &lt;_switch_demo+<span class="number">0x7b</span>&gt;  <span class="comment">; 无符号跳转，如果eax中的值大于0，即x - 2 - 5 &gt; 0，则修改PC寄存器的值为0x7b，即跳转到default分支</span></span><br><span class="line"><span class="number">20</span>: <span class="number">48</span> <span class="number">8d</span> <span class="number">05</span> <span class="number">69</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    leaq    <span class="number">105</span>(%rip), %rax         <span class="comment">; 将PC寄存器中的值加0x69并复制到rax寄存器，PC寄存器存的是下一条待执行指令的地址即0x27，所以rax中的值为0x90即跳转表首地址。leaq是对地址进行运算，并将计算出的地址存入目标寄存器中；movq是对地址中的数据进行计算</span></span><br><span class="line"><span class="number">27</span>: <span class="number">48</span> 8b <span class="number">4d</span> f0             <span class="keyword">movq</span>    -<span class="number">16</span>(%rbp), %rcx         <span class="comment">; 将index的值复制到rcx寄存器</span></span><br><span class="line">2b: <span class="number">48</span> <span class="number">63</span> <span class="number">14</span> <span class="number">88</span>             movslq  (%rax,%rcx,<span class="number">4</span>), %rdx     <span class="comment">; 跳转表首地址 + index * 4，这里是计算变量x对应的跳转表中的地址</span></span><br><span class="line">2f: <span class="number">48</span> <span class="number">01</span> c2                addq    %rax, %rdx              <span class="comment">; 跳转表中地址存储的值为`case代码块相对于跳转表首地址的差值`， 加上跳转表首地址后，rbx中存的即为变量x对应的case代码块首地址</span></span><br><span class="line"><span class="number">32</span>: ff e2                   jmpq    *%rdx                   <span class="comment">; 修改PC寄存器值为rdx中存的地址值</span></span><br><span class="line"><span class="comment">;          printf(&quot;Got 3&quot;);</span></span><br><span class="line"><span class="number">34</span>: <span class="number">48</span> <span class="number">8d</span> <span class="number">3d</span> <span class="number">6d</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    leaq    <span class="number">109</span>(%rip), %rdi         <span class="comment">; data段中&quot;Got 3&quot;常量对应的地址</span></span><br><span class="line">3b: b0 <span class="number">00</span>                   movb    <span class="number">$0</span>, %al</span><br><span class="line"><span class="number">3d</span>: e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          callq   <span class="number">0</span> &lt;_switch_demo+<span class="number">0x42</span>&gt;</span><br><span class="line"><span class="comment">;          break;</span></span><br><span class="line"><span class="number">42</span>: e9 <span class="number">42</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">jmp</span>     <span class="number">66</span> &lt;_switch_demo+<span class="number">0x89</span>&gt;  <span class="comment">; break跳出循环 </span></span><br><span class="line"><span class="comment">;          printf(&quot;Got 6&quot;);</span></span><br><span class="line"><span class="number">47</span>: <span class="number">48</span> <span class="number">8d</span> <span class="number">3d</span> <span class="number">60</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    leaq    <span class="number">96</span>(%rip), %rdi</span><br><span class="line">4e: b0 <span class="number">00</span>                   movb    <span class="number">$0</span>, %al</span><br><span class="line"><span class="number">50</span>: e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          callq   <span class="number">0</span> &lt;_switch_demo+<span class="number">0x55</span>&gt;</span><br><span class="line"><span class="comment">;          printf(&quot;Got 7&quot;);</span></span><br><span class="line"><span class="number">55</span>: <span class="number">48</span> <span class="number">8d</span> <span class="number">3d</span> <span class="number">58</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    leaq    <span class="number">88</span>(%rip), %rdi          <span class="comment">; go through</span></span><br><span class="line">5c: b0 <span class="number">00</span>                   movb    <span class="number">$0</span>, %al</span><br><span class="line">5e: e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          callq   <span class="number">0</span> &lt;_switch_demo+<span class="number">0x63</span>&gt;</span><br><span class="line"><span class="comment">;          break;</span></span><br><span class="line"><span class="number">63</span>: e9 <span class="number">21</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">jmp</span>     <span class="number">33</span> &lt;_switch_demo+<span class="number">0x89</span>&gt;</span><br><span class="line"><span class="comment">;          printf(&quot;Got 2 or 4&quot;);</span></span><br><span class="line"><span class="number">68</span>: <span class="number">48</span> <span class="number">8d</span> <span class="number">3d</span> 4b <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    leaq    <span class="number">75</span>(%rip), %rdi</span><br><span class="line">6f: b0 <span class="number">00</span>                   movb    <span class="number">$0</span>, %al</span><br><span class="line"><span class="number">71</span>: e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          callq   <span class="number">0</span> &lt;_switch_demo+<span class="number">0x76</span>&gt;</span><br><span class="line"><span class="comment">;          break;</span></span><br><span class="line"><span class="number">76</span>: e9 0e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="keyword">jmp</span>     <span class="number">14</span> &lt;_switch_demo+<span class="number">0x89</span>&gt;</span><br><span class="line"><span class="comment">;          printf(&quot;Got default&quot;);</span></span><br><span class="line">7b: <span class="number">48</span> <span class="number">8d</span> <span class="number">3d</span> <span class="number">43</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    leaq    <span class="number">67</span>(%rip), %rdi</span><br><span class="line"><span class="number">82</span>: b0 <span class="number">00</span>                   movb    <span class="number">$0</span>, %al</span><br><span class="line"><span class="number">84</span>: e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          callq   <span class="number">0</span> &lt;_switch_demo+<span class="number">0x89</span>&gt;</span><br><span class="line"><span class="comment">; &#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="switch-case-2"><p>小端模式，即低地址存低字节。值为补码。</p>
<table>
<thead>
<tr>
<th>index/switch值</th>
<th>asm</th>
<th>补码</th>
<th>原码</th>
<th>case代码块首地址</th>
<th>对应代码</th>
</tr>
</thead>
<tbody><tr>
<td>0/2</td>
<td>90: d8 ff ff ff</td>
<td>0xffffffd8</td>
<td>0x80000028</td>
<td>0x68</td>
<td>printf(“Got 2 or 4”);</td>
</tr>
<tr>
<td>1/3</td>
<td>94: a4 ff ff ff</td>
<td>0xffffffa4</td>
<td>0x8000005c</td>
<td>0x34</td>
<td>printf(“Got 3”);</td>
</tr>
<tr>
<td>2/4</td>
<td>98: d8 ff ff ff</td>
<td>0xffffffd8</td>
<td>0x80000028</td>
<td>0x68</td>
<td>printf(“Got 2 or 4”);</td>
</tr>
<tr>
<td>3/5</td>
<td>9c: eb ff ff ff</td>
<td>0xffffffeb</td>
<td>0x80000015</td>
<td>0x7b</td>
<td>printf(“Got default”);</td>
</tr>
<tr>
<td>4/6</td>
<td>a0: b7 ff ff ff</td>
<td>0xffffffb7</td>
<td>0x80000049</td>
<td>0x47</td>
<td>printf(“Got 6”);</td>
</tr>
<tr>
<td>5/7</td>
<td>a4: c5 ff ff ff</td>
<td>0xffffffc5</td>
<td>0x8000003b</td>
<td>0x55</td>
<td>printf(“Got 7”);</td>
</tr>
</tbody></table><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="switch-case-3"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">switch_demo</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(x) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Got 3&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Got 6&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Got 7&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Got 2 or 4&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Got default&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h4 id="函数调用及栈帧"><a href="#函数调用及栈帧" class="headerlink" title="函数调用及栈帧"></a>函数调用及栈帧</h4><blockquote>
<p>上一小节分析指令跳转汇编代码时提到了函数调用、压栈相关知识，这一节重点学习下。首先思考个问题，函数A在调用函数B之前，需要保存哪些信息，保存到哪？需要传递哪些信息，如何传递？调用结束后如何恢复信息并继续执行呢？</p>
</blockquote>
<h5 id="函数栈帧起源"><a href="#函数栈帧起源" class="headerlink" title="函数栈帧起源"></a>函数栈帧起源</h5><p>如果让我来设计指令实现函数调用，最先想到的是什么方法呢？</p>
<ul>
<li>用goto能实现吗，函数B执行结束后利用goto回到函数A中调用函数B的下一条指令的地址。但是细想一下有诸多问题，如果依赖了第三方的库，我们没办法改它的源代码，也就没办法让Callee执行结束后goto回Caller继续执行，所以用goto实现不了函数调用。</li>
<li>那既然在这种场景下没办法跳回，能不能在编译时用函数B的指令替换掉函数A的call指令？这样无需跳转顺序执行即可。但是细想一下还是有问题，如果函数A调用函数B，函数B又调用了函数A，这样一直循环调用就会产生无穷无尽的替换。所以把Callee的指令直接插入到调用处这个方法也实现不了函数调用。</li>
<li>既然函数调用必须要跳回继续执行，但又不能修改被调用函数的指令，那能不能把要跳回执行的指令记录下来，然后大家约定下：比如函数调用结束后都从<code>r15</code>寄存器中取出跳回地址，继续执行就好了。但是在多层函数调用里，需要记录每一层函数的跳回地址，而CPU中的寄存器数量并不多（x86-64只有16个通用寄存器），调用层级一多就存不下了。</li>
<li>既然寄存器存不下跳回地址，那能不能把地址存到内存空间中呢？考虑到函数调用有递归的特性，即先调用的后返回，这和栈的数据结构（LIFO，Last In First Out）相同。这样我们在内存中开辟一段空间，每次函数调用之前把跳回后要继续执行的指令地址压栈，在被调用函数返回时将栈顶地址出栈，然后<code>jmp</code>跳转到对应指令地址。</li>
</ul>
<p>通过上面的推演，我们初步确定了函数调用的方法。当然在真实的程序里，需要压栈的不止有函数调用完成后的返回地址。</p>
<p>为了保证调用前后变量和函数在Caller中的相对地址不变，在函数返回时要能把Caller栈底的地址恢复到寄存器中，所以Caller的栈底地址（即<code>%rbp</code>寄存器中的值）也需要保存到栈空间。考虑到函数传参可以有很多，而寄存器个数有限，所以当参数超过6个（在<a href="#%E5%AF%84%E5%AD%98%E5%99%A8">寄存器</a>一节有讲过）后，多出的参数数据也要压入栈中（从右到左依次压入Caller栈）。那么函数的栈空间目前可以确定的结构如下：</p>
<img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20210409011244.png" style="zoom:33%;" />

<p>通过寄存器传递到Callee的参数值也需要保存到栈空间，以免寄存器参与之后的计算或函数调用导致其内的值被覆盖。同时局部变量在函数调用返回后还需要继续使用，所以局部变量的值也需要保存到栈空间，那么函数的栈帧空间最终就确定为：</p>
<img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20210409011337.png" style="zoom:33%;" />

<h5 id="汇编代码分析"><a href="#汇编代码分析" class="headerlink" title="汇编代码分析"></a>汇编代码分析</h5><blockquote>
<p>注：汇编代码使用的编译器版本为：<code>gcc version 6.3.0 20170516 (Debian 6.3.0-18+deb9u1)</code></p>
<p>汇编代码中涉及到的几个小知识，这里提前说明下</p>
<ol>
<li><code>lea</code>（Load Effective Address）是对地址进行运算，并将计算出的地址存入目标寄存器中；mov是对地址中的数据进行计算。举个例子：<code>%rbp=0x30</code>， <code>mov -0x10(%rbp),rax</code>将0x20~0x28内存地址中的数据复制到rax寄存器；<code>lea -0x10(%rbp),rax</code>将0x20这个值复制到rax寄存器</li>
<li><strong>栈地址对齐</strong>：某些型号的Intel和AMD处理器对于SSE指令，如果数据没有对齐的话，就无法正确执行。这些指令对16字节内存进行操作，在SSE单元和内存之间传送数据的指令要求内存地址必须是16的倍数。对齐的字节数可以通过gcc的<code>-mpreferred-stack-boundary</code>参数配置，取值范围为<code>4~12</code>即<code>64byte~4096byte</code></li>
</ol>
</blockquote>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000000072</span> &lt;main&gt;:</span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line"><span class="number">72</span>:  <span class="number">55</span>                <span class="keyword">push</span>   %rbp              <span class="comment">; 将上一栈帧的rbp值压栈。这里有一个疑惑：main函数不是整个函数的入口吗？难道说main也有父函数？这个谜题将在[程序链接与装载](#程序连接与装载)一节揭晓</span></span><br><span class="line"><span class="number">73</span>:  <span class="number">48</span> <span class="number">89</span> e5          <span class="keyword">mov</span>    %rsp,%rbp         <span class="comment">; 将rsp的值复制到rbp寄存器，即将rbp指向当前函数的栈底，而rsp始终会指向栈顶</span></span><br><span class="line"><span class="number">76</span>:  <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>       <span class="keyword">sub</span>    <span class="number">$0</span>x10,%rsp        <span class="comment">; 栈顶向下扩展16个字节（栈是从高地址向低地址生长的），用于存储局部变量</span></span><br><span class="line">		long x = <span class="number">10</span>, y = <span class="number">20</span><span class="comment">;</span></span><br><span class="line">7a:  <span class="number">48</span> c7 <span class="number">45</span> f8 0a <span class="number">00</span> <span class="keyword">movq</span>   <span class="number">$0</span>xa,-<span class="number">0x8</span>(%rbp)   <span class="comment">; 将栈地址[rbp-8, rbp]内存空间，即变量x赋值为10</span></span><br><span class="line"><span class="number">81</span>:  <span class="number">00</span> </span><br><span class="line"><span class="number">82</span>:  <span class="number">48</span> c7 <span class="number">45</span> f0 <span class="number">14</span> <span class="number">00</span> <span class="keyword">movq</span>   <span class="number">$0</span>x14,-<span class="number">0x10</span>(%rbp) <span class="comment">; 将栈地址[rbp-16, rbp-8]内存空间，即变量y赋值为20</span></span><br><span class="line"><span class="number">89</span>:  <span class="number">00</span> </span><br><span class="line">		x = calc(<span class="string">&#x27;l&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>, x, <span class="number">15</span>, y, y + <span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">8a:  <span class="number">48</span> 8b <span class="number">45</span> f0       <span class="keyword">mov</span>    -<span class="number">0x10</span>(%rbp),%rax  <span class="comment">; 将变量y的值复制到rax寄存器，用于后续计算y+1</span></span><br><span class="line">8e:  <span class="number">48</span> <span class="number">8d</span> <span class="number">48</span> <span class="number">01</span>       <span class="keyword">lea</span>    <span class="number">0x1</span>(%rax),%rcx    <span class="comment">; 将y+1的值复制到rcx寄存器，这里为什么用lea而不用add呢？因为rax中存储y的值还要用于后续传参，用add会改变rax中的值，这里用lea可以将运算后的值存到另一个寄存器中</span></span><br><span class="line"><span class="number">92</span>:  <span class="number">48</span> 8b <span class="number">55</span> f0       <span class="keyword">mov</span>    -<span class="number">0x10</span>(%rbp),%rdx  <span class="comment">; 将变量y的值复制到rbx寄存器</span></span><br><span class="line"><span class="number">96</span>:  <span class="number">48</span> 8b <span class="number">45</span> f8       <span class="keyword">mov</span>    -<span class="number">0x8</span>(%rbp),%rax   <span class="comment">; 将变量x的值复制到rax寄存器</span></span><br><span class="line">9a:  <span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>       <span class="keyword">sub</span>    <span class="number">$0</span>x8,%rsp         <span class="comment">; 栈顶向下扩展8个字节，用于保证栈帧的边界是16字节对齐的</span></span><br><span class="line">9e:  <span class="number">51</span>                <span class="keyword">push</span>   %rcx              <span class="comment">; 第七个参数压栈，</span></span><br><span class="line">9f:  <span class="number">49</span> <span class="number">89</span> d1          <span class="keyword">mov</span>    %rdx,%r9          <span class="comment">; r9寄存器，存第六个参数y，y的值在0x92指令中被复制到了rdx寄存器</span></span><br><span class="line"><span class="symbol">a2:</span>  <span class="number">41</span> b8 0f <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="keyword">mov</span>    <span class="number">$0</span>xf,%r8d         <span class="comment">; r8寄存器，存第五个参数15</span></span><br><span class="line"><span class="symbol">a8:</span>  <span class="number">48</span> <span class="number">89</span> c1          <span class="keyword">mov</span>    %rax,%rcx         <span class="comment">; rcx寄存器，存第四个参数x，x的值在0x96指令中被复制到了rax寄存器</span></span><br><span class="line"><span class="symbol">ab:</span>  ba <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    <span class="keyword">mov</span>    <span class="number">$0</span>x3,%edx         <span class="comment">; rdx寄存器，存第三个参数3</span></span><br><span class="line"><span class="symbol">b0:</span>  be <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    <span class="keyword">mov</span>    <span class="number">$0</span>x2,%esi         <span class="comment">; rsi寄存器，存第二个参数2</span></span><br><span class="line"><span class="symbol">b5:</span>  bf 6c <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    <span class="keyword">mov</span>    <span class="number">$0</span>x6c,%edi        <span class="comment">; rdi寄存器，存第一个参数&#x27;l&#x27;</span></span><br><span class="line"><span class="symbol">ba:</span>  e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    callq  bf &lt;main+<span class="number">0x4d</span>&gt;    <span class="comment">; 调用calc方法，call指令会把rip寄存器里的下一条指令的地址压栈，保留函数调用结束后要执行的指令地址，然后把被调函数的地址更新到rip寄存器中实现函数跳转</span></span><br><span class="line"><span class="symbol">bf:</span>  <span class="number">48</span> <span class="number">83</span> c4 <span class="number">10</span>       <span class="keyword">add</span>    <span class="number">$0</span>x10,%rsp        <span class="comment">; 栈顶向上缩减16个字节，即恢复push第七个参数+Padding的16个字节空间</span></span><br><span class="line"><span class="symbol">c3:</span>  <span class="number">48</span> <span class="number">89</span> <span class="number">45</span> f8       <span class="keyword">mov</span>    %rax,-<span class="number">0x8</span>(%rbp)   <span class="comment">; 将calc函数的返回值赋值给变量x</span></span><br><span class="line">		return x<span class="comment">;</span></span><br><span class="line"><span class="symbol">c7:</span>  <span class="number">48</span> 8b <span class="number">45</span> f8       <span class="keyword">mov</span>    -<span class="number">0x8</span>(%rbp),%rax   <span class="comment">; 将变量x的值复制到rax寄存器作为main函数的返回值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="symbol">cb:</span>  c9                leaveq                   <span class="comment">; 相当于 mov %rbp %rsp; pop %rbp，与函数开头的 push %rbp; mov %rsp, %rbp 对应。将rbp的值复制到rsp寄存器，即rsp和rbp此时都指向当前函数的栈底；将栈顶元素出栈，即上一栈帧的栈底地址赋值到rbp中，也就是将rbp指向caller的栈底</span></span><br><span class="line"><span class="symbol">cc:</span>  c3                retq                     <span class="comment">; 相当于 pop %rip，与call指令的 push %rip 对应。将栈顶元素出栈，即将返回地址的值复制到rip指令地址寄存器，以实现继续执行caller中的指令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;calc&gt;:</span><br><span class="line">long calc(char a, short b, <span class="keyword">int</span> c, long d, long e, long f, long g) &#123;</span><br><span class="line"> <span class="number">0</span>:  <span class="number">55</span>                <span class="keyword">push</span>   %rbp              <span class="comment">; 将main函数栈帧的rbp值压栈</span></span><br><span class="line"> <span class="number">1</span>:  <span class="number">48</span> <span class="number">89</span> e5          <span class="keyword">mov</span>    %rsp,%rbp         <span class="comment">; main函数解释过了</span></span><br><span class="line"> <span class="number">4</span>:  <span class="number">48</span> <span class="number">83</span> ec <span class="number">40</span>       <span class="keyword">sub</span>    <span class="number">$0</span>x40,%rsp        <span class="comment">;	栈顶向下扩展64个字节，用于存储局部变量和寄存器中的值</span></span><br><span class="line"> <span class="number">8</span>:  <span class="number">89</span> f0             <span class="keyword">mov</span>    %esi,%eax         <span class="comment">; 6个用于传参的寄存器值按顺序压栈</span></span><br><span class="line"><span class="symbol"> a:</span>  <span class="number">89</span> <span class="number">55</span> e4          <span class="keyword">mov</span>    %edx,-<span class="number">0x1c</span>(%rbp)</span><br><span class="line"><span class="symbol"> d:</span>  <span class="number">48</span> <span class="number">89</span> <span class="number">4d</span> d8       <span class="keyword">mov</span>    %rcx,-<span class="number">0x28</span>(%rbp)</span><br><span class="line"><span class="number">11</span>:  4c <span class="number">89</span> <span class="number">45</span> d0       <span class="keyword">mov</span>    %r8,-<span class="number">0x30</span>(%rbp)</span><br><span class="line"><span class="number">15</span>:  4c <span class="number">89</span> <span class="number">4d</span> c8       <span class="keyword">mov</span>    %r9,-<span class="number">0x38</span>(%rbp)</span><br><span class="line"><span class="number">19</span>:  <span class="number">40</span> <span class="number">88</span> <span class="number">7d</span> ec       <span class="keyword">mov</span>    %dil,-<span class="number">0x14</span>(%rbp)</span><br><span class="line"><span class="number">1d</span>:  <span class="number">66</span> <span class="number">89</span> <span class="number">45</span> e8       <span class="keyword">mov</span>    %ax,-<span class="number">0x18</span>(%rbp)</span><br><span class="line">		srand(time(NULL))<span class="comment">;</span></span><br><span class="line"><span class="number">21</span>:  bf <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    <span class="keyword">mov</span>    <span class="number">$0</span>x0,%edi         <span class="comment">; rdi寄存器赋值为0，对应NULL</span></span><br><span class="line"><span class="number">26</span>:  e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    callq  2b &lt;calc+<span class="number">0x2b</span>&gt;</span><br><span class="line">2b:  <span class="number">89</span> c7             <span class="keyword">mov</span>    %eax,%edi</span><br><span class="line"><span class="number">2d</span>:  e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    callq  <span class="number">32</span> &lt;calc+<span class="number">0x32</span>&gt;</span><br><span class="line">		<span class="keyword">int</span> h = rand()<span class="comment">;</span></span><br><span class="line"><span class="number">32</span>:  e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    callq  <span class="number">37</span> &lt;calc+<span class="number">0x37</span>&gt;</span><br><span class="line"><span class="number">37</span>:  <span class="number">89</span> <span class="number">45</span> fc          <span class="keyword">mov</span>    %eax,-<span class="number">0x4</span>(%rbp)   <span class="comment">; rand函数返回值赋值到栈地址[rbp - 4, rbp]</span></span><br><span class="line">		return a + b + c + d + e + f + g + h<span class="comment">;</span></span><br><span class="line">3a:  0f be <span class="number">55</span> ec       movsbl -<span class="number">0x14</span>(%rbp),%edx  <span class="comment">; 将变量a的值1字节带符号扩展成4字节，并存到rdx寄存器</span></span><br><span class="line">3e:  0f bf <span class="number">45</span> e8       movswl -<span class="number">0x18</span>(%rbp),%eax  <span class="comment">; 将变量b的值2字节带符号扩展成4字节，并存到rax寄存器</span></span><br><span class="line"><span class="number">42</span>:  <span class="number">01</span> c2             <span class="keyword">add</span>    %eax,%edx         <span class="comment">; rdx = rax + rdx</span></span><br><span class="line"><span class="number">44</span>:  8b <span class="number">45</span> e4          <span class="keyword">mov</span>    -<span class="number">0x1c</span>(%rbp),%eax  <span class="comment">; 将变量c的值复制到rax寄存器</span></span><br><span class="line"><span class="number">47</span>:  <span class="number">01</span> d0             <span class="keyword">add</span>    %edx,%eax         <span class="comment">; rax = rdx + rax</span></span><br><span class="line"><span class="number">49</span>:  <span class="number">48</span> <span class="number">63</span> d0          movslq %eax,%rdx         <span class="comment">; 将rax中的4字节带符号扩展成8字节，并存到rdx寄存器</span></span><br><span class="line">4c:  <span class="number">48</span> 8b <span class="number">45</span> d8       <span class="keyword">mov</span>    -<span class="number">0x28</span>(%rbp),%rax  <span class="comment">; 将变量d的值复制到rax寄存器</span></span><br><span class="line"><span class="number">50</span>:  <span class="number">48</span> <span class="number">01</span> c2          <span class="keyword">add</span>    %rax,%rdx         <span class="comment">; rdx = rax + rdx</span></span><br><span class="line"><span class="number">53</span>:  <span class="number">48</span> 8b <span class="number">45</span> d0       <span class="keyword">mov</span>    -<span class="number">0x30</span>(%rbp),%rax  <span class="comment">; 将变量e的值复制到rax寄存器</span></span><br><span class="line"><span class="number">57</span>:  <span class="number">48</span> <span class="number">01</span> c2          <span class="keyword">add</span>    %rax,%rdx         <span class="comment">; rdx = rax + rdx</span></span><br><span class="line">5a:  <span class="number">48</span> 8b <span class="number">45</span> c8       <span class="keyword">mov</span>    -<span class="number">0x38</span>(%rbp),%rax  <span class="comment">; 将变量f的值复制到rax寄存器</span></span><br><span class="line">5e:  <span class="number">48</span> <span class="number">01</span> c2          <span class="keyword">add</span>    %rax,%rdx         <span class="comment">; rdx = rax + rdx</span></span><br><span class="line"><span class="number">61</span>:  <span class="number">48</span> 8b <span class="number">45</span> <span class="number">10</span>       <span class="keyword">mov</span>    <span class="number">0x10</span>(%rbp),%rax   <span class="comment">; 将变量g的值（在caller的栈帧中）复制到rax寄存器</span></span><br><span class="line"><span class="number">65</span>:  <span class="number">48</span> <span class="number">01</span> c2          <span class="keyword">add</span>    %rax,%rdx         <span class="comment">; rdx = rax + rdx</span></span><br><span class="line"><span class="number">68</span>:  8b <span class="number">45</span> fc          <span class="keyword">mov</span>    -<span class="number">0x4</span>(%rbp),%eax   <span class="comment">; 将局部变量h的值复制到eax寄存器</span></span><br><span class="line">6b:  <span class="number">48</span> <span class="number">98</span>             cltq                     <span class="comment">; 将eax的值带符号扩展成8字节存到rax寄存器</span></span><br><span class="line"><span class="number">6d</span>:  <span class="number">48</span> <span class="number">01</span> d0          <span class="keyword">add</span>    %rdx,%rax         <span class="comment">; rax = rbx + rax</span></span><br><span class="line"></span><br><span class="line"><span class="number">70</span>:  c9                leaveq                   <span class="comment">; main函数解释过了</span></span><br><span class="line"><span class="number">71</span>:  c3                retq                     <span class="comment">; main函数解释过了</span></span><br></pre></td></tr></table></figure>

<h5 id="x86-64常用指令"><a href="#x86-64常用指令" class="headerlink" title="x86_64常用指令"></a>x86_64常用指令</h5><h5 id="相关知识延展"><a href="#相关知识延展" class="headerlink" title="相关知识延展"></a>相关知识延展</h5><h6 id="函数内联优劣"><a href="#函数内联优劣" class="headerlink" title="函数内联优劣"></a>函数内联优劣</h6><p>如果被调函数中没有再调用其他函数（这种函数通常被称为叶子函数），可以通过将被调函数指令直接替换到调用处来实现函数调用的。这也是常见的编译器自动优化的手段，叫做<strong>函数内联（Inline）</strong>。除了靠编译器自动优化，也可以在函数定义前加上inline关键字，来提示编译器对函数进行内联。</p>
<p>我们来看一段代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="type">int</span> x = rand() % <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> y = rand() % <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">return</span> add(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>gcc -O</code>编译出来的汇编代码，并没有把add函数单独编译成一段指令顺序，而是在调用<code>add(x, y)</code>的时候，直接替换成了一个add指令</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">      <span class="number">6d</span>: <span class="number">01</span> c8                         addl    %ecx, %eax</span><br><span class="line"><span class="comment">;     return a + b;</span></span><br><span class="line">      6f: <span class="number">01</span> d8                         addl    %ebx, %eax</span><br></pre></td></tr></table></figure>

<p>内联可以减少函数调用过程中保存寄存器值，数据压栈出栈等开销，提升调用性能。</p>
<p>不过这也是有代价的，内联把可以复用的指令在调用它的地方完全展开了，这就会导致程序的代码段指令数增加，占用空间变大。</p>
<h6 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a>Stack Overflow</h6><p>一般是由于递归调用，或调用链过深，或在栈空间里创建非常占内存的变量（比如一个巨大的数组）导致的。</p>
<ol>
<li>Linux：默认栈空间大小为8MiB，在task_struct创建时（Linux不区分进程和线程）alloc并memset为0，具体代码见<a href="https://code.woboq.org/linux/linux/kernel/fork.c.html#alloc_thread_stack_node">alloc_thread_stack_node</a>。</li>
<li>JVM：默认栈空间大小为1MiB，可以由<code>-Xss</code>指定</li>
<li>Go：goroutine初始栈空间大小为2Kib，上限取决于操作系统位数，<a href="https://github.com/golang/go/blob/f296b7a6f045325a230f77e9bda1470b1270f817/src/runtime/proc.go#L120">64位为1GiB，32位为250MiB</a></li>
<li>Python：没有限制栈空间，不过有最大递归调用次数限制，可以通过<code>sys.getrecursionlimit()</code>获取，默认为1000</li>
</ol>
<h6 id="栈溢出攻击"><a href="#栈溢出攻击" class="headerlink" title="栈溢出攻击"></a>栈溢出攻击</h6><blockquote>
<p>栈溢出利用程序的漏洞，通过构造精心设计的数据，来覆盖函数的返回地址，进而打乱原有函数执行流程，跳入黑客预先设计好的恶意代码中。</p>
</blockquote>
<p>栈溢出攻击基于以下几个原理：</p>
<ol>
<li>函数栈帧保存了函数调用返回后下一条待执行指令的内存地址</li>
<li>程序的代码和数据都在内存中，直接从内存的二进制形式上是无法区分哪些是数据哪些是代码</li>
<li>局部变量存储在栈中，如果局部变量是一个数组，那么通过构造一个溢出当前栈帧的数据，就有可能覆盖上一栈帧的函数返回地址，进而跳转执行恶意代码</li>
</ol>
<p>例如下面这段代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">counter</span><span class="params">(<span class="type">char</span> *data, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buffer[BUF_LEN];</span><br><span class="line">  <span class="built_in">strcpy</span>(buffer, data);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是一个典型的栈溢出代码，使用了不安全的<code>strcpy</code>函数，系统会盲目的将data的全部数据拷贝到栈空间的buffer上，而buffer的长度是有限的，一旦data的数据长度超过BUF_LEN，就会产生栈溢出。</p>
<img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20210409011416.png" style="zoom: 33%;" />

<p>基本原理就如上图所示，但实际上直接修改函数返回地址将其指向恶意代码是很难实现的，因为操作系统每次加载可执行文件到进程空间的位置都不是固定的，因此栈的位置实际是不固定的。为了解决这个问题，有了通过跳板(<code>jmp esp</code>)进行栈溢出的方式，这里就不展开了，感兴趣的可以看<a href="https://www.jianshu.com/p/47d484b9227e">这篇文章</a>。</p>
<blockquote>
<p> 栈溢出攻击的防护</p>
</blockquote>
<ol>
<li>栈不可执行：利用cpu硬件的特性，将栈设置为不可执行，禁止执行栈上的数据</li>
<li>栈保护：编译时打开栈保护开关，则会在函数的进入和返回的地方增加一些检测指令，在数据被修改时终止程序运行</li>
<li>内存布局随机化：将程序的加载位置、堆栈位置以及动态链接库的映射位置随机化</li>
</ol>
<h6 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h6><p>尾递归是指在一个方法内部，递归调用后直接return，没有任何多余的指令。从函数栈帧角度来想，当前栈帧的所有数据在发生递归调用后都已经无用了，此时就无需将其保存到当前栈帧，只需将参数存入指定寄存器，goto到函数开始的指令继续执行就好了。</p>
<p>比如下面这种求阶乘的写法就不是一个尾递归，因为函数调用结束后还要拿到结果计算乘法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而改写成下面这种写法就可以进行尾递归优化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> sum + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, sum + n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="协程的函数栈切换"><a href="#协程的函数栈切换" class="headerlink" title="协程的函数栈切换"></a>协程的函数栈切换</h6><h4 id="从CPU指令层面理解一些问题"><a href="#从CPU指令层面理解一些问题" class="headerlink" title="从CPU指令层面理解一些问题"></a>从CPU指令层面理解一些问题</h4><h5 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h5><h5 id="混淆编译"><a href="#混淆编译" class="headerlink" title="混淆编译"></a>混淆编译</h5><h5 id="Compare-And-Swap原子操作"><a href="#Compare-And-Swap原子操作" class="headerlink" title="Compare And Swap原子操作"></a>Compare And Swap原子操作</h5><p><a href="https://dslztx.github.io/blog/2020/01/14/CAS/">https://dslztx.github.io/blog/2020/01/14/CAS/</a></p>
<p><a href="https://dslztx.github.io/blog/2019/06/08/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%9A%84LOCK%E6%8C%87%E4%BB%A4%E5%89%8D%E7%BC%80/">https://dslztx.github.io/blog/2019/06/08/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%9A%84LOCK%E6%8C%87%E4%BB%A4%E5%89%8D%E7%BC%80/</a></p>
<h5 id="超线程-hyperthreading"><a href="#超线程-hyperthreading" class="headerlink" title="超线程 hyperthreading"></a>超线程 hyperthreading</h5><blockquote>
<p>现代CPU一般声称有4核8线程、8核16线程等，这是什么意思呢？</p>
</blockquote>
<p>考虑到CPU同内存、IO设备之间存取速度的严重不匹配，出现了乱序执行、分支预测等优化让CPU利用数据装载等待的时间，尽量多的执行后面的指令。但是某些指令必须要等到数据加载完成才能执行，比如数值求和比较等，此时CPU仍有大量空闲时间浪费。</p>
<p>为了提高CPU的利用率，聪明的工程师们想到了在CPU中额外增加一组寄存器，这样可以不覆盖当前线程的寄存器数据，同时执行另一个线程的指令，最大程度的利用计算单元，在可控的成本内（没有增加ALU等运算单元）提升了CPU利用率，这就是超线程。</p>
<h5 id="有趣的优化"><a href="#有趣的优化" class="headerlink" title="有趣的优化"></a>有趣的优化</h5><ol>
<li><p>为什么将循环求和的结果放到一个局部变量中，会比将其放到一个通过指针传递过来的参数中，运行起来更快呢？</p>
<ol>
<li>放到局部变量相当于将结果保存在<code>rax</code>寄存器中；而放到指针传递过来的参数相当于每次都要先根据内存地址读取上一个栈帧中的内存数据到寄存器，求和之后再把寄存器的值保存回内存中。CPU操作寄存器相比于内存耗时不在一个量级。</li>
</ol>
</li>
<li></li>
</ol>
<h3 id="CPU运算"><a href="#CPU运算" class="headerlink" title="CPU运算"></a>CPU运算</h3><h4 id="算术逻辑单元（ALU-Arithmetic-Logic-Unit）"><a href="#算术逻辑单元（ALU-Arithmetic-Logic-Unit）" class="headerlink" title="算术逻辑单元（ALU Arithmetic Logic Unit）"></a>算术逻辑单元（ALU Arithmetic Logic Unit）</h4><h5 id="门电路"><a href="#门电路" class="headerlink" title="门电路"></a>门电路</h5><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20210402014630.png" style="zoom: 33%;" />

<p>异或：<code>A XOR B = (A &amp; ~B) | (~A &amp; B)</code></p>
<img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20210402014901.png" style="zoom:33%;" />

<h5 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h5><p>二进制的加法与十进制加法本质上并无差异，只不过二进制是逢2进1。拿个位举例，有4种组合，00/01/10/11，00和11个位相加的结果为0，01和10个位相加结果为1，这个输入和输出的关系就是<em>异或门</em>计算逻辑；同时对于11相加后需要向上一位进位，也就是<em>与门</em>计算逻辑。</p>
<p>所以通过一个异或门计算出个位，通过一个与门计算出是否进位，就通过电路算出了一个一位数的加法。</p>
<img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20210409011059.png" style="zoom:33%;" />

<p>之所以叫半加器是因为这里只能处理个位加法，对于二位的加法除了加数和被加数之外，还要加上来自个位的进位信号，一共需要3个bit进行相加。要想实现3个数相加，可以通过组合2个半加器和1个或门组成一个<em>全加器</em>。</p>
<img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20210409014052.png" style="zoom:33%;" />

<h6 id="加法器优化"><a href="#加法器优化" class="headerlink" title="加法器优化"></a>加法器优化</h6><h5 id="乘法器"><a href="#乘法器" class="headerlink" title="乘法器"></a>乘法器</h5><h5 id="减法运算"><a href="#减法运算" class="headerlink" title="减法运算"></a>减法运算</h5><h6 id="为什么减法器效率低"><a href="#为什么减法器效率低" class="headerlink" title="为什么减法器效率低"></a>为什么减法器效率低</h6><h6 id="为什么负数的补码要按位取反并加1？"><a href="#为什么负数的补码要按位取反并加1？" class="headerlink" title="为什么负数的补码要按位取反并加1？"></a>为什么负数的补码要按位取反并加1？</h6><h5 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h5><h4 id="提升CPU利用率"><a href="#提升CPU利用率" class="headerlink" title="提升CPU利用率"></a>提升CPU利用率</h4><h5 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h5><h5 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h5><p>好处：可以充分利用CPU，在等待内存操作返回的同时，执行其他指令</p>
<h5 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h5><h6 id="Linux中的likely-unlikely"><a href="#Linux中的likely-unlikely" class="headerlink" title="Linux中的likely/unlikely"></a>Linux中的<code>likely/unlikely</code></h6><h5 id="并行计算：SIMD"><a href="#并行计算：SIMD" class="headerlink" title="并行计算：SIMD"></a>并行计算：SIMD</h5><h5 id="一些有趣小🌰"><a href="#一些有趣小🌰" class="headerlink" title="一些有趣小🌰"></a>一些有趣小🌰</h5><ul>
<li>找出一个数组中小于某数x的个数。排序后的数组运行更快</li>
<li>两个for循环嵌套，循环次数多的写里面</li>
</ul>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h4 id="MMU与TLB"><a href="#MMU与TLB" class="headerlink" title="MMU与TLB"></a>MMU与TLB</h4><h4 id="M-Modified-E-Exclusive-S-Shared-I-Invalid-协议"><a href="#M-Modified-E-Exclusive-S-Shared-I-Invalid-协议" class="headerlink" title="M(Modified) E(Exclusive) S(Shared) I(Invalid)协议"></a>M(Modified) E(Exclusive) S(Shared) I(Invalid)协议</h4><p>缓存行有4种不同的状态</p>
<ol>
<li><strong>已修改Modified（M）：</strong>缓存行是脏的，与主存的值不同。如果别的CPU内核要读主存这块数据，该缓存行必须回写到主存，状态变为共享（S）</li>
<li><strong>独占Exclusive（E）：</strong>缓存行只在当前缓存中，而且与主存值相同。当别的缓存读取它时，状态变为共享；当前写数据时，变为已修改状态</li>
<li><strong>共享Shared（S）：</strong>缓存行也存在与其他缓存中且是干净的，缓存行可以在任意时刻抛弃</li>
<li><strong>无效Invalid（I）：</strong>缓存行是无效的</li>
</ol>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20211017180553.png"></p>
<p>上图为4中状态间的有限状态机转换，有两种场景会触发状态的转换：</p>
<ol>
<li>缓存所在CPU的读写（上图中左半部黑实线）<ol>
<li>PrRd：处理器请求读一个缓存块</li>
<li>PrWr：处理器请求写一个缓存块</li>
</ol>
</li>
<li>其他CPU的读写，通过总线发送信号，然后被其他总线snooper嗅探到（上图中右半部红虚线）<ol>
<li>BusRd：嗅探到其他处理器请求<strong>读</strong>一个缓存块</li>
<li>BusRdX：嗅探到其他处理器请求<strong>写</strong>一个该处理器<strong>不拥有</strong>的缓存块</li>
<li>BusUpgr：嗅探到其他处理器请求<strong>写</strong>一个该处理器<strong>拥有的</strong>缓存块</li>
<li>Flush：snooper请求<strong>回写</strong>整个缓存到主存</li>
<li>FlushOpt：snooper请求将整个缓存块发送到另一个处理器（缓存到缓存的赋复制）</li>
</ol>
</li>
</ol>
<h4 id="CacheLine与伪共享"><a href="#CacheLine与伪共享" class="headerlink" title="CacheLine与伪共享"></a>CacheLine与伪共享</h4><p>一个CacheLine包含：标识位、和内存匹配tag、数据块。其中标识位包含：V（Valid）表示这个缓存块是否被使用，M（Modified）表示这个缓存块是否被写过。数据块大小一般为64Byte。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># getconf -a | grep CACHE</span><br><span class="line"></span><br><span class="line">LEVEL1_ICACHE_SIZE                 32768</span><br><span class="line">LEVEL1_ICACHE_ASSOC                8</span><br><span class="line">LEVEL1_ICACHE_LINESIZE             64</span><br><span class="line">LEVEL1_DCACHE_SIZE                 32768</span><br><span class="line">LEVEL1_DCACHE_ASSOC                8</span><br><span class="line">LEVEL1_DCACHE_LINESIZE             64</span><br><span class="line">LEVEL2_CACHE_SIZE                  2097152</span><br><span class="line">LEVEL2_CACHE_ASSOC                 8</span><br><span class="line">LEVEL2_CACHE_LINESIZE              64</span><br><span class="line">LEVEL3_CACHE_SIZE                  16777216</span><br><span class="line">LEVEL3_CACHE_ASSOC                 16</span><br><span class="line">LEVEL3_CACHE_LINESIZE              64</span><br><span class="line">LEVEL4_CACHE_SIZE                  0</span><br><span class="line">LEVEL4_CACHE_ASSOC                 0</span><br><span class="line">LEVEL4_CACHE_LINESIZE              0</span><br></pre></td></tr></table></figure>

<p>L1 数据Cache大小为32K，包含32 * 1024 / 64 = 512个CacheLine，标识为和tag有专门的电路，不占用缓存块的空间。</p>
<p><a href="https://itimetraveler.github.io/2018/09/09/CPU%20Cache%E4%B8%8E%E7%BC%93%E5%AD%98%E8%A1%8C/">https://itimetraveler.github.io/2018/09/09/CPU%20Cache%E4%B8%8E%E7%BC%93%E5%AD%98%E8%A1%8C/</a></p>
<h3 id="存储与I-O设备"><a href="#存储与I-O设备" class="headerlink" title="存储与I/O设备"></a>存储与I/O设备</h3><h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><h4 id="INT中断"><a href="#INT中断" class="headerlink" title="INT中断"></a>INT中断</h4><ul>
<li>地址总线、数据总线  </li>
<li>ext3/ext4文件系统</li>
</ul>
<h3 id="为什么ARM架构在移动互联网时代大行其道"><a href="#为什么ARM架构在移动互联网时代大行其道" class="headerlink" title="为什么ARM架构在移动互联网时代大行其道"></a>为什么ARM架构在移动互联网时代大行其道</h3><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul>
<li>FUTEX(Fast Userspace muTEX)系统调用</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h4><h5 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h5><h5 id="小对象分配"><a href="#小对象分配" class="headerlink" title="小对象分配"></a>小对象分配</h5><h4 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h4><h5 id="页表布局"><a href="#页表布局" class="headerlink" title="页表布局"></a>页表布局</h5><p><a href="https://github.com/lorenzo-stoakes/linux-vm-notes/blob/master/sections/page-tables.md">https://github.com/lorenzo-stoakes/linux-vm-notes/blob/master/sections/page-tables.md</a></p>
<p>Linux中有4级页表，每级由<code>pXXval_t</code>包装而成的 <code>pXX_t</code>类型的数组组成</p>
<ol>
<li>Page Global Directory (PGD)</li>
<li>Page Upper Directory (PUD)</li>
<li>Page Middle Directory (PMD)</li>
<li>Page Table Entry Directory (PTE)</li>
</ol>
<p>这些类型的具体定义取决于不同的arch，比如在x86架构下的定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>   <span class="type">pgdval_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>   <span class="type">pudval_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>   <span class="type">pmdval_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>   <span class="type">pteval_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">pgdval_t</span> pgd; &#125; <span class="type">pgd_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">pudval_t</span> pud; &#125; <span class="type">pud_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">pmdval_t</span> pmd; &#125; <span class="type">pmd_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="type">pteval_t</span> pte; &#125; <span class="type">pte_t</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>p[gum]d_t</code>结构定义在<a href="https://code.woboq.org/linux/linux/arch/x86/include/asm/pgtable_types.h.html">arch/x86/include/asm/pgtable_types.h</a>中，而<code>pte_t</code>和<code>pXXval_t</code>类型定义在<a href="https://code.woboq.org/linux/linux/arch/x86/include/asm/pgtable_64_types.h.html">arch/x86/include/asm/pgtable_64_types.h</a>中，通过宏定义在<code>pgtable_types</code>文件中被include，这样是为了尽量复用32和64位x86代码。</p>
</li>
<li><p>在64位x86架构，以及4KB页大小情况下，每个PGD/PUD/PMD/PTE页表均包含512个指针，指向下一级页表的地址，每个指针8byte，即每个页表占用4KB内存空间，刚好一个内存页。每个页表可包含的指针个数使用宏定义<code>PTRS_PER_XXX</code>，例如<a href="https://code.woboq.org/linux/linux/arch/x86/include/asm/pgtable_64_types.h.html#_M/PTRS_PER_PGD">PTRS_PER_PGD</a>，<a href="https://code.woboq.org/linux/linux/arch/x86/include/asm/pgtable_64_types.h.html#_M/PTRS_PER_PTE">PTRS_PER_PTE</a></p>
</li>
<li><p>虚拟地址对应的每个页表的下标需要先通过<code>&gt;&gt;</code>然后<code>&amp; MASK</code>计算得出</p>
<ul>
<li>右移位数：<code>PGDIR_SHIFT=39, PUD_SHIFT=30, PMD_SHIFT=21, PAGE_SHIFT=12</code></li>
<li>MASK：以<code>PTRS_PER_XXX - 1</code>为掩码，将所有高于第9位的位全部置0</li>
</ul>
</li>
<li><p>计算每个页表的index被定义成了inline函数，比如下面这个计算pte在pmd中的index的方法</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">pte_index</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (address &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过页表基地址+index可以获得下一级页表的基地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pte_t</span> *<span class="title function_">pte_offset_kernel</span><span class="params">(<span class="type">pmd_t</span> *pmd, <span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">pte_t</span> *)pmd_page_vaddr(*pmd) + pte_index(address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>PGD的虚拟基地址存储在每个进程的<a href="https://code.woboq.org/linux/linux/include/linux/mm_types.h.html#mm_struct::(anonymous)::pgd">struct mm_struct-&gt;pgd</a>字段中，对应的物理地址存储在CR3寄存器中，并随着进程切换而改变</li>
<li>依次调用<a href="https://code.woboq.org/linux/linux/arch/x86/include/asm/pgtable.h.html#1003">pgd_offset_k</a> -&gt; <a href="https://code.woboq.org/linux/linux/arch/x86/include/asm/pgtable.h.html#pud_offset">pud_offset</a> -&gt; <a href="https://code.woboq.org/linux/linux/arch/x86/include/asm/pgtable.h.html#pmd_offset">pmd_offset</a> -&gt; <a href="https://code.woboq.org/linux/linux/arch/x86/include/asm/pgtable.h.html#pte_offset_kernel">pte_offset_kernel</a>来查找页表项的虚拟地址，流程图如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000000000</span> <span class="number">000000010</span> <span class="number">000000101</span> <span class="number">000000110</span> <span class="number">100100101</span> <span class="number">000000100100</span></span><br><span class="line">[   RESERVED   ] [  PGD  ] [  PUD  ] [  PMD  ] [  PTE  ] [  OFFSET  ]</span><br><span class="line"></span><br><span class="line">PGD offset =    <span class="number">000000010</span> = <span class="number">2</span></span><br><span class="line">PUD offset =    <span class="number">000000101</span> = <span class="number">5</span></span><br><span class="line">PMD offset =    <span class="number">000000110</span> = <span class="number">6</span></span><br><span class="line">PTE offset =    <span class="number">100100101</span> = <span class="number">293</span></span><br><span class="line">phy offset = <span class="number">000000100100</span> = <span class="number">36</span></span><br><span class="line"></span><br><span class="line">         PGD</span><br><span class="line">        -----   </span><br><span class="line">      <span class="number">0</span> |   |         PUD</span><br><span class="line">      . |   |        -----   </span><br><span class="line">      <span class="number">2</span> |~~~|-----&gt;<span class="number">0</span> |   |   </span><br><span class="line">      . |   |      . |   |         PMD</span><br><span class="line">      . |   |      . |   |        -----   </span><br><span class="line">      . |   |      <span class="number">5</span> |~~~|-----&gt;<span class="number">0</span> |   |   </span><br><span class="line">      . |   |      . |   |      . |   |         PTE</span><br><span class="line">      . |   |      . |   |      . |   |        -----   </span><br><span class="line">    <span class="number">512</span> -----      . |   |      <span class="number">6</span> |~~~|-----&gt;<span class="number">0</span> |   |   </span><br><span class="line">                   . |   |      . |   |      . |   |   </span><br><span class="line">                 <span class="number">512</span> -----      . |   |      . |   |   </span><br><span class="line">                                . |   |      . |   |   </span><br><span class="line">                                . |   |      . |   |     physical page</span><br><span class="line">                              <span class="number">512</span> -----      . |   |        -----</span><br><span class="line">                                           <span class="number">293</span> |~~~|-----&gt;<span class="number">0</span> |   |</span><br><span class="line">                                             . |   |      . |   |</span><br><span class="line">                                           <span class="number">512</span> -----     <span class="number">36</span> | h |</span><br><span class="line">                                                          . | e |</span><br><span class="line">                                                          . | l |</span><br><span class="line">                                                          . | l |</span><br><span class="line">                                                          . | o |</span><br><span class="line">                                                         <span class="number">41</span> | ! |</span><br><span class="line">                                                          . |   |</span><br><span class="line">                                                        <span class="number">4096</span>-----</span><br></pre></td></tr></table></figure>

<h5 id="Page-Table-Entry-Flags"><a href="#Page-Table-Entry-Flags" class="headerlink" title="Page Table Entry Flags"></a>Page Table Entry Flags</h5><ul>
<li>由于每个页目录项是页对齐的，所以每个页表首地址的低<code>PAGE_SHIFT</code>位都是0，也就是说<code>PGD/PUD/PMD/PTE</code>中指针的值低<code>PAGE_SHIFT</code>位是没用到的，这样就可以将这些位作为标志位存储page的配置信息。另外在x86-64架构中，只有46个可寻址位，所以不参与寻址的高位也可以存储标志位</li>
<li>这样做的影响是：计算页目录index时需要忽略标志位。在页大小为4KB情况下，是通过<a href="https://code.woboq.org/linux/linux/arch/x86/include/asm/pgtable_types.h.html#_M/PTE_PFN_MASK">PTE_PFN_MASK</a>和<a href="https://code.woboq.org/linux/linux/arch/x86/include/asm/pgtable_types.h.html#_M/PTE_FLAGS_MASK">PTE_FLAGS_MASK</a>两个宏定义计算的。更大的页大小需要些特殊处理，这里先不赘述了，会在[Huge Page](#Huge Page)一节详述。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PAGE_MASK = ~((<span class="number">1UL</span> &lt;&lt; <span class="number">12</span>) - <span class="number">1</span>) = </span><br><span class="line"><span class="number">1111111111111111111111111111111111111111111111111111000000000000</span></span><br><span class="line"></span><br><span class="line">__PHYSICAL_MASK = ((<span class="number">1UL</span> &lt;&lt; <span class="number">52</span>) - <span class="number">1</span>) = </span><br><span class="line"><span class="number">0000000000001111111111111111111111111111111111111111111111111111</span></span><br><span class="line"></span><br><span class="line">PTE_PFN_MASK = PAGE_MASK &amp; __PHYSICAL_MASK = </span><br><span class="line"><span class="number">1111111111111111111111111111111111111111111111111111000000000000</span></span><br><span class="line"><span class="number">0000000000001111111111111111111111111111111111111111111111111111</span> = </span><br><span class="line"><span class="number">0000000000001111111111111111111111111111111111111111000000000000</span></span><br><span class="line"></span><br><span class="line">PTE_FLAGS_MASK = ~PTE_PFN_MASK =</span><br><span class="line"><span class="number">1111111111110000000000000000000000000000000000000000111111111111</span></span><br><span class="line">  </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pteval_t</span> pte_flags(<span class="type">pte_t</span> pte)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> native_pte_val(pte) &amp; PTE_FLAGS_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这些额外的标志位用于表示页表项中的页的各种状态，有一点需要弄清楚：PGD中的 <code>pdg_t</code>条目的标志位代表的是其指向的PUD页的状态，所以每一个<code>pXX_t</code>条目的标志位实际上表示的是下一级<code>PXX</code>页的状态</li>
<li>标志位的取值通过<code>(pXX_FLAGS_MASK &amp; pXX_val) &amp; (((pteval_t)1) &lt;&lt; FLAG_OFFSET)</code>计算，比如<code>pte_write = pte_flags(pte) &amp; (1UL &lt;&lt; 1)</code></li>
<li>一些常用的标志位含义（全部定义可见<a href="https://code.woboq.org/linux/linux/arch/">arch</a>/<a href="https://code.woboq.org/linux/linux/arch/x86/">x86</a>/<a href="https://code.woboq.org/linux/linux/arch/x86/include/">include</a>/<a href="https://code.woboq.org/linux/linux/arch/x86/include/asm/">asm</a>/<a href="https://code.woboq.org/linux/linux/arch/x86/include/asm/pgtable_types.h.html">pgtable_types.h</a>）<ul>
<li><code>_PAGE_PRESENT</code>: 用于确定页在内存中是否可用，还是由于页换出或其他原因导致不可用</li>
<li><code>_PAGE_RW</code>: 如果清除该标志，则内存页是只读的（常用语Copy On Write）</li>
<li><code>_PAGE_USER</code>: 如果清除该标志，则只有内核态能访问内存页</li>
<li><code>_PAGE_ACCESSED</code>: 页面已被访问，如果在创建页面时将其清除，则对该页面的首次访问将设置该标志，并且该标志将保持设置状态，直到手动清除为止</li>
<li><code>_PAGE_DIRTY</code>: 页面已被修改，如果在创建页面时将其清除，则对该页面的首次写入将设置该标志，并且该标志将保持设置状态，直到手动清除为止</li>
<li><code>_PAGE_PSE</code>: 为1则表示该页是一个Huge Page，即1GB或2MB而不是4KB</li>
<li><code>_PAGE_GLOBAL</code>: 为1则表示普通的TLB缓存刷新不会驱逐该页</li>
</ul>
</li>
</ul>
<h5 id="PGD与进程切换"><a href="#PGD与进程切换" class="headerlink" title="PGD与进程切换"></a>PGD与进程切换</h5><h5 id="Huge-Page"><a href="#Huge-Page" class="headerlink" title="Huge Page"></a>Huge Page</h5><h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><h2 id="程序链接与装载"><a href="#程序链接与装载" class="headerlink" title="程序链接与装载"></a>程序链接与装载</h2><ol>
<li>Preprocess -&gt; Compile -&gt; Assemble -&gt; Link</li>
</ol>
<h3 id="库打桩机制"><a href="#库打桩机制" class="headerlink" title="库打桩机制"></a>库打桩机制</h3><ul>
<li>编译时打桩：利用编译器的<code>-I</code>参数，以及宏定义，在编译时将目标函数的声明替换掉。典型的应用有：<ul>
<li>Redis中根据不同的编译参数选择使用不同的内存分配器，并将<code>malloc</code>, <code>free</code>等函数利用宏定义替换成不同内存分配器的函数声明，比如<code>je_malloc</code>, <code>je_free</code></li>
</ul>
</li>
<li>链接时打桩</li>
<li>运行时打桩</li>
</ul>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="链接的接口——符号"><a href="#链接的接口——符号" class="headerlink" title="链接的接口——符号"></a>链接的接口——符号</h4><ul>
<li><p>C++中namespace与函数重载在符号表中的体现：编译器根据函数签名中的函数名、参数类型以及所在类和命名空间生成修饰后名称，保证链接时不会出现函数重复定义。下面是GCC编译器生成修饰后名称，</p>
<table>
<thead>
<tr>
<th>函数签名</th>
<th>修饰后名称</th>
</tr>
</thead>
<tbody><tr>
<td>int func(int)</td>
<td>_Z4funci</td>
</tr>
<tr>
<td>float func(float)</td>
<td>_Z4funcf</td>
</tr>
<tr>
<td>int ClassA::func(int)</td>
<td>_ZN6ClassA4funcEi</td>
</tr>
<tr>
<td>int ClassA::ClassB::func(int)</td>
<td>_ZN6ClassA6ClassB4funcEi</td>
</tr>
<tr>
<td>int NamespaceA::ClassC::func(int)</td>
<td>_ZN10NamespaceA6ClassC4funcEi</td>
</tr>
</tbody></table>
</li>
<li><p>C++中<code>extern &quot;C&quot;</code>用途：告知C++编译器，对于其修饰的代码块，不要按照C++函数修饰规则生成符号。这在C++程序调用C库函数，或C++程序暴露C函数接口时是非常有必要的，否则在链接时会报<code>undefined reference</code>错误</p>
</li>
<li><p>弱符号：库中定义的弱符号可以被用户定义的强符号所覆盖，弱符号相当于函数的默认实现，用户可以在链接时使用自定义的实现覆盖它，进而使得依赖此函数的第三方在不改动代码的情况下替换函数的功能</p>
</li>
<li><p>弱引用：程序中声明的弱引用在链接时如果没有找到对应的符号，不会报链接错，其函数地址为0。利用此特性，程序可以选择性使用某些扩展功能模块，当链接扩展模块时则使用对应函数，否则也不影响程序正常运行</p>
</li>
</ul>
<h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><h5 id="GOT与C-中的虚函数表"><a href="#GOT与C-中的虚函数表" class="headerlink" title="GOT与C++中的虚函数表"></a>GOT与C++中的虚函数表</h5><ul>
<li>C++中的虚函数也是在运行时通过修改对象的虚函数表地址来实现多态的</li>
</ul>
<h5 id="函数的入口一定是main吗"><a href="#函数的入口一定是main吗" class="headerlink" title="函数的入口一定是main吗"></a>函数的入口一定是main吗</h5><p>还有一个衍生问题，为什么main函数在Java中一定要是static的？</p>
<p>程序真正执行的入口是main吗？（glibc中main函数地址并不是ELF中的entry）</p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul>
<li><a href="https://tonydeng.github.io/sdn-handbook/secure/vpn/">https://tonydeng.github.io/sdn-handbook/secure/vpn/</a></li>
<li><a href="https://segmentfault.com/a/1190000008836467">https://segmentfault.com/a/1190000008836467</a></li>
</ul>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><h4 id="FDB-Fowarding-dataase"><a href="#FDB-Fowarding-dataase" class="headerlink" title="FDB(Fowarding dataase)"></a>FDB(Fowarding dataase)</h4><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="ARP-Address-Resolution-Protocol"><a href="#ARP-Address-Resolution-Protocol" class="headerlink" title="ARP(Address Resolution Protocol)"></a>ARP(Address Resolution Protocol)</h4><h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><h5 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h5><h6 id="一些小问题"><a href="#一些小问题" class="headerlink" title="一些小问题"></a>一些小问题</h6><ul>
<li>为什么IPv6在http请求的路径中需要加<code>[]</code>？<ul>
<li>IPv6可以使用双冒号<code>::</code>表示一组0或多组连续的0，但只能出现一次</li>
<li>http url可以使用<code>ip:port</code>作为domain，也可以省略port，此时http默认为80端口，https默认为443端口</li>
<li>如果不用<code>[]</code>扩起，则形如<code>https://2021:0216::1234:6789/path/to</code>的url就没办法区分请求的是<code>2021:0216:0000:0000:0000:0000:0000:1234</code>地址的6789端口还是<code>2021:0216:0000:0000:0000:0000:1234:6789</code>地址的443端口</li>
</ul>
</li>
</ul>
<h4 id="TUN-TAP及其应用"><a href="#TUN-TAP及其应用" class="headerlink" title="TUN/TAP及其应用"></a>TUN/TAP及其应用</h4><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><h4 id="UnixDomain-Socket"><a href="#UnixDomain-Socket" class="headerlink" title="UnixDomain Socket"></a>UnixDomain Socket</h4><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h4 id="Packet-Filtering-amp-iptables"><a href="#Packet-Filtering-amp-iptables" class="headerlink" title="Packet Filtering &amp; iptables"></a>Packet Filtering &amp; iptables</h4><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><h4 id="HTTP家族"><a href="#HTTP家族" class="headerlink" title="HTTP家族"></a>HTTP家族</h4><h5 id="HTTP2特性"><a href="#HTTP2特性" class="headerlink" title="HTTP2特性"></a>HTTP2特性</h5><ol>
<li>Headers压缩：HPACK算法</li>
<li>二进制分帧</li>
<li>多路复用，一个TCP连接能同时承载多个请求。每个流都有一个ID, 即可以同时发送多个请求，不再依赖多个 TCP 连接去实现多流并行了。</li>
<li>解决HTTP头部阻塞（仍未解决TCP头部阻塞）<ul>
<li>HTTP头部阻塞：前一个请求未收到响应时，不能使用该TCP连接发送下一个请求。根本原因还是请求和响应的每一个packet之间缺乏一个key进行关联，导致如果要支持同一个TCP连接同时发送多个请求，在收到不同请求的响应数据包后，无法找到它们对应的是哪个请求以及无法组装同一个响应的不同数据包。而HTTP2引入分帧后，在每个帧中增加了StreamID以串联同一个TCP连接中不同的流。</li>
<li>TCP头部阻塞：由于TCP需要保证消息的有序性，所以一个数据包丢包后，其后面的数据包就算接收到也不会回复ack。意味着后面的数据包都被这个丢失的数据包阻塞了。</li>
</ul>
</li>
<li>服务端推送：服务端可以在客户端的某个请求之后，主动向客户端推送其他资源。这也得益于二进制分帧，通过StreamID可以区分不同的流。而在HTTP中，没办法实现服务端推送，因为客户端区分不了是某个请求的响应还是服务端主动推送的。</li>
</ol>
<h5 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h5><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><p>SSH原理： <a href="https://mp.weixin.qq.com/s/E05ZSzJQFc6efXtvs5sf1g">https://mp.weixin.qq.com/s/E05ZSzJQFc6efXtvs5sf1g</a></p>
<blockquote>
<p>更多内容详见<a href="https://www.ietf.org/rfc/rfc4251.txt">RFC4251</a></p>
</blockquote>
<p>SSH(<code>Secure Shell</code>)是为了在<strong>不安全的网络上</strong>提供安全的远程登录和其他网络服务，用来替代不安全的终端访问方式，例如<code>telnet</code> 。</p>
<p>SSH协议可以理解为一组协议规范，主要包括3个部分：</p>
<ol>
<li>传输层协议<code>[SSH-TRANS]</code>：</li>
<li>用户认证协议<code>[SSH-USERAUTH]</code>：</li>
<li>会话连接协议<code>[SSH-CONNECT]</code>：</li>
</ol>
<p>在传输层依赖于TCP协议，采用非对称加密（非对称加密<a href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">详见</a>）实现身份认证</p>
<h5 id="SSH使用账号密码认证原理"><a href="#SSH使用账号密码认证原理" class="headerlink" title="SSH使用账号密码认证原理"></a>SSH使用账号密码认证原理</h5><h5 id="SSH使用秘钥认证原理"><a href="#SSH使用秘钥认证原理" class="headerlink" title="SSH使用秘钥认证原理"></a>SSH使用秘钥认证原理</h5><p>平常使用<code>ssh user@ip</code>默认使用当前用户的id_rsa秘钥文件，当然也可以通过<code>ssh -i rsa</code>指定私钥。</p>
<ol>
<li><p>私钥中包含了公钥，也就是说通过私钥可以计算出公钥，公私钥计算公式如下，具体可见 <a href="https://tools.ietf.org/html/rfc3447#appendix-A.1.1">RFC3447</a>。通过<code>ssh-keygen -yf ~/.ssh/id_rsa</code>可以提取公钥</p>
<blockquote>
<p>RSAPublicKey ::= SEQUENCE {</p>
<pre><code>      modulus           INTEGER,  -- n
      publicExponent    INTEGER   -- e
  &#125;
</code></pre>
<p>RSAPrivateKey ::= SEQUENCE {</p>
<pre><code>      version           Version,
      modulus           INTEGER,  -- n
      publicExponent    INTEGER,  -- e
      privateExponent   INTEGER,  -- d
      prime1            INTEGER,  -- p
      prime2            INTEGER,  -- q
      exponent1         INTEGER,  -- d mod (p-1)
      exponent2         INTEGER,  -- d mod (q-1)
      coefficient       INTEGER,  -- (inverse of q) mod p
      otherPrimeInfos   OtherPrimeInfos OPTIONAL
  &#125;
</code></pre>
</blockquote>
</li>
<li><p>公钥和私钥计算出的秘钥指纹是相同的。通过<code>ssh-keygen -lf ~/.ssh/id_rsa</code>可以计算fingerprint，秘钥指纹生成算法如下（bigendian）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 07  ssh-rsa 00 00 00 03 01 00 01 00 00 01 01 00 01 ... 63 25</span><br><span class="line">[tag length] [ tag ] [e length ] [   e  ] [n length ] [      n      ]</span><br><span class="line"></span><br><span class="line">*.pub文件中的第二段就是通过：先将公钥按照上面的算法生成的字节，再用base64编码</span><br><span class="line"></span><br><span class="line">ssh-keygen -lf ~/.ssh/id_rsa.pub生成的SHA256摘要指纹是通过：先将公钥按照上面的算法生成的字节，再用sha256算法生成digest，再用base64编码</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><code>ssh -i</code>鉴权流程：</p>
<ol>
<li>客户端与服务端协商产生会话密钥</li>
<li>客户端向服务端发送登录请求（如 <code>root@192.168.0.2</code>），发送的信息包括用户名root以及根据公/私钥计算的公钥指纹，且所有的数据都是经过会话秘钥加密过的</li>
<li>服务端收到数据后使用会话秘钥解密得到登录的用户名root以及秘钥指纹，然后读取<code>/root/.ssh/autorized_keys</code>文件中的所有公钥数据，通过上述算法生成指纹与客户端发送的指纹对比，从而找到客户端对应的公钥</li>
<li>服务端使用找到的客户端公钥对一个随机数进行加密然后发送到客户端</li>
<li>客户端使用私钥对服务的发送的随机数密文进行解密，然后把解密后的结果发给服务端</li>
<li>服务端验证客户端解密后的随机数与之前发送的数据一致，则对客户端的身份验证通过</li>
</ol>
<h5 id="SSH-tunneling原理及使用"><a href="#SSH-tunneling原理及使用" class="headerlink" title="SSH tunneling原理及使用"></a>SSH tunneling原理及使用</h5><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h1 id="后端技能"><a href="#后端技能" class="headerlink" title="后端技能"></a>后端技能</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="InnoDB的Page-Structure"><a href="#InnoDB的Page-Structure" class="headerlink" title="InnoDB的Page Structure"></a>InnoDB的Page Structure</h4><ul>
<li>为什么User Records要以单链表形式存储而非数组呢？<ul>
<li>插入记录O(1)时间复杂度，无需移动数据；而向数组中间插入记录必须挪动后面所有的记录，成本太高</li>
<li>每条记录的大小是不固定的</li>
</ul>
</li>
</ul>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><h4 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h4><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="缓存技术总览"><a href="#缓存技术总览" class="headerlink" title="缓存技术总览"></a>缓存技术总览</h3><h4 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h4><h5 id="TinyLFU"><a href="#TinyLFU" class="headerlink" title="TinyLFU"></a>TinyLFU</h5><h6 id="W-TinyLFU"><a href="#W-TinyLFU" class="headerlink" title="W-TinyLFU"></a>W-TinyLFU</h6><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h4><h5 id="Redis编码"><a href="#Redis编码" class="headerlink" title="Redis编码"></a>Redis编码</h5><h5 id="Redis对象"><a href="#Redis对象" class="headerlink" title="Redis对象"></a>Redis对象</h5><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">0            3 4                7 8          31 32              63 64         127</span><br><span class="line">|&lt;-- type --&gt;| |&lt;-- encoding --&gt;| |&lt;-- lru --&gt;| |&lt;-- refcount --&gt;| |&lt;-- prt --&gt;|</span><br><span class="line"></span><br><span class="line">type: Redis对象类型，String, List, Set, Sorted set, Hash</span><br><span class="line">encoding: 对象的编码类型，Raw, Integer, Hash table, Skiplist, Embstr等</span><br><span class="line">lru: 表示与lru_clock的相对值（用于LRU驱逐策略）；或LFU的数据，低8bit表示frequency，高16bit表示最后访问时间（以分钟为单位）</span><br><span class="line">refcount: 此对象的引用计数</span><br><span class="line">ptr: 指向对象值的指针</span><br></pre></td></tr></table></figure>

<h6 id="String-Object"><a href="#String-Object" class="headerlink" title="String Object"></a>String Object</h6><p>字符串长度<code>&lt;= 44</code>使用embstr，否则使用raw string。之所以根据字符串长度有不同的实现，是因为embstr只需要一次内存分配，而raw string需要2次内存分配，而且会产生内存碎片，另外重要的一点是String对象作为最基础的对象，通常长度不会太长（作为command、key等）。</p>
<p>而44这个数字，是因为String Object中一个<code>robj</code>对象占用16字节，<code>sdshdr8</code>占用3字节，<code>\0</code>占用1字节，也就是说就算是一个空字符串也要占用20字节。Redis使用的内存分配器默认是<code>jemalloc</code>，根据class_size向上取整理应要分配32字节，但是这样的话字符串最大长度只有12字节，没办法适用大部分场景。所以就扩大了限制以适配64字节这个size。</p>
<h4 id="Redis通信协议"><a href="#Redis通信协议" class="headerlink" title="Redis通信协议"></a>Redis通信协议</h4><h5 id="RESP（REdis-Serialization-Protocol）"><a href="#RESP（REdis-Serialization-Protocol）" class="headerlink" title="RESP（REdis Serialization Protocol）"></a>RESP（REdis Serialization Protocol）</h5><p>用于Redis Client和Server通信，RESP可以兼顾以下几个优点：1. 实现简单    2. 解析速度快    3. Human readable。</p>
<p>RESP尽量遵循简单的请求-响应模型，即Client发送不同参数组成的命令，Server接收到后处理并响应。但是有2个例外的场景：</p>
<ol>
<li><code>Pipeline</code>：客户端会一次性发送多个请求命令，然后等待批量的响应（多个请求之间用<code>\r\n</code>分隔）</li>
<li><code>Pub/Sub</code>：不再需要客户端主动请求，因为服务端会在Channel有新Message时主动通知客户端</li>
</ol>
<p>RESP支持多种数据类型并可以用一个字节枚举，请求和响应的数据由多种不同数据类型的part组成。每个part的数据以一个字节表示的数据类型开头，<code>\r\n(CRLF)</code>结尾。</p>
<p>RESP3在RESP2的基础上额外增加了多种数据类型，同时协议向后兼容。RESP3在Redis 6.0及以上版本引入，但是为了保证Client的兼容默认是关闭的，可以通过<code>HELLO 3</code>命令升级为RESP3，当然也可以通过<code>HELLO 2</code>降级回RESP2。</p>
<div class="tabs" id="resp数据类型说明"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#resp数据类型说明-1">RESP2</button></li><li class="tab"><button type="button" data-href="#resp数据类型说明-2">RESP3中引入</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="resp数据类型说明-1"><table>
<thead>
<tr>
<th>数据类型</th>
<th>first byte</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>Simple String</td>
<td>+</td>
<td><code>+&lt;string&gt;\r\n</code>。字符串中不能包含CR或LF，所以不是二进制安全的</td>
<td><code>+PONG\r\n</code></td>
</tr>
<tr>
<td>Simple Error</td>
<td>-</td>
<td>规则与Simple String相同。第一个大写单词代表错误码，客户端会把字符串当成异常信息来处理</td>
<td><code>-Error message\r\n</code></td>
</tr>
<tr>
<td>Number</td>
<td>:</td>
<td>64位有符号整数，<code>:&lt;number&gt;\r\n</code>。INCR, LLEN等命令会返回具体的数值，而SETNX, EXISTS等命令会返回1代表<code>true/实际执行了操作</code> 或 0代表<code>false/没有执行操作</code></td>
<td><code>:666\r\n</code></td>
</tr>
<tr>
<td>Blob String</td>
<td>$</td>
<td><code>$&lt;length&gt;\r\n&lt;bytes&gt;\r\n</code>，因为有字节长度，所以是二进制安全的。在RESP2中使用<code>$-1\r\n</code>表示Null，比如GET的key不存在</td>
<td><code>$3\r\nfoo\r\n</code></td>
</tr>
<tr>
<td>Array</td>
<td>*</td>
<td>Client使用数组来发送命令，某些命令Server也会返回数组，例如<code>SMEMBERS</code>。”*” 后面跟着数组长度N，随后是CRLF，接着是N个任何类型的元素（可以是不同类型）</td>
<td><code>*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n</code></td>
</tr>
</tbody></table><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="resp数据类型说明-2"><table>
<thead>
<tr>
<th>数据类型</th>
<th>first byte</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>Null</td>
<td>_</td>
<td><code>_\r\n</code></td>
<td><code>_\r\n</code></td>
</tr>
<tr>
<td>Double</td>
<td>,</td>
<td><code>,&lt;floating-point-number&gt;\r\n</code>，<code>inf</code>表示正无穷，<code>-inf</code>表示负无穷</td>
<td><code>,3.1415926\r\n</code></td>
</tr>
<tr>
<td>Boolean</td>
<td>#</td>
<td><code>#t\r\n</code>代表True，<code>#\f\r\n</code>代表False</td>
<td></td>
</tr>
<tr>
<td>Blob Error</td>
<td>!</td>
<td>规则与Blob String相同。第一个大写单词代表错误码，客户端会把字符串当成异常信息来处理</td>
<td><code>!21\r\nSYNTAX invalid syntax\r\n</code></td>
</tr>
<tr>
<td>Verbatim String</td>
<td>=</td>
<td>规则上与Blob String类似，前三个字节表示富文本类型，比如<code>txt</code>/<code>mkd</code>，第四个字节为<code>:</code>，然后是真正的字符串</td>
<td><code>=8\r\ntxt:test\r\n</code></td>
</tr>
<tr>
<td>Big Number</td>
<td>(</td>
<td>用来代表超过有符号64整数的数字，<code>(&lt;big number&gt;\r\n</code>。大数可以是正数或负数，但不能包含小数部分</td>
<td><code>(3492890328409238509324850943850943825024385\r\n</code></td>
</tr>
<tr>
<td>Map</td>
<td>%</td>
<td>与Array类似，”%”后跟着键值对的个数N，随后是CRLF，接着是N个任何类型的Key-Value对</td>
<td><code>%2\r\n+foo\r\n:1\r\n+bar\r\n#t\r\n</code></td>
</tr>
<tr>
<td>Set</td>
<td>~</td>
<td>与Array类似，不过语义上稍有不同，Set返回的元素是无序的。协议上并没有强制保证Set内的元素不重复，Client需要处理这种情况</td>
<td><code>~3\r\n+foo\r\n:1\r\n#f\r\n</code></td>
</tr>
</tbody></table><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div></div></div>

<blockquote>
<p> 下面我们通过nc命令，使用RESP协议尝试不同的请求命令，加深下理解。</p>
<p><strong><em>Tips：</em></strong>当我们需要在线上环境定位问题时，可能没有易用的redis-cli命令，此时可以使用nc命令按照RESP规范进行请求。当然Redis也提供了另一种简化的使用方式，叫做<code>内联命令(Inline Commands)</code>， 可以通过空格分隔的参数进行请求。</p>
</blockquote>
<div class="tabs" id="resp2协议使用"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#resp2协议使用-1">使用RESP2</button></li><li class="tab"><button type="button" data-href="#resp2协议使用-2">内联命令</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="resp2协议使用-1"><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;*1\r\n$7\r\nUNKNOWN\r\n&#x27; | nc redis 6379</span><br><span class="line">-ERR unknown command `UNKNOWN`, with args beginning with: </span><br><span class="line"></span><br><span class="line">echo &#x27;*2\r\n$3\r\nGET\r\n$3\r\nfoo\r\n&#x27; | nc redis 6379</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">-1</span></span><br><span class="line"></span><br><span class="line">echo &#x27;*3\r\n$3\r\nSET\r\n$3\r\nfoo\r\n$6\r\nfooval\r\n&#x27; | nc redis 6379</span><br><span class="line">+OK</span><br><span class="line"></span><br><span class="line">echo &#x27;*2\r\n$3\r\nGET\r\n$3\r\nfoo\r\n&#x27; | nc redis 6379</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">6</span></span><br><span class="line">fooval</span><br><span class="line"></span><br><span class="line">echo &#x27;*3\r\n$5\r\nSETNX\r\n$3\r\nfoo\r\n$6\r\nfooval\r\n&#x27; | nc redis 6379</span><br><span class="line">:0	# SETNX，此时foo已经存在，所以返回:0表示没有执行操作</span><br><span class="line"></span><br><span class="line">echo &#x27;*5\r\n$5\r\nLPUSH\r\n$3\r\nbar\r\n$2\r\nv1\r\n$2\r\nv2\r\n$2\r\nv3\r\n&#x27; | nc redis 6379</span><br><span class="line">:3</span><br><span class="line"></span><br><span class="line">echo &#x27;*4\r\n$6\r\nLRANGE\r\n$3\r\nbar\r\n$1\r\n0\r\n$2\r\n-1\r\n&#x27; | nc redis 6379 </span><br><span class="line">*3</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2</span></span><br><span class="line">v3</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2</span></span><br><span class="line">v2</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2</span></span><br><span class="line">v1</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="resp2协议使用-2"><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;UNKNOWN&#x27; | nc redis 6379</span><br><span class="line">-ERR unknown command `UNKNOWN`, with args beginning with:</span><br><span class="line"></span><br><span class="line">echo &#x27;GET foo&#x27; | nc redis 6379</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">-1</span></span><br><span class="line"></span><br><span class="line">echo &#x27;SET foo foovalue&#x27; | nc redis 6379</span><br><span class="line">+OK</span><br><span class="line"></span><br><span class="line">echo &#x27;SET foo foovalue NX&#x27; | nc redis 6379</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">-1</span></span><br><span class="line"></span><br><span class="line">echo &#x27;lpush bar v1 v2 v3&#x27; | nc redis 6379</span><br><span class="line">:3</span><br><span class="line"></span><br><span class="line">echo &#x27;lrange bar 0 -1&#x27; | nc redis 6379</span><br><span class="line">*3</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2</span></span><br><span class="line">v3</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2</span></span><br><span class="line">v2</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2</span></span><br><span class="line">v1</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" onclick="scrollToDest($(this).parents('.tabs'),65)"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h4 id="淘汰机制"><a href="#淘汰机制" class="headerlink" title="淘汰机制"></a>淘汰机制</h4><ul>
<li>每次lookupKey都会更新robj的lru值</li>
<li>LFU的低16位存储上次访问的时间戳对应的分钟数</li>
</ul>
<h3 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h3><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h2 id="编码-amp-压缩-amp-加密"><a href="#编码-amp-压缩-amp-加密" class="headerlink" title="编码 &amp; 压缩 &amp; 加密"></a>编码 &amp; 压缩 &amp; 加密</h2><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>编码的本质就是双方根据一定的规则对数据进行处理</p>
<h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><ul>
<li>字符：各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。 也就是说，它是一个信息单位，一个数字是一个字符，一个文字是一个字符，一个标点符号也是一个字符。</li>
<li>字符集：字符的集合，不同集合支持的字符范围自然也不一样，譬如ASCII只支持英文，GB18030支持中文等等。在字符集中存在一个码表，每个字符在各自字符集对应着唯一一个码。但是同一个字符在不同的字符集中对应的码不同，比如字符“世”在Unicode中为<code>U+4e16</code>，在GBK中为<code>0xcac0</code></li>
<li>字符编码：定义字符集中的字符如何编码为特定的二进制数，以便在计算机中存储。字符集与字符编码通常是一一对应的，比如GB18030既可以代表字符集也可以代表字符编码，它为了兼容ASCII码，编码方式为大于255采用两字节来代表一个字符，否则就是兼容模式，一个字节代表一个字符。当然也存在特例，比如Unicode字符集就有多种编码实现（UTF-8，UTF-16等）</li>
</ul>
<h5 id="字符集与字符编码发展史"><a href="#字符集与字符编码发展史" class="headerlink" title="字符集与字符编码发展史"></a>字符集与字符编码发展史</h5><ul>
<li>最早的计算机只需要使用英文符号，加上数字和一些特殊符号，然后用8位二进制映射到128个不同的字符串里，这样就能表示日常需要的所有字符了，这就是我们常说的ASCII码（American Standard Code for Information Interchange，美国信息交换标准代码）。在ASCII码中，0<del>31是控制字符如换行删除等，32</del>126是可打印字符可以通过键盘输出并显示出来。</li>
<li>后来计算机传入欧洲，一些欧洲国家决定对ASCII编码进行适当的“改造”：利用字节中闲置的最高位编入新的符号，这样一来可以表示最多256个符号。但是欧洲的语言体系有个特点：小国家特别多，每个国家可能都有自己的语言体系，因此即便有256个字符也没办法统一欧洲的语言环境。后来大家想了一个折中的方案：在256个字符中，前128字符和ASCII编码表示的字符完全一样，后128个字符每个国家或地区都有自己的编码标准。根据这个规则，形成了很多子标准：ISO-8859-1、ISO-8859-2。。。</li>
<li>计算机传入亚洲后，国际标准已被完全不够用，各个国家根据自己的地区特色，发明了适用自身的字符集与编码，譬如中国大陆的GB2312，日本的Shift JIS等等 这些编码都是用双字节来进行存储，它们对外有一个统称ANSI（American National Standards Institute），也就是说GB2312或Shift JIS等都是ANSI在各自地区的不同标准。</li>
<li>到了全球互联网时代，不同国家需要在互联网上进行信息交互，这时候由于各自编码标准都不一样，彼此之间都是乱码，无法良好的沟通交流。于是这时候ISO组织与统一码联盟整合推出了Unicode字符集，它使用4字节的数字来表达每个字符。每个数字代表唯一的至少在某种语言中使用的字符。这时候所有的字符都可以采用同一个字符集，有着相同的编码，可以愉快的进行交流了。</li>
</ul>
<h5 id="UTF-8编码规则"><a href="#UTF-8编码规则" class="headerlink" title="UTF-8编码规则"></a>UTF-8编码规则</h5><p><strong>UTF-8</strong>（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容。</p>
<p>UTF-8 的编码规则很简单：</p>
<ol>
<li>对于单字节字符，与ASCII编码完全相同</li>
<li>对于<code>n</code>字节的字符，第一个字节的前<code>n</code>个bit都置为1，第<code>n+1</code>个bit置为<code>0</code>，后面字节的前两位一律置为<code>10</code>，剩余的bit用于从左至右依次存储Unicode的码点</li>
</ol>
<p>Unicode与UTF-8转换关系表</p>
<table>
<thead>
<tr>
<th>Unicode码点位数</th>
<th>Unicode码点范围</th>
<th>UTF-8字节序</th>
</tr>
</thead>
<tbody><tr>
<td>[0, 7]</td>
<td>U+0000~U+007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>[8, 11]</td>
<td>U+0080~U+07FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>[12, 16]</td>
<td>U+0800~U+FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>[17, 21]</td>
<td>U+10000~U+1FFFFF</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>[22, 26]</td>
<td>U+200000~U+3FFFFFF</td>
<td>111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>[27, 31]</td>
<td>U+4000000~U+7FFFFFFF</td>
<td>1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<p>举几个例子</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>Unicode</th>
<th>UTF-8</th>
</tr>
</thead>
<tbody><tr>
<td>Ā</td>
<td>U+0100</td>
<td>11000100 10000000 = C4 80</td>
</tr>
<tr>
<td>世</td>
<td>U+4E16</td>
<td>11100100 10111000 10010110 = E4 B8 96</td>
</tr>
<tr>
<td>🎅</td>
<td>U+1F385</td>
<td>11110000 10011111 10001110 10000101 = F0 9F 8E 85</td>
</tr>
</tbody></table>
<h5 id="手持两把锟斤拷，口中疾呼烫烫烫"><a href="#手持两把锟斤拷，口中疾呼烫烫烫" class="headerlink" title="手持两把锟斤拷，口中疾呼烫烫烫"></a>手持两把锟斤拷，口中疾呼烫烫烫</h5><h5 id="MySQL中的utf8mb4"><a href="#MySQL中的utf8mb4" class="headerlink" title="MySQL中的utf8mb4"></a>MySQL中的utf8mb4</h5><p>utf8无法存储emoji，因为MySQL中的utf8最多只用3字节存储，而emoji使用4字节编码，比如🎅的16进制编码为<code>0xF09F8E85</code></p>
<h5 id="Python2中讨厌的编码"><a href="#Python2中讨厌的编码" class="headerlink" title="Python2中讨厌的编码"></a>Python2中讨厌的编码</h5><h4 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h4><h5 id="varint"><a href="#varint" class="headerlink" title="varint"></a>varint</h5><h5 id="zigzag"><a href="#zigzag" class="headerlink" title="zigzag"></a>zigzag</h5><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><h5 id="simdjson是何方神圣"><a href="#simdjson是何方神圣" class="headerlink" title="simdjson是何方神圣"></a>simdjson是何方神圣</h5><h4 id="Base64家族"><a href="#Base64家族" class="headerlink" title="Base64家族"></a>Base64家族</h4><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><h4 id="GZip"><a href="#GZip" class="headerlink" title="GZip"></a>GZip</h4><h4 id="LZ4"><a href="#LZ4" class="headerlink" title="LZ4"></a>LZ4</h4><h4 id="Snappy"><a href="#Snappy" class="headerlink" title="Snappy"></a>Snappy</h4><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><h5 id="RSA算法的数学原理"><a href="#RSA算法的数学原理" class="headerlink" title="RSA算法的数学原理"></a>RSA算法的数学原理</h5><ul>
<li><a href="https://segmentfault.com/a/1190000014871852">https://segmentfault.com/a/1190000014871852</a></li>
</ul>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p><a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><h2 id="内存分配与回收"><a href="#内存分配与回收" class="headerlink" title="内存分配与回收"></a>内存分配与回收</h2><p>分配器多种多样，比如通用的jemalloc、tcmalloc，或者各个语言自己实现的比如pymalloc，但是他们的目标是一样的：</p>
<ol>
<li>基本功能：将一块内存根据固定单位的页定义出来，然后区分对象大小分别管理内存，小内存分成若干类，专门用来分配固定大小的内存块，并用一个表管理起来，降低内部碎片，减少Page Fault，提升内存分配速度。大内存则以页为单位管理，配合小对象所在页， 降低碎片。</li>
<li>回收：当释放内存时，要能够合并小内存为大内存，根据一些条件，该保留的就保留下来，在下次使用时可以快速响应</li>
<li>多线程下性能优化：每个线程独占一段内存，被称为TLS，这样线程内操作时可以不加锁，提高性能。当独占的内存不够用时再从全局的内存中分配。但随之而来的也有些待解决的问题：<ol>
<li>如何尽量减少到全局内存池中分配导致锁冲突</li>
<li>如何解决不同线程内存利用率不一致导致的overhead</li>
<li>如何在空闲时将线程独占内存释放回全局内存中以便其他线程使用</li>
</ol>
</li>
</ol>
<p>当占用内存的对象不再可能被使用的时候，需要对其使用的内存进行回收，常见的回收算法有<em>引用计数法</em>，<em>标记清除法</em>，它们的目标是：</p>
<ol>
<li>尽可能多的识别出不使用的内存空间</li>
<li>减少内存回收导致的外部碎片</li>
<li>降低内存回收对程序运行的影响，耗时尽量短</li>
</ol>
<h2 id="eBPF"><a href="#eBPF" class="headerlink" title="eBPF"></a>eBPF</h2><h1 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h1><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h2 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h2><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><ul>
<li>内存管理</li>
</ul>
<h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><h4 id="一切皆对象"><a href="#一切皆对象" class="headerlink" title="一切皆对象"></a>一切皆对象</h4><h5 id="int"><a href="#int" class="headerlink" title="int"></a>int</h5><p><a href="https://www.dongwm.com/post/python-memory-usage-1/">https://www.dongwm.com/post/python-memory-usage-1/</a></p>
<h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p><a href="https://juejin.cn/post/6924192092902146055#heading-12">import原理详细解读</a></p>
<h3 id="奇淫巧技"><a href="#奇淫巧技" class="headerlink" title="奇淫巧技"></a>奇淫巧技</h3><h4 id="new-与-init"><a href="#new-与-init" class="headerlink" title="__new__与__init__"></a><code>__new__</code>与<code>__init__</code></h4><p><code>__new__</code>用于创建对象；<code>__init__</code>用于初始化对象。</p>
<p><code>__new__</code>会在使用<code>ClassName()</code>创建对象时自动调用，<code>__init__</code>会在new返回创建的实例后被调用，并把返回的实例传入<code>__init__</code>，对应入参<code>self</code>。</p>
<p>如果重写了父类的<code>__new__</code>但是并没有返回实例，则不会调用<code>__init__</code></p>
<h4 id="类方法与实例方法"><a href="#类方法与实例方法" class="headerlink" title="类方法与实例方法"></a>类方法与实例方法</h4><p>类方法对应的地址全局唯一，不同的对象对应的类方法id都是相同的。</p>
<p>不同的对象对应的实例方法id是不同的，实例方法也可以通过<code>Class.method(object)</code>调用，实例方法第一个参数是<code>self</code>也就是实例，我们平常用的<code>object.method(args)</code>本质上就是在对象创建时通过<code>Class.method</code>生成一个新的<code>偏函数(partial)</code>，将第一个参数绑定成实例，然后重新<code>setattr(object,  method, partialed_method)</code>。</p>
<h4 id="mock的原理"><a href="#mock的原理" class="headerlink" title="mock的原理"></a>mock的原理</h4><ol>
<li>Python中一切都是对象，module是对象，class是对象，function也是对象</li>
<li>globals() 和 locals()</li>
<li>setattr()</li>
</ol>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h4 id="Object-Header"><a href="#Object-Header" class="headerlink" title="Object Header"></a>Object Header</h4><ul>
<li><a href="https://juejin.cn/post/6844904113306615822">https://juejin.cn/post/6844904113306615822</a></li>
</ul>
<h2 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h2><ul>
<li><a href="http://twitter.github.io/scala_school/index.html">Twitter Scala School</a></li>
</ul>
<h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><h3 id="为什么Go的可执行文件特别小还不需要依赖so"><a href="#为什么Go的可执行文件特别小还不需要依赖so" class="headerlink" title="为什么Go的可执行文件特别小还不需要依赖so"></a>为什么Go的可执行文件特别小还不需要依赖so</h3><h1 id="内功心法"><a href="#内功心法" class="headerlink" title="内功心法"></a>内功心法</h1><p><strong>可维护性 = 当依赖变化时，有多少代码需要随之改变</strong></p>
<p><strong>可扩展性 = 做新需求或改逻辑时，需要新增/修改多少代码</strong></p>
<p><strong>可测试性 = 运行每个测试用例所花费的时间 * 每个需求所需要增加的测试用例数量 * 编写测试用例的难易程度</strong> </p>
<h2 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h2><ul>
<li>四大特性：封装、抽象、继承、多态</li>
<li>与面向过程的区别于联系</li>
<li>接口与抽象类</li>
<li>基于接口而非实现编程</li>
<li>多用组合少用继承</li>
<li>面向过程的贫血模型与面向对象的充血模型</li>
</ul>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ul>
<li>S(Single Responsibility Principle)：单一职责原则</li>
<li>O(Open Close Principle)：开闭原则</li>
<li>L(Liskov Substitution Principle)：里氏替换原则</li>
<li>I(Interface Segregation Principle)：接口隔离原则</li>
<li>D(Dependency Inversion Principle)：依赖导致原则</li>
<li>DRY(Don’t Repeat Yourself)</li>
<li>KISS(Keep It Simple, Silly)</li>
<li>YAGNI(You Aren’t Gonna Need It)</li>
<li>LOD(Law Of Demeter): 迪米特法则，又叫做最少知识原则</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li><p>创建型</p>
<ul>
<li>常用：单例模式、建造者模式、工厂模式（简单工厂、工厂方法）</li>
<li>不常用：抽象工厂、原型模式</li>
</ul>
</li>
<li><p>结构型</p>
<ul>
<li>常用：代理模式、桥接模式、装饰器模式、适配器模式</li>
<li>不常用：门面模式、组合模式、享元模式</li>
</ul>
</li>
<li><p>行为型</p>
<ul>
<li>常用：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、空对象模式</li>
<li>状态：访问者模式、备忘录模式、命令模式、解释器模式、中介模式</li>
</ul>
<h2 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h2></li>
<li><p>命名，命名，还是命名</p>
</li>
<li><p>函数</p>
</li>
<li><p>对象和数据结构</p>
</li>
<li><p>错误处理</p>
</li>
<li><p>类</p>
</li>
</ul>
<h2 id="接口设计规范"><a href="#接口设计规范" class="headerlink" title="接口设计规范"></a>接口设计规范</h2><p>RESTful接口设计可以参照Google的这篇指南</p>
<p><a href="https://cloud.google.com/apis/design">https://cloud.google.com/apis/design</a></p>
<p>具体应用可以参考K8S的接口设计</p>
<p><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#-strong-api-overview-strong-">https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#-strong-api-overview-strong-</a></p>
<h2 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h2><ul>
<li>重构的目的（Why）、对象（What）、时机（When）、方法（How）</li>
<li>保证重构不出错的技术手段：单元测试、代码可测试性</li>
</ul>
<h2 id="领域驱动设计"><a href="#领域驱动设计" class="headerlink" title="领域驱动设计"></a>领域驱动设计</h2><h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><h2 id="批流处理"><a href="#批流处理" class="headerlink" title="批流处理"></a>批流处理</h2><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h2 id="实时分析"><a href="#实时分析" class="headerlink" title="实时分析"></a>实时分析</h2><h1 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h1><h2 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h2><h3 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h3><p><a href="https://code.woboq.org/linux/linux/fs/ioctl.c.html#718">ioctl syscall</a> -&gt; <a href="https://code.woboq.org/linux/linux/fs/ioctl.c.html#ksys_ioctl">ksys_ioctl</a> -&gt; <a href="https://code.woboq.org/linux/linux/fs/ioctl.c.html#do_vfs_ioctl">do_vfs_ioctl</a> -&gt; <a href="https://code.woboq.org/linux/linux/fs/ioctl.c.html#vfs_ioctl">vfs_ioctl</a> -&gt; <a href="https://code.woboq.org/linux/linux/virt/kvm/kvm_main.c.html#3321">unlocked_ioctl</a> -&gt; <a href="https://code.woboq.org/linux/linux/virt/kvm/kvm_main.c.html#kvm_vm_ioctl">kvm_vm_ioctl</a> -&gt; </p>
<h2 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h2><h3 id="容器底层核心技术"><a href="#容器底层核心技术" class="headerlink" title="容器底层核心技术"></a>容器底层核心技术</h3><h4 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h4><h4 id="CGroup"><a href="#CGroup" class="headerlink" title="CGroup"></a>CGroup</h4><ul>
<li>OOM Kill进程的日志可以在<code>/var/log/kern.log</code>中查看，</li>
</ul>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20201203000045.png"></p>
<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><h4 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h4><ul>
<li><a href="https://segmentfault.com/a/1190000007898437">https://segmentfault.com/a/1190000007898437</a></li>
</ul>
<h3 id="Podman"><a href="#Podman" class="headerlink" title="Podman"></a>Podman</h3><h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><h3 id="K8S网络"><a href="#K8S网络" class="headerlink" title="K8S网络"></a>K8S网络</h3><h4 id="Flannel网络原理"><a href="#Flannel网络原理" class="headerlink" title="Flannel网络原理"></a>Flannel网络原理</h4><p><a href="https://blog.laputa.io/kubernetes-flannel-networking-6a1cb1f8ec7c">https://blog.laputa.io/kubernetes-flannel-networking-6a1cb1f8ec7c</a></p>
<ul>
<li>node的annotation中有flannel相关的信息，比如Vtep MAC、PublicIP、podCIDR等</li>
<li>flannel会通过IndexerInformer watch k8s node的变更</li>
<li>对于node的变更，flannel会调用netlink包中的FDB、ARP接口，更新fdb表和路由表</li>
</ul>
<p><a href="http://just4coding.com/2020/04/20/vxlan-fdb/">http://just4coding.com/2020/04/20/vxlan-fdb/</a></p>
<h3 id="Helm"><a href="#Helm" class="headerlink" title="Helm"></a>Helm</h3><p>三大概念</p>
<ol>
<li>Chart：代表一个helm包，包含了运行一个应用/工具/服务所需要的所有资源定义，比如在k8s中部署MySQL需要<a href="https://github.com/helm/charts/blob/master/stable/mysql/templates/deployment.yaml">Deployment定义</a>、<a href="https://github.com/helm/charts/blob/master/stable/mysql/templates/svc.yaml">Service定义</a>、<a href="https://github.com/helm/charts/blob/master/stable/mysql/templates/pvc.yaml">PVC定义</a>等</li>
<li>Repository：存储共享各种Charts的地方</li>
<li>Release：在k8s集群中运行Chart实例，一个Chart可以多次安装到同一集群中，每次安装时都会创建一个新版本。比如在一个集群中运行两个不同版本的MySQL实例</li>
</ol>
<p>常用操作</p>
<ol>
<li><code>helm repo add NAME URL</code>，可以到<a href="https://artifacthub.io搜索各种chart对应的repo.`helm/">https://artifacthub.io搜索各种Chart对应的repo。`helm</a> search repo NAME`，在已经添加的repo中<strong>模糊</strong>搜索Chart</li>
<li><code>helm install NAME CHART Flags</code>，部署Chart到k8s集群，可以指定<code>-f config.yaml</code>或<code>--set key=value</code>覆盖Chart中的配置值。<code>helm upgrade RELEASE CHART</code>，更新Release的配置，一般用于更新配置值</li>
<li><code>helm rollback RELEASE REVISION</code>，回滚Release到指定版本，可以通过<code>helm history RELEASE</code>查看发布历史</li>
<li><code>helm list</code>查看部署的releases，<code>helm uninstall RELEASE</code>将release从集群中卸载</li>
<li><code>helm create NAME</code>创建一个新的Chart，你可以定义自己的Chart，<code>helm lint PATH</code>用于校验写的chart是不是合法的</li>
</ol>
<h2 id="ServiceMesh"><a href="#ServiceMesh" class="headerlink" title="ServiceMesh"></a>ServiceMesh</h2><h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><h1 id="代码之外的软技能"><a href="#代码之外的软技能" class="headerlink" title="代码之外的软技能"></a>代码之外的软技能</h1><h1 id="效率工具"><a href="#效率工具" class="headerlink" title="效率工具"></a>效率工具</h1><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h3>]]></content>
      <categories>
        <category>计算机知识体系构建</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>后端技能</tag>
        <tag>编程语言</tag>
        <tag>内功心法</tag>
        <tag>大数据</tag>
        <tag>云原生</tag>
        <tag>效率工具</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式Python实现</title>
    <url>/posts/ea37/</url>
    <content><![CDATA[<blockquote>
<p>最近找到了一篇容易理解的关于设计模式的文章，比较深刻地讲解了设计模式 <a href="https://blog.csdn.net/lovelion/article/details/17517213">史上最全设计模式导学目录（完整版）</a>。 为了加深自己对设计模式的理解，同时熟悉Python面向对象编程的技巧，遂写下此篇文章，记录每种设计模式对应的一个练习题，并附上Python代码实现。</p>
</blockquote>
<span id="more"></span>

<h2 id="简单工厂模式-Simple-Factory-Pattern"><a href="#简单工厂模式-Simple-Factory-Pattern" class="headerlink" title="简单工厂模式-Simple Factory Pattern"></a>简单工厂模式-Simple Factory Pattern</h2><h4 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h4><p>XX软件公司欲基于Python语言开发一套图表库，该图表库可以为应用系统提供各种不同外观的图表，例如柱状图、饼状图、折线图等。XX软件公司图表库设计人员希望为应用系统开发人员提供一套灵活易用的图表库，而且可以较为方便地对图表库进行扩展，以便能够在将来增加一些新类型的图表。</p>
<h4 id="改进前"><a href="#改进前" class="headerlink" title="改进前"></a>改进前</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chart</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">type</span></span>):</span><br><span class="line">        self._<span class="built_in">type</span> = <span class="built_in">type</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>.lower() == <span class="string">&quot;histogram&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;初始化柱状图&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">type</span>.lower() == <span class="string">&quot;pie&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;初始化饼状图&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">type</span>.lower() == <span class="string">&quot;line&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;初始化折线图&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self._<span class="built_in">type</span>.lower() == <span class="string">&quot;histogram&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;显示柱状图&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> self._<span class="built_in">type</span>.lower() == <span class="string">&quot;pie&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;显示化饼状图&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> self._<span class="built_in">type</span>.lower() == <span class="string">&quot;line&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;显示化折线图&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    histogram = Chart(<span class="string">&quot;histogram&quot;</span>)</span><br><span class="line">    histogram.display()</span><br></pre></td></tr></table></figure>

<p>此实现存在以下几个问题：</p>
<ol>
<li><code>init</code>函数和<code>display</code>函数中进行了大量的<code>if...else...</code>判断，并且均为重复代码</li>
<li>Chart类既负责了所有种类图标的初始化，又负责了显示功能，违背了”单一职责原则”</li>
<li>如果需要新增一种图标的类型，需要修改Chart类的源码，违反了”开闭原则”</li>
</ol>
<h4 id="改进后"><a href="#改进后" class="headerlink" title="改进后"></a>改进后</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod, ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chart</span>(metaclass=ABCMeta):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HistogramChart</span>(<span class="title class_ inherited__">Chart</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化柱状图&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;显示柱状图&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PieChart</span>(<span class="title class_ inherited__">Chart</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化饼状图&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;显示饼状图&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LineChart</span>(<span class="title class_ inherited__">Chart</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;初始化折线图&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;显示折线图&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChartFactory</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">chart_type</span>):</span><br><span class="line">        <span class="keyword">for</span> sc <span class="keyword">in</span> Chart.__subclasses__():</span><br><span class="line">            <span class="keyword">if</span> sc.__name__ == chart_type:</span><br><span class="line">                <span class="keyword">return</span> sc()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    chart = ChartFactory.create(<span class="string">&quot;HistogramChart&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> chart:</span><br><span class="line">        chart.display()</span><br></pre></td></tr></table></figure>

<p>此实现有以下优点：</p>
<ol>
<li>不同种类的图标各司其职</li>
<li>利用Python的特性，省略了在工厂类中<code>if...else...</code>的判断，但是可能会增加使用复杂度，因为客户端要输入具体的类名</li>
<li>新增一种图表，不需要修改原有的代码</li>
</ol>
<h2 id="工厂方法模式-Factory-Method-Pattern"><a href="#工厂方法模式-Factory-Method-Pattern" class="headerlink" title="工厂方法模式-Factory Method Pattern"></a>工厂方法模式-Factory Method Pattern</h2><h4 id="问题背景-1"><a href="#问题背景-1" class="headerlink" title="问题背景"></a>问题背景</h4><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>XX软件公司欲开发一个系统运行日志记录器(Logger)，该记录器可以通过多种途径保存系统的运行日志，如通过文件记录或数据库记录，用户可以通过修改配置文件灵活地更换日志记录方式。在设计各类日志记录器时，Sunny公司的开发人员发现需要对日志记录器进行一些初始化工作，初始化参数的设置过程较为复杂，而且某些参数的设置有严格的先后次序，否则可能会发生记录失败。如何封装记录器的初始化过程并保证多种记录器切换的灵活性是XX公司开发人员面临的一个难题。</p>
<p>XX公司的开发人员通过对该需求进行分析，发现该日志记录器有两个设计要点：</p>
<ul>
<li>需要封装日志记录器的初始化过程，这些初始化工作较为复杂，例如需要初始化其他相关的类，还有可能需要读取配置文件（例如连接数据库或创建文件），导致代码较长，如果将它们都写在构造函数中，会导致构造函数庞大，不利于代码的修改和维护；</li>
<li>用户可能需要更换日志记录方式，在客户端代码中需要提供一种灵活的方式来选择日志记录器，尽量在不修改源代码的基础上更换或者增加日志记录方式。</li>
</ul>
<h4 id="改进前-1"><a href="#改进前-1" class="headerlink" title="改进前"></a>改进前</h4><h4 id="改进后-1"><a href="#改进后-1" class="headerlink" title="改进后"></a>改进后</h4><h2 id="抽象工厂模式-Abstract-Factory-Pattern"><a href="#抽象工厂模式-Abstract-Factory-Pattern" class="headerlink" title="抽象工厂模式-Abstract Factory Pattern"></a>抽象工厂模式-Abstract Factory Pattern</h2><h2 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式-Singleton Pattern"></a>单例模式-Singleton Pattern</h2><h2 id="原型模式-Prototype-Pattern"><a href="#原型模式-Prototype-Pattern" class="headerlink" title="原型模式-Prototype Pattern"></a>原型模式-Prototype Pattern</h2><h2 id="建造者模式-Builder-Pattern"><a href="#建造者模式-Builder-Pattern" class="headerlink" title="建造者模式-Builder Pattern"></a>建造者模式-Builder Pattern</h2><h2 id="适配器模式-Adapter-Pattern"><a href="#适配器模式-Adapter-Pattern" class="headerlink" title="适配器模式-Adapter Pattern"></a>适配器模式-Adapter Pattern</h2><h2 id="桥接模式-Bridge-Pattern"><a href="#桥接模式-Bridge-Pattern" class="headerlink" title="桥接模式-Bridge Pattern"></a>桥接模式-Bridge Pattern</h2><h2 id="组合模式-Composite-Pattern"><a href="#组合模式-Composite-Pattern" class="headerlink" title="组合模式-Composite Pattern"></a>组合模式-Composite Pattern</h2><h2 id="装饰模式-Decorator-Pattern"><a href="#装饰模式-Decorator-Pattern" class="headerlink" title="装饰模式-Decorator Pattern"></a>装饰模式-Decorator Pattern</h2><h2 id="外观模式-Facade-Pattern"><a href="#外观模式-Facade-Pattern" class="headerlink" title="外观模式-Facade Pattern"></a>外观模式-Facade Pattern</h2><h2 id="享元模式-Flyweight-Pattern"><a href="#享元模式-Flyweight-Pattern" class="headerlink" title="享元模式-Flyweight Pattern"></a>享元模式-Flyweight Pattern</h2><h2 id="代理模式-Proxy-Pattern"><a href="#代理模式-Proxy-Pattern" class="headerlink" title="代理模式-Proxy Pattern"></a>代理模式-Proxy Pattern</h2>]]></content>
      <categories>
        <category>内功心法</category>
        <category>编程语言</category>
        <category>设计模式</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>零基础学习kubernetes(一): 基础知识</title>
    <url>/posts/26b4/</url>
    <content><![CDATA[<p>Kubernetes是用于自动部署，扩展和管理容器化应用程序的开源系统。它将组成应用程序的容器组合成逻辑单元，以便于管理和服务发现。</p>
<p>本文介绍了如何使用<a href="https://github.com/kubernetes/minikube"><code>minikube</code></a>，在本机搭建一个k8s集群，并在其上部署应用程序，理解k8s基本的概念和操作。</p>
<span id="more"></span>

<h2 id="使用minikube创建一个集群"><a href="#使用minikube创建一个集群" class="headerlink" title="使用minikube创建一个集群"></a>使用minikube创建一个集群</h2><h3 id="kubernetes集群"><a href="#kubernetes集群" class="headerlink" title="kubernetes集群"></a>kubernetes集群</h3><p>Kubernetes协调一个高度可用的计算机集群，这些计算机集群作为一个单元连接到一起工作。</p>
<p>Kubernetes集群由两种类型的资源组成:</p>
<ol>
<li><code>Master</code>协调集群</li>
<li><code>Nodes</code>是运行应用程序的wokers</li>
</ol>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://d33wubrfki0l68.cloudfront.net/99d9808dcbf2880a996ed50d308a186b5900cec9/40b94/docs/tutorials/kubernetes-basics/public/images/module_01_cluster.svg"></p>
<p><strong>主服务器负责管理集群</strong>。主协调集群中的所有活动，例如调度应用程序、维护应用程序所需的状态、扩展应用程序和推出新更新。</p>
<p><strong>Node是作为Kubernetes集群中的工作机器的VM或物理计算机。</strong>每个节点都有一个Kubelet，它是管理节点和与Kubernetes主机通信的代理。节点还应该有处理容器操作的工具，比如Docker或rkt。处理生产流量的Kubernetes集群至少应该有三个节点。</p>
<p>当在Kubernetes上部署应用程序时，主程序调度容器在集群的节点上运行。节点使用Kubernetes API与主节点通信，主节点公开了该API。最终用户还可以直接使用Kubernetes API与集群交互。</p>
<h3 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h3><ol>
<li>install minikube<ul>
<li>macOS: <code>brew cask install minikube</code></li>
<li>Linux: <code>curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo cp minikube /usr/local/bin/ &amp;&amp; rm minikube</code></li>
</ul>
</li>
<li>启动集群: <code>minikube start</code>，minikube会在本地启动一个虚拟机，然后在虚拟机中运行k8s集群。</li>
<li>查看集群信息: <code>kubectl cluster-info</code></li>
<li>查看所有节点: <code>kubectl get nodes</code></li>
</ol>
<h2 id="使用kubectl创建发布应用"><a href="#使用kubectl创建发布应用" class="headerlink" title="使用kubectl创建发布应用"></a>使用<code>kubectl</code>创建发布应用</h2><h3 id="k8s部署"><a href="#k8s部署" class="headerlink" title="k8s部署"></a>k8s部署</h3><p>有了k8s集群，我们就可以在其上部署容器化应用了。首先，需要创建一个Kubernetes部署配置。部署指示Kubernetes如何创建和更新应用程序实例。</p>
<p>一旦创建了应用程序实例，Kubernetes部署控制器就会持续监视这些实例。如果承载实例的节点宕机或被删除，部署控制器将替换它。这提供了一个自愈机制来处理机器故障。</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://d33wubrfki0l68.cloudfront.net/152c845f25df8e69dd24dd7b0836a289747e258a/4a1d2/docs/tutorials/kubernetes-basics/public/images/module_02_first_app.svg"></p>
<h3 id="cmd-1"><a href="#cmd-1" class="headerlink" title="cmd"></a>cmd</h3><p>通过<code>kubectl run</code>发布应用程序。我们需要提供发布的<code>name</code>和镜像地址(如果镜像不是来自docker hub，则需要完整的url链接)。</p>
<p>下面我们将部署一个Node.js服务</p>
<ol>
<li>发布应用: <code>kubectl run kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1 --port=8080</code>。这个命令中，k8s帮我们干了三件事情:<ol>
<li>搜索可以运行应用程序实例的合适Node</li>
<li>调度应用程序在该节点上运行</li>
<li>配置集群以在需要时在新节点上重新调度实例</li>
</ol>
</li>
<li>查看发布的应用: <code>kubectl get deployments</code></li>
</ol>
<h2 id="查看Pods和Nodes"><a href="#查看Pods和Nodes" class="headerlink" title="查看Pods和Nodes"></a>查看Pods和Nodes</h2><h3 id="Pods"><a href="#Pods" class="headerlink" title="Pods"></a>Pods</h3><p>在上一节中创建部署时，我们创建了一个Pod来托管应用程序实例。Pod是一个k8s抽象，它表示一组一个或多个应用程序容器(如Docker或rkt)，以及这些容器的一些共享资源。这些资源包括:</p>
<ul>
<li>共享存储，作为卷</li>
<li>网络，作为唯一的集群IP地址</li>
<li>共享如何运行每个容器的信息，例如容器映像版本或要使用的特定端口</li>
</ul>
<p>Pod对特定于应用程序的“逻辑主机”进行建模，并可以包含相对紧密耦合的不同应用程序容器。例如，Pod可能包含一个web服务容器，一个数据库服务容器，一个后端rpc服务容器。Pod中的容器共享一个IP地址和端口空间，它们总是一起定位和调度，并在同一个节点的共享上下文中运行。</p>
<p>Pods是k8s中的原子单位，每个Pod被绑定到预定的节点上，并一直保留到终止(根据重启策略)或删除。如果节点出现故障，则在集群中的其他可用节点上调度相同的pod。</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://d33wubrfki0l68.cloudfront.net/fe03f68d8ede9815184852ca2a4fd30325e5d15a/98064/docs/tutorials/kubernetes-basics/public/images/module_03_pods.svg"></p>
<h3 id="Nodes"><a href="#Nodes" class="headerlink" title="Nodes"></a>Nodes</h3><p>一个Pod运行在一个Node上。Node可以是VM或者物理机器。每一个Node都由master管理。一个Node可以包含多个pods，并且master会自动地在集群中的节点上调度pod。master的调度调度考虑到每个节点上的可用资源。</p>
<p>每个Node至少运行了：</p>
<ol>
<li>kubelet: 负责Kubernetes主机和节点之间通信的进程;它管理机器上运行的Pods和容器。</li>
<li>一个容器运行时(如Docker, rkt)负责从注册表中提取容器映像，解包容器，并运行应用程序。如果容器是紧密耦合的，并且需要共享磁盘等资源，那么它们应该被安排在一个单独的Pod中。</li>
</ol>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://d33wubrfki0l68.cloudfront.net/5cb72d407cbe2755e581b6de757e0d81760d5b86/a9df9/docs/tutorials/kubernetes-basics/public/images/module_03_nodes.svg"></p>
<h3 id="使用常见的kubectl命令进行故障排除"><a href="#使用常见的kubectl命令进行故障排除" class="headerlink" title="使用常见的kubectl命令进行故障排除"></a>使用常见的kubectl命令进行故障排除</h3><ul>
<li><strong>kubectl get</strong>: 获取指定资源的列表</li>
<li><strong>kubectl describe</strong>: 获取一个资源的详细信息</li>
<li><strong>kubectl logs</strong>: 打印一个pod的一个容器中的日志</li>
<li><strong>kubectl exec</strong>: 在一个pod的一个容器中执行命令</li>
</ul>
<h2 id="使用service暴露应用程序"><a href="#使用service暴露应用程序" class="headerlink" title="使用service暴露应用程序"></a>使用service暴露应用程序</h2><h3 id="服务为何而生"><a href="#服务为何而生" class="headerlink" title="服务为何而生"></a>服务为何而生</h3><p>考虑具有3个副本的图像处理后端。那些复制品是可替代的; 前端系统不应该关心后端副本，即使Pod丢失并重新创建。也就是说，Kubernetes集群中的每个Pod都有一个唯一的IP地址，甚至是同一节点上的Pod，因此需要有一种方法可以自动协调Pod之间的更改，以便您的应用程序继续运行。</p>
<p>service是k8s中的一个抽象的概念，它定义了一组逻辑Pod和一个访问它们的策略。service如何选择一组pod通常由<code>LabelSelector</code>决定。尽管每个Pod都有一个惟一的IP地址，但如果没有服务，这些IP不会暴露在集群之外。服务允许您的应用程序接收流量。通过在ServiceSpec中指定一个类型，可以以不同的方式公开服务:</p>
<ul>
<li>ClusterIP(默认): 在集群中的内部IP上公开服务。这种类型使得服务只能从集群中访问。</li>
<li>NodePort: 使用NAT在集群中每个选定节点的相同端口上公开服务，使用<code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>从集群外部访问服务。</li>
<li>LoadBalancer: 在当前云中创建一个外部负载均衡器(如果支持的话)，并向服务分配一个固定的外部IP。</li>
<li>Ingress: Ingress 事实上不是一种服务类型。相反，它处于多个服务的前端，扮演着“智能路由”或者集群入口的角色。</li>
</ul>
<blockquote>
<p>资料来源 <a href="http://dockone.io/article/4884">Kubernetes的三种外部访问方式：NodePort、LoadBalancer 和 Ingress</a></p>
</blockquote>
<ol>
<li>暴露服务: <code>kubectl expose deployment/kubernetes-bootcamp --type=&quot;NodePort&quot; --port 8080</code></li>
<li>查看服务: <code>kubectl get svc</code></li>
<li>查看服务详细信息: <code>kubectl describe svc kubernetes-bootcamp</code></li>
</ol>
<h2 id="扩展应用程序"><a href="#扩展应用程序" class="headerlink" title="扩展应用程序"></a>扩展应用程序</h2><p>扩展是通过更改部署中的副本数量来完成的。扩展部署将确保创建新的pod并将其调度到具有可用资源的节点。缩放将增加pod的数量到新的期望状态。</p>
<h3 id="cmd-2"><a href="#cmd-2" class="headerlink" title="cmd"></a>cmd</h3><p>scale的基本命令比较简单，只需要指定<code>replicas</code>的个数就可以了。</p>
<ol>
<li>停止指定部署的所有副本: <code>kubectl scale --replicas=0 deployment/kubernetes-bootcamp</code></li>
</ol>
<h2 id="更新应用程序"><a href="#更新应用程序" class="headerlink" title="更新应用程序"></a>更新应用程序</h2><p>用户希望应用程序随时可用，开发人员希望每天多次部署新版本的应用程序。在Kubernetes，这是通过滚动更新完成的。滚动更新允许部署的更新在零停机的情况下进行，方法是用新的pod实例增量地更新它们。新的pod将被安排在具有可用资源的节点上。</p>
<p>与应用程序扩展类似，如果部署公开暴露，服务将只在更新期间负载均衡到可用的Pod。</p>
<p>滚动更新允许以下操作:</p>
<ul>
<li>将应用程序从一个环境提升到另一个环境(通过容器映像更新)</li>
<li>回滚到以前的版本</li>
<li>持续集成和持续交付应用程序，零停机时间</li>
</ul>
<p>可以通过指定<code>maxUnavailable</code>和<code>maxSurge</code>来控制滚动更新策略。</p>
<ul>
<li><code>maxUnavailable</code>: 指定在更新过程中不可用Pod的最大数量</li>
<li><code>maxSurge</code>: 指定可以超过期望的Pod数量的最大个数</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇介绍了如何使用minikube在本地搭建一个k8s集群，并通过本地集群学习了基本的应用部署、服务暴露、扩展和更新知识。</p>
<p>下一篇，会介绍如何在ECS上(单机)手动部署一个kubernetes集群。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://kubernetes.io/docs/tutorials/">https://kubernetes.io/docs/tutorials/</a></li>
</ul>
]]></content>
      <categories>
        <category>云原生</category>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>零基础学习kubernetes(三): 资源对象</title>
    <url>/posts/9327/</url>
    <content><![CDATA[<p>在学习使用k8s的过程中，我们不免看到许许多多的名词，包括<code>deploy</code>、<code>svc</code>、<code>rs</code>等等，它们通常代表着k8s中不同的资源对象。本文会介绍这些资源，同时会给出部署的yml文件，供实战部署，加深对这些名词的理解。</p>
<span id="more"></span>

<h2 id="Autoscaling"><a href="#Autoscaling" class="headerlink" title="Autoscaling"></a>Autoscaling</h2><p>Horizontal Pod Autoscaling (HPA) 可以根据 CPU 使用率或应用自定义 metrics 自动扩展 Pod 数量（支持 replication controller、deployment 和 replica set ）。</p>
<ul>
<li>控制管理器每隔 30s（可以通过 –horizontal-pod-autoscaler-sync-period 修改）查询 metrics 的资源使用情况</li>
<li>支持三种 metrics 类型<ul>
<li>预定义 metrics（比如 Pod 的 CPU）以利用率的方式计算</li>
<li>自定义的 Pod metrics，以原始值（raw value）的方式计算</li>
<li>自定义的 object metrics</li>
</ul>
</li>
<li>支持两种 metrics 查询方式：Heapster 和自定义的 REST API</li>
<li>支持多 metrics</li>
</ul>
<h2 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h2><p>ConfigMap 用于保存配置数据的键值对，可以用来保存单个属性，也可以用来保存配置文件。ConfigMap 跟 secret 很类似，但它可以更方便地处理不包含敏感信息的字符串。</p>
<h3 id="从yaml文件创建"><a href="#从yaml文件创建" class="headerlink" title="从yaml文件创建"></a>从yaml文件创建</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">special-config</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">env:</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line">  <span class="attr">port:</span> <span class="string">&quot;80&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="ConfigMap使用"><a href="#ConfigMap使用" class="headerlink" title="ConfigMap使用"></a>ConfigMap使用</h3><p>三种分别方式为：</p>
<ol>
<li>设置环境变量</li>
<li>设置容器命令行参数</li>
<li>在 Volume 中直接挂载文件或目录。</li>
</ol>
<blockquote>
<p>Tips</p>
<ul>
<li>ConfigMap 必须在 Pod 引用它之前创建</li>
<li>使用<code>envFrom</code>时，将会自动忽略无效的键</li>
<li>Pod 只能使用同一个命名空间内的 ConfigMap</li>
</ul>
</blockquote>
<p>首先创建 ConfigMap：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create configmap special-config --from-literal=special.how=very --from-literal=special.type=charm</span><br><span class="line">kubectl create configmap env-config --from-literal=log_level=INFO</span><br></pre></td></tr></table></figure>

<h4 id="用作环境变量"><a href="#用作环境变量" class="headerlink" title="用作环境变量"></a>用作环境变量</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">gcr.io/google_containers/busybox</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;env&quot;</span>]</span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SPECIAL_LEVEL_KEY</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">special-config</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">special.how</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SPECIAL_TYPE_KEY</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">special-config</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">special.type</span></span><br><span class="line">      <span class="attr">envFrom:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">configMapRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">env-config</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure>

<p>当 Pod 结束后会输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SPECIAL_LEVEL_KEY=very</span><br><span class="line">SPECIAL_TYPE_KEY=charm</span><br><span class="line">log_level=INFO</span><br></pre></td></tr></table></figure>

<h4 id="使用-volume-将-ConfigMap-作为文件或目录直接挂载"><a href="#使用-volume-将-ConfigMap-作为文件或目录直接挂载" class="headerlink" title="使用 volume 将 ConfigMap 作为文件或目录直接挂载"></a>使用 volume 将 ConfigMap 作为文件或目录直接挂载</h4><p>将创建的 ConfigMap 直接挂载至 Pod 的 / etc/config 目录下，其中每一个 key-value 键值对都会生成一个文件，key 为文件名，value 为内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">vol-test-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">gcr.io/google_containers/busybox</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;cat /etc/config/special.how&quot;</span>]</span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/etc/config</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">special-config</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure>

<p>当 Pod 结束后会输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">very</span><br></pre></td></tr></table></figure>

<h2 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h2><p>CronJob 即定时任务，就类似于 Linux 系统的 crontab，在指定的时间周期运行指定的任务。</p>
<p>CronJob Spec</p>
<ul>
<li><code>.spec.schedule</code>指定任务运行周期，格式同<a href="https://en.wikipedia.org/wiki/Cron">Cron</a></li>
<li><code>.spec.jobTemplate</code>指定需要运行的任务，格式同Job</li>
<li><code>.spec.startingDeadlineSeconds</code>指定任务开始的截止期限</li>
<li><code>.spec.concurrencyPolicy</code>指定任务的并发策略，支持Allow、Forbid和Replace三个选项</li>
</ul>
<h2 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h2><p>DaemonSet保证在每个Node上都运行一个容器副本，常用来部署一些集群的日志、监控或者其他系统管理应用。典型的应用包括：</p>
<ul>
<li>日志收集：logstash，fluentd</li>
<li>系统监控：Prometheus</li>
<li>系统程序：kube-proxy，glusterd</li>
</ul>
<h3 id="Fluentd示例"><a href="#Fluentd示例" class="headerlink" title="Fluentd示例"></a>Fluentd示例</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">fluentd-logging</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">fluentd-elasticsearch</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">gcr.io/google-containers/fluentd-elasticsearch:1.20</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">200Mi</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/log</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlibdockercontainers</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/lib/docker/containers</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlibdockercontainers</span></span><br><span class="line">        <span class="attr">hostPath:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/var/lib/docker/containers</span></span><br></pre></td></tr></table></figure>

<h3 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h3><p>通过<code>spec.updateStrategy.type</code>设置更新策略。目前支持两种策略</p>
<ul>
<li>OnDelete：默认策略，更新模板后，只有手动删除了旧的Pod后才会创建新的Pod</li>
<li>RollingUpdate: 更新DaemonSet模板后，自动删除旧的Pod并创建新的Pod</li>
</ul>
<p>在使用RollingUpdate策略时，还可以设置</p>
<ul>
<li>spec.updateStrategy.rollingUpdate.maxUnavailable，默认1</li>
<li>spec.minReadySeconds，默认0</li>
</ul>
<h3 id="指定Node节点"><a href="#指定Node节点" class="headerlink" title="指定Node节点"></a>指定Node节点</h3><p>DaemonSet 会忽略 Node 的 unschedulable 状态，有两种方式来指定 Pod 只运行在指定的 Node 节点上：</p>
<ul>
<li>nodeSelector：只调度到匹配指定 label 的 Node 上</li>
<li>nodeAffinity：功能更丰富的 Node 选择器，比如支持集合操作</li>
<li>podAffinity：调度到满足条件的 Pod 所在的 Node 上</li>
</ul>
<h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><p>有如下一些功能：</p>
<ul>
<li>使用Deployment来创建ReplicaSet。ReplicaSet在后台创建Pod。检查启动状态，看它是成功还是失败。</li>
<li>更新Deployment的PodTemplateSpec字段来声明Pod的新状态。这会创建一个新的ReplicaSet，Deployment会按照控制的速率将Pod从旧的ReplicaSet移动到新的ReplicaSet中。</li>
<li>如果当前状态不稳定，回滚到之前的Deployment revision。每次回滚都会更新Deployment的revision。</li>
<li>scale/autoscale</li>
<li>暂停Deployment来应用PodTemplateSpec的多个修复，然后恢复上线</li>
<li>清除旧的不必要的ReplicaSet</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>功能对应的cmd</p>
<ul>
<li>扩容：<code>kubectl scale deployment nginx-deployment --replicas 10</code></li>
<li>自动扩容：<code>kubectl autoscale deployment nginx-deployment --min=10 --max=15 --cpu-percent=80</code></li>
<li>更新镜像：<code>kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1</code></li>
<li>回滚：<code>kubectl rollout undo deployment/nginx-deployment --to-revision=1</code></li>
</ul>
<h2 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h2><p>在本篇文章中你将会看到一些在其他地方被交叉使用的术语，为了防止产生歧义，我们首先来澄清下</p>
<ul>
<li>节点（Node）：k8s集群中的服务器</li>
<li>集群（Cluster）：k8s管理的一组服务器集合</li>
<li>边界路由器：为局域网和Internet路由数据包的路由器，执行防火墙保护局域网络</li>
<li>集群网络：遵循k8s网络模型实现集群内的通信的具体实现，比如flannel和OVS</li>
<li>服务：k8s的服务是使用标签选择器标识的一组Pod Service。</li>
</ul>
<h3 id="什么是Ingress"><a href="#什么是Ingress" class="headerlink" title="什么是Ingress"></a>什么是Ingress</h3><p>通常情况下，service 和 pod 的 IP 仅可在集群内部访问。集群外部的请求需要通过负载均衡转发到 service 在 Node 上暴露的 NodePort 上，然后再由 kube-proxy 通过边缘路由器 (edge router) 将其转发给相关的 Pod 或者丢弃。</p>
<p>Ingress 可以给 service 提供集群外部访问的 URL、负载均衡、SSL 终止、HTTP 路由等。</p>
<h3 id="Ingress格式"><a href="#Ingress格式" class="headerlink" title="Ingress格式"></a>Ingress格式</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/testpath</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">test</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>每个 Ingress 都需要配置 rules，目前 Kubernetes <strong>仅支持</strong> http 规则。上面的示例表示请求 /testpath 时转发到服务 test 的 80 端口。</p>
<h3 id="Ingress类型"><a href="#Ingress类型" class="headerlink" title="Ingress类型"></a>Ingress类型</h3><h4 id="单服务Ingress"><a href="#单服务Ingress" class="headerlink" title="单服务Ingress"></a>单服务Ingress</h4><p>单服务 Ingress 即该 Ingress 仅指定一个没有任何规则的后端服务。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br><span class="line">    <span class="attr">serviceName:</span> <span class="string">testsvc</span></span><br><span class="line">    <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h4 id="多服务的Ingress"><a href="#多服务的Ingress" class="headerlink" title="多服务的Ingress"></a>多服务的Ingress</h4><p>路由到多服务的Ingress，即根据请求路径的不同转发到不同的后端服务上，比如</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">foo.bar.com -&gt; 178.91.123.132 -&gt; / foo    s1:80</span><br><span class="line">                                 / bar    s2:80</span><br></pre></td></tr></table></figure>

<p>可以通过下面的 Ingress 来定义：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">foo.bar.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/foo</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">s1</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/bar</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">s2</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h4 id="虚拟主机Ingress"><a href="#虚拟主机Ingress" class="headerlink" title="虚拟主机Ingress"></a>虚拟主机Ingress</h4><p>虚拟主机 Ingress 即根据名字的不同转发到不同的后端服务上，而他们共用同一个的 IP 地址，如下所示</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">foo.bar.com --|                 |-&gt; foo.bar.com s1:80</span><br><span class="line">              | 178.91.123.132  |</span><br><span class="line">bar.foo.com --|                 |-&gt; bar.foo.com s2:80</span><br></pre></td></tr></table></figure>

<p>下面是一个基于 Host header 路由请求的 Ingress：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">foo.bar.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">s1</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">bar.foo.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">s2</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h3 id="Ingress-Controller"><a href="#Ingress-Controller" class="headerlink" title="Ingress Controller"></a>Ingress Controller</h3><p>Ingress 正常工作需要集群中运行 Ingress Controller。Ingress Controller 与其他作为 kube-controller-manager 中的在集群创建时自动启动的 controller 成员不同，需要用户选择最适合自己集群的 Ingress Controller，或者自己实现一个。</p>
<h2 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h2><p>Job 负责批量处理短暂的一次性任务 (short lived one-off tasks)，即仅执行一次的任务，它保证批处理任务的一个或多个 Pod 成功结束。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>Kubernetes 支持以下几种 Job：</p>
<ul>
<li>非并行Job：通常创建一个Pod直至其成功结束</li>
<li>固定结束册数的Job：设置<code>.spec.completions</code>，创建多个Pod，知道<code>.spec.completions</code>个Pod成功结束</li>
<li>带有工作队列的并行Job：设置<code>.spec.parallelism</code>但不设置<code>.spec.completions</code>，当所有Pod结束并且至少一个成功时，Job就认为是成功</li>
</ul>
<p>根据<code>.spec.completions</code>和<code>.spec.parallelism</code>的设置，可以将Job划分为以下几种pattern</p>
<table>
<thead>
<tr>
<th align="center">Job类型</th>
<th align="center">使用示例</th>
<th align="center">行为</th>
<th align="center">completions</th>
<th align="center">parallelism</th>
</tr>
</thead>
<tbody><tr>
<td align="center">一次性Job</td>
<td align="center">数据库迁移</td>
<td align="center">创建一个Pod直至其成功结束</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">固定结束次数的Job</td>
<td align="center">处理工作队列的Pod</td>
<td align="center">依次创建一个Pod运行直至completions个成功结束</td>
<td align="center">2+</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">固定结束次数的并行Job</td>
<td align="center">多个Pod同时处理工作队列</td>
<td align="center">依次创建多个Pod运行直至completions个成功结束</td>
<td align="center">2+</td>
<td align="center">2+</td>
</tr>
<tr>
<td align="center">并行Job</td>
<td align="center">多个Job同时处理工作队列</td>
<td align="center">创建一个或多个Pod直至有一个成功结束</td>
<td align="center">1</td>
<td align="center">2+</td>
</tr>
</tbody></table>
<h3 id="Job-Spec格式"><a href="#Job-Spec格式" class="headerlink" title="Job Spec格式"></a>Job Spec格式</h3><ul>
<li>spec.template格式同Pod</li>
<li>RestartPolicy仅支持Never或OnFailure</li>
<li>单个Pod时，默认Pod成功运行后Job即结束</li>
<li><code>.spec.completions</code>标志Job结束需要成功运行的Pod个数，默认为1</li>
<li><code>.spec.parallelism</code>标志并行运行的Pod的个数，默认为1</li>
<li><code>.spec.activeDeadlineSeconds</code>标志失败Pod的重试最大时间，超过这个时间不会继续重试</li>
</ul>
<h2 id="LocalVolume"><a href="#LocalVolume" class="headerlink" title="LocalVolume"></a>LocalVolume</h2><p>本地数据卷（Local Volume）代表一个本地存储设备，比如磁盘、分区或者目录等。主要的应用场景包括分布式存储和数据库等需要高性能和高可靠性的环境里。</p>
<p>本地数据卷只能以静态创建的 PV 使用。本地数据卷可以直接以持久化的方式使用（它总是通过 NodeAffinity 调度在某个指定的节点上）。</p>
<h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>Namespace 是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目组或用户组。常见的 pod, service, replication controller 和 deployment 等都是属于某一个 namespace 的（默认是 default），而 node, persistent volume，namespace 等资源则不属于任何 namespace。</p>
<p>Namespace 常用来隔离不同的用户，比如 Kubernetes 自带的服务一般运行在 kube-system namespace 中。</p>
<h3 id="Namespace操作"><a href="#Namespace操作" class="headerlink" title="Namespace操作"></a>Namespace操作</h3><ul>
<li>查询：<code>k get ns</code></li>
<li>创建：<code>k create ns new-ns</code></li>
<li>删除：<code>k delete ns new-ns</code>  注意：<ol>
<li>删除一个namespace会自动删除所有属于该ns的资源</li>
<li>default和kube-system命名空间不可删除</li>
<li>PersistentVolume 是不属于任何 namespace 的，但 PersistentVolumeClaim 是属于某个特定 namespace 的。</li>
</ol>
</li>
</ul>
<p>给namespace增加资源配额，请见<code>ResourceQuota</code></p>
<h2 id="Pods"><a href="#Pods" class="headerlink" title="Pods"></a>Pods</h2><h3 id="Pod的特征"><a href="#Pod的特征" class="headerlink" title="Pod的特征"></a>Pod的特征</h3><ul>
<li>可以直接通过localhost通信</li>
<li>共享Volume</li>
<li>直接创建的Pod是与Node绑定的，异常退出后不会被重新调度。因此推荐使用Deployment、Daemonset等控制器来容错</li>
<li>优雅终止，Pod删除的时候先给其内的进程发送<code>SIGTERM</code>(Unlike SIGKILL, this signal can be blocked, handled, and ignored. It is the normal way to politely ask a program to terminate.)，等待一段时间后才会强制停止依然还在运行的进程。</li>
</ul>
<h3 id="Pod定义"><a href="#Pod定义" class="headerlink" title="Pod定义"></a>Pod定义</h3><p>一个nginx Pod的yaml配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在生产环境中建议不要直接部署Pod，原因上面已经阐述。</p>
</blockquote>
<h3 id="使用Volume持久化数据"><a href="#使用Volume持久化数据" class="headerlink" title="使用Volume持久化数据"></a>使用Volume持久化数据</h3><p>Volume可以为容器提供持久化存储，比如</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis-storage</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/data/redis</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis-storage</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RestartPolicy"><a href="#RestartPolicy" class="headerlink" title="RestartPolicy"></a>RestartPolicy</h3><ul>
<li>Always: 只要Pod退出就重启</li>
<li>OnFailure: Pod异常退出(exit code != 0)时重启</li>
<li>Never: 退出后不重启</li>
</ul>
<p>Tips: 重启只会在所在的Node上本地重启，不会重新调度到别的Node</p>
<h3 id="ImagePullPolicy"><a href="#ImagePullPolicy" class="headerlink" title="ImagePullPolicy"></a>ImagePullPolicy</h3><ul>
<li>Always: 不管镜像是否存在都会进行一次拉取</li>
<li>Never: 不贵镜像是否存在都不会进行拉取</li>
<li>IfNotPresent: 只有镜像不存在时，才会进行镜像拉取</li>
</ul>
<p>Tips:</p>
<ul>
<li>默认为<code>IfNotPresent</code>，但<code>:latest</code>标签的镜像默认为<code>Always</code></li>
<li>拉取竟像是docker会进行校验，如果镜像中的MD5码没有变，则不会拉取镜像数据</li>
<li>生产环境中应该尽量避免使用<code>:latest</code>标签，而开发环境中可以借助<code>:latest</code>标签自动拉取最新的镜像</li>
</ul>
<h3 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h3><p>k8s通过<code>cgroups</code>限制容器的CPU和内存等计算资源，包括<code>requests</code>(请求，调度器保证调度到资源充足的<code>Node</code>上，如果无法满足会调度失败)和<code>limits</code>(上限)等:</p>
<ul>
<li><code>spec.containers[].resources.limits.cpu</code>: CPU上限，可以短暂超过，容器也不会被停止</li>
<li><code>spec.containers[].resources.limits.memory</code>: 内存上限，不可以超过，如果超过，容器可能会被终止或调度到其他资源充足的机器上</li>
<li><code>spec.containers[].resources.limits.ephemeral-storage</code>: 临时存储（容器可写层、日志以及EmptyDir等）的上限，超过后Pod会被驱逐</li>
<li><code>spec.containers[].resources.requests.cpu</code>: CPU请求，也是调度CPU资源的依据，可以超过</li>
<li><code>spec.containers[].resources.requests.memory</code>: 内存请求，也是调度内存资源的一句，可以超过；但是如果超过，容器可能会在Node内存不足时清理</li>
<li><code>spec.containers[].resources.requests.ephemeral-storage</code>: 临时存储（容器可写层、日志以及EmptyDir等）的请求，调度容器存储的依据</li>
</ul>
<p>比如nginx容器请求30%的CPU和56MB的内存，但限制最多只能使用50%的CPU和128MB的内存：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">300m</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">56Mi</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">128Mi</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>Tips:</p>
<ul>
<li>CPU的单位是CPU个数，可以用<code>millicpu(m)</code>表示少于1个CPU的情况，例如<code>500m = 500millicpu = 0.5cpu</code></li>
<li>内存的单位包括<code>E, P, T, G, M, K, Ei, Pi, Ti, Gi, Mi, Ki</code>等</li>
</ul>
<h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><p>为了确保容器在部署后确实处在正常的运行状态，k8s提供了两种探针（Probe）来探测容器的状态：</p>
<ul>
<li>LivenessProbe: 探测应用是否处于健康状态，如果不健康则删除并重新创建容器</li>
<li>ReadinessProbe: 探测应用是否启动完成并且处于正常服务状态，如果不正常则不会接收来自k8s的流量</li>
</ul>
<p>k8s支持三种方式来执行探针：</p>
<ul>
<li>exec: 在容器中执行一个命令，如果命令退出码返回0则表示探测成功，否则失败</li>
<li>tcpSocket: 对指定的容器IP及端口执行一个TCP检查，如果端口是开放的则表示探测成功，否则表示失败</li>
<li>httpGet: 对指定的容器IP、端口及路径执行一个HTTP Get请求，如果返回的状态码在<code>[200,400)</code>之间则表示探测成功，否则表示失败</li>
</ul>
<h3 id="Init-Container"><a href="#Init-Container" class="headerlink" title="Init Container"></a>Init Container</h3><p>Init容器在所有容器运行之前执行，常用来初始化配置。如果为一个Pod指定了多个Init容器，那些容器会顺序一次运行一个。每个Init容器必须运行成功，下一个才能够运行。当所有Init同期运行完成时，k8s初始化Pod并像平常一样运行应用容器。</p>
<h3 id="容器声明周期钩子"><a href="#容器声明周期钩子" class="headerlink" title="容器声明周期钩子"></a>容器声明周期钩子</h3><p>容器声明周期钩子监听容器生命周期的特定时间，并在事件发生时执行已注册的回调函数。支持两种钩子：</p>
<ul>
<li>postStart: 容器创建后立即执行，注意由于是异步执行，它无法保证一定在<code>ENTRYPOINT</code>之前运行。</li>
<li>preStop: 容器终止前执行，常用于资源清理。如果失败，容器同样也会被杀死</li>
</ul>
<p>而钩子的回调函数支持两种方式：</p>
<ul>
<li>exec</li>
<li>httpGet</li>
</ul>
<h3 id="自定义hosts"><a href="#自定义hosts" class="headerlink" title="自定义hosts"></a>自定义hosts</h3><p>可以通过<code>pod.spec.hostAliases</code>来增加hosts内容，如</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hostaliases-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hostAliases:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="string">&quot;10.1.2.3&quot;</span></span><br><span class="line">    <span class="attr">hostnames:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;foo.remote&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;bar.remote&quot;</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cat-hosts</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">    <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;/etc/hosts&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Pod时区"><a href="#Pod时区" class="headerlink" title="Pod时区"></a>Pod时区</h3><p>很多容器都是配置了UTC时区，与国内集群的Node所在时区有可能不一致，可以通过HostPath存储插件给容器配置与Node一样的时区：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-tz</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pod-tz</span></span><br><span class="line">    <span class="attr">stdin:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/localtime</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">time</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">time</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/etc/localtime</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>Service是对一组提供相同功能的Pods的抽象，并为它们提供一个统一的入口。</p>
<p>四种类型</p>
<ul>
<li>ClusterIP: 默认类型，自动分配一个仅cluster内部可以访问的虚拟IP</li>
<li>NodePort: 在ClusterIP基础上为Service在每台机器上绑定一个端口，这样就可以通过<code>&lt;NodeIP&gt;:NodePort</code>来访问该服务</li>
<li>LoadBalancer: 在NodePort的基础上，借助cloud provider创建一个外部的负载均衡器，并将请求转发到<code>&lt;NodeIP&gt;:NodePort</code></li>
<li>ExternalName: 将服务通过DNS CNAME记录方式转发到指定的域名。</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>Service 的定义也是通过<code>yaml</code>或<code>json</code>，比如下面定义了一个名为<code>nginx</code>的服务，将服务的<code>80</code>端口转发到<code>default namespace</code>中带有标签<code>app=nginx,tier=ingress</code>的Pod的80端口</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">ingress</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br></pre></td></tr></table></figure>

<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>Service、Endpoints 和 Pod 支持三种类型的协议：</p>
<ul>
<li>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</li>
<li>UDP（User Datagram Protocol，用户数据报协议）是一种无连接的传输层协议，用于不可靠信息传送服务。</li>
<li>SCTP（Stream Control Transmission Protocol，流控制传输协议），用于通过IP网传输SCN（Signaling Communication Network，信令通信网）窄带信令消息。</li>
</ul>
<h3 id="Headless服务"><a href="#Headless服务" class="headerlink" title="Headless服务"></a>Headless服务</h3><p>Headless 服务即不需要 Cluster IP 的服务，即在创建服务的时候指定 spec.clusterIP=None。包括两种类型</p>
<ul>
<li>不指定 Selectors，但设置 externalName，即上面的（2），通过 CNAME 记录处理</li>
<li>指定 Selectors，通过 DNS A 记录设置后端 endpoint 列表，DNS格式为<code>&lt;serviceName&gt;.&lt;namespace&gt;.svc.cluster.local</code></li>
</ul>
<p>因为没有ClusterIP，kube-proxy 并不处理此类服务，因为没有load balancing或 proxy 代理设置，在访问服务的时候回返回后端的全部的Pods IP地址，主要用于开发者自己根据pods进行负载均衡器的开发(设置了selector)。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/service-flow.png"></p>
<blockquote>
<p>图片来源：<a href="https://feisky.gitbooks.io/kubernetes/content/concepts/service.html">https://feisky.gitbooks.io/kubernetes/content/concepts/service.html</a></p>
</blockquote>
<h2 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h2><p>ReplicaSet用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的Pod来替代。虽然ReplicaSet可以独立使用，但建议使用Deployment来自动管理ReplicaSet，这样就无需担心跟其他机制的不兼容问题（比如ReplicaSet不支持rolling-update但Deployment支持），并且还支持版本记录、回滚、暂停升级等高级特性。</p>
<h2 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h2><p>StatefulSet是为了解决有状态服务的问题，应用场景包括</p>
<ul>
<li>持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于<code>PVC</code>实现</li>
<li>稳定的网络标志，即Pod重新调度后其PodName和HostName不变，基于<code>Headless Service</code>来实现</li>
<li>有序部署，有序扩展，即Pod是有顺序的，在部署或者扩展的时候要一句定义的顺序依次进行，基于<code>init containers</code>来实现</li>
<li>有序收缩，有序删除</li>
</ul>
<p>从上面的场景可以发现，StatefulSet 由以下几个部分组成：</p>
<ul>
<li>用于定义网络标志（DNS domain）的 <code>Headless Service</code></li>
<li>用于创建 PersistentVolumes 的 <code>volumeClaimTemplates</code></li>
<li>定义具体应用的 <code>StatefulSet</code></li>
</ul>
<p>StatefulSet中每个Pod的DNS格式为<code>statefulSetName-&#123;0..N-1&#125;.serviceName.namespace.svc.cluster.local</code>，其中</p>
<ul>
<li><code>statefulSetName</code>为StatefulSet 的名字</li>
<li><code>0..N-1</code>为Pod所在的序号，从 0 开始到 N-1</li>
<li><code>serviceName</code>为Headless Service的名字</li>
<li><code>namespace</code>为服务所在的 namespace，Headless Service 和 StatefulSet 必须在相同的 namespace</li>
<li><code>.cluster.local</code>为 Cluster Domain</li>
</ul>
<h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p>以一个简单的nginx服务为例</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">&quot;nginx&quot;</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">k8s.gcr.io/nginx-slim:0.8</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">www</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">  <span class="attr">volumeClaimTemplates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">www</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">accessModes:</span> [<span class="string">&quot;ReadWriteOnce&quot;</span>]</span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure>

<p>进行操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">扩容</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl scale statefulset web --replicas=5  <span class="comment"># 可以看出Pod是按照次序创建的</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缩容</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl patch statefulset web -p <span class="string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;replicas&quot;:3&#125;&#125;&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">镜像更新（目前还不支持直接更新 image，需要 patch 来间接实现）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl patch statefulset web --<span class="built_in">type</span>=<span class="string">&#x27;json&#x27;</span> -p=<span class="string">&#x27;[&#123;&quot;op&quot;:&quot;replace&quot;,&quot;path&quot;:&quot;/spec/template/spec/containers/0/image&quot;,&quot;value&quot;:&quot;gcr.io/google_containers/nginx-slim:0.7&quot;&#125;]&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除 StatefulSet 和 Headless Service</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl delete statefulset web</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl delete service nginx</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">StatefulSet 删除后 PVC 还会保留着，数据不再使用的话也需要删除</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl delete pvc www-web-0 www-web-1</span></span><br></pre></td></tr></table></figure>

<h3 id="更新StatefulSet"><a href="#更新StatefulSet" class="headerlink" title="更新StatefulSet"></a>更新StatefulSet</h3><p>通过<code>.spec.updateStrategy</code>设置更新策略。目前支持两种策略</p>
<ul>
<li>OnDelete：当<code>.spec.template</code>更新时，并不立即删除旧的Pod，而是等待用户手动删除这些旧Pod后自动创建新Pod。</li>
<li>RollingUpdate：当<code>.spec.template</code>更新时，自动删除旧的Pod并创建新Pod替换。在更新时，这些Pod是按逆序的方式进行，依次删除、创建并等待Pod变成Ready状态才进行下一个Pod的更新。</li>
</ul>
<h3 id="Pod管理策略"><a href="#Pod管理策略" class="headerlink" title="Pod管理策略"></a>Pod管理策略</h3><p>通过<code>.spec.podManagementPolicy</code>设置Pod管理策略，支持两种方式</p>
<ul>
<li>OrderedReady：默认的策略，按照Pod的次序依次创建每个Pod并等待Ready之后才创建后面的Pod</li>
<li>Parallel：并行创建或删除Pod</li>
</ul>
<h3 id="Zookeeper示例"><a href="#Zookeeper示例" class="headerlink" title="Zookeeper示例"></a>Zookeeper示例</h3><p><a href="https://kubernetes.io/zh/docs/tutorials/stateful-application/zookeeper/">官网示例</a></p>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><h2 id="Resource-Quotas"><a href="#Resource-Quotas" class="headerlink" title="Resource Quotas"></a>Resource Quotas</h2><h2 id="PV-PVC-StorageClass"><a href="#PV-PVC-StorageClass" class="headerlink" title="PV/PVC/StorageClass"></a>PV/PVC/StorageClass</h2><h2 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h2><h2 id="Service-Account"><a href="#Service-Account" class="headerlink" title="Service Account"></a>Service Account</h2><h2 id="Security-Context"><a href="#Security-Context" class="headerlink" title="Security Context"></a>Security Context</h2><h2 id="Network-Policy"><a href="#Network-Policy" class="headerlink" title="Network Policy"></a>Network Policy</h2><h2 id="PodPreset"><a href="#PodPreset" class="headerlink" title="PodPreset"></a>PodPreset</h2>]]></content>
      <categories>
        <category>云原生</category>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>零基础学习kubernetes(二): 在ECS上部署集群</title>
    <url>/posts/1a2d/</url>
    <content><![CDATA[<p>kubernetes官网提供了不同场景下的集群搭建解决方案，包括本地/托管方案等等。如果你的集群是基于单节点搭建，可以选择<a href="https://kubernetes.io/docs/setup/minikube/">Minikube</a>/<a href="https://github.com/kubernetes-sigs/kubeadm-dind-cluster">Kubeadm-dind</a>等.</p>
<p>尽管这些现成的解决方案可以帮助你很快的在本地搭建一个k8s集群。但是为了更深入了解k8s集群的组成、原理，本篇文章笔者会从头开始创建自定义集群。阅读完本篇文章，你将会学到：</p>
<ul>
<li>集群master节点和node节点包含的主要组件</li>
<li>各个组件的用途</li>
<li>如何引导启动集群</li>
</ul>
<span id="more"></span>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="笔者的环境"><a href="#笔者的环境" class="headerlink" title="笔者的环境"></a>笔者的环境</h2><ul>
<li>1 ECS(1vCPU+2GRAM, OS:CentOS 7)</li>
</ul>
<h2 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h2><h3 id="配置yum源"><a href="#配置yum源" class="headerlink" title="配置yum源"></a>配置yum源</h3><p>默认的yum源在安装软件时往往会非常慢甚至超时，所以这里我们使用阿里云的yum源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>

<h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>因为CentOS7自带的docker版本可能过低，所以需要重新安装docker</p>
<p>卸载原有docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker  docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure>

<p>添加仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo wget -O /etc/yum.repos.d/docker-ce.repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>

<p>安装docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce -y</span><br></pre></td></tr></table></figure>

<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20180925232655.png"></p>
<p>运行<code>docker --version</code>查看docker版本</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20180925232755.png"></p>
<p>启动docker并设置开机启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker &amp;&amp; sudo systemctl enable docker</span><br></pre></td></tr></table></figure>

<p>验证安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p>有如下输出表示安装docker成功</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20180925233635.png"></p>
<h3 id="关闭swap"><a href="#关闭swap" class="headerlink" title="关闭swap"></a>关闭swap</h3><p>kubelet要求必须关闭内存交换，执行<code>swapoff -a</code>可以临时关闭，重启失效；编辑<code>/etc/fstab</code>，注释掉<code>swap</code>哪一行，重启可以永久关闭。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/dev/mapper/centos-root /                       xfs     defaults        0 0</span><br><span class="line">UUID=20ca01ff-c5eb-47bc-99a0-6527b8cb246e /boot                   xfs     defaults        0 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/dev/mapper/centos-swap swap</span></span><br></pre></td></tr></table></figure>

<p><code>htop</code>验证是否关闭成功</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20180926000333.png"></p>
<h2 id="k8s相关环境"><a href="#k8s相关环境" class="headerlink" title="k8s相关环境"></a>k8s相关环境</h2><p>根据<a href="https://kubernetes.io/docs/setup/independent/install-kubeadm/">官方文档</a>，准备k8s集群部署相关的软件、环境设置等。</p>
<h3 id="关闭SELinux"><a href="#关闭SELinux" class="headerlink" title="关闭SELinux"></a>关闭SELinux</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo setenforce 0</span><br></pre></td></tr></table></figure>

<p>通过运行<code>setenforce 0</code>来禁用SELinux来允许容器访问主机文件系统，这是pod网络所需要的。</p>
<h3 id="配置k8s的yum源"><a href="#配置k8s的yum源" class="headerlink" title="配置k8s的yum源"></a>配置k8s的yum源</h3><p>由于官方yum源在天朝无法使用，所以这里我们还是使用阿里云的k8s源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/yum.repos.d/kubernetes.repo</span><br><span class="line"></span><br><span class="line">加入如下内容</span><br><span class="line"></span><br><span class="line">[kubernetes]</span><br><span class="line"></span><br><span class="line">name=Kubernetes</span><br><span class="line"></span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line"></span><br><span class="line">enabled=1</span><br><span class="line"></span><br><span class="line">gpgcheck=0</span><br><span class="line"></span><br><span class="line">repo_gpgcheck=0</span><br><span class="line"></span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line"></span><br><span class="line">        http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br></pre></td></tr></table></figure>

<h3 id="安装k8s组件"><a href="#安装k8s组件" class="headerlink" title="安装k8s组件"></a>安装k8s组件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure>

<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20180926002139.png"></p>
<p>开机启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable kubelet &amp;&amp; sudo systemctl start kubelet</span><br></pre></td></tr></table></figure>

<h3 id="配置kubelet使用的cgroup-drive"><a href="#配置kubelet使用的cgroup-drive" class="headerlink" title="配置kubelet使用的cgroup drive"></a>配置kubelet使用的cgroup drive</h3><p>查看docker的cgroup driver</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker info | grep &#x27;Cgroup Driver&#x27;</span><br></pre></td></tr></table></figure>

<p>如果<strong>不是</strong><code>cgroupfs</code>，而是<code>systemd</code>，需要更改<code>kubelet</code>配置，在<code>/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code>文件中加入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Environment=&quot;KUBELET_CGROUP_ARGS=--cgroup-driver=systemd&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后执行</span></span><br><span class="line">sudo systemctl daemon-reload &amp;&amp; sudo systemctl restart kubelet</span><br></pre></td></tr></table></figure>

<h3 id="修改kubeadm使用的默认镜像仓储"><a href="#修改kubeadm使用的默认镜像仓储" class="headerlink" title="修改kubeadm使用的默认镜像仓储"></a>修改kubeadm使用的默认镜像仓储</h3><p>Change: 2018-12-14</p>
<p>kubeadm支持<code>--image-repository</code>参数，可以指定镜像仓库，所以下面的方法可以作废。我们使用dockerhub上的一些仓库即可完成pull images。e.g.  <a href="https://hub.docker.com/u/bluenet13">bluenet13</a> (support v1.13.1)</p>
<p>由于执行<code>kubeadm init</code>会默认访问谷歌服务器，所以会出现失败的情况，这里我们需要将kubeadm使用的默认docker镜像从另外的仓库中全部下载下来，然后批量打标签成需要的镜像名。</p>
<blockquote>
<p>参考：<a href="https://anjia0532.github.io/2017/11/15/gcr-io-image-mirror/">Google Container Registry(gcr.io) 中国可用镜像(长期维护)</a></p>
</blockquote>
<p>在执行<code>kubeadm init</code>时，会报错</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20180927002610.png"></p>
<p>我们将需要下载的镜像记录到<code>img.txt</code>中</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">k8s.gcr.io/kube-apiserver-amd64:v1.11.0</span><br><span class="line">k8s.gcr.io/kube-controller-manager-amd64:v1.11.0</span><br><span class="line">k8s.gcr.io/kube-scheduler-amd64:v1.11.0</span><br><span class="line">k8s.gcr.io/kube-proxy-amd64:v1.11.0</span><br><span class="line">k8s.gcr.io/etcd-amd64:3.2.18</span><br><span class="line">k8s.gcr.io/coredns:1.1.3</span><br></pre></td></tr></table></figure>

<p>创建批量下载并打标签镜像的脚本<code>batch_get_images.sh</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># replace gcr.io/google-containers/federation-controller-manager-arm64:v1.3.1-beta.1 to real image</span></span><br><span class="line"><span class="comment"># this will convert gcr.io/google-containers/federation-controller-manager-arm64:v1.3.1-beta.1</span></span><br><span class="line"><span class="comment"># to anjia0532/google-containers.federation-controller-manager-arm64:v1.3.1-beta.1 and pull it</span></span><br><span class="line"><span class="comment"># k8s.gcr.io/&#123;image&#125;/&#123;tag&#125; &lt;==&gt; gcr.io/google-containers/&#123;image&#125;/&#123;tag&#125; &lt;==&gt; anjia0532/google-containers.&#123;image&#125;/&#123;tag&#125;</span></span><br><span class="line"></span><br><span class="line">images=$(<span class="built_in">cat</span> img.txt)</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line"><span class="comment">#images=$(cat &lt;&lt;EOF</span></span><br><span class="line"><span class="comment"># gcr.io/google-containers/federation-controller-manager-arm64:v1.3.1-beta.1</span></span><br><span class="line"><span class="comment"># gcr.io/google-containers/federation-controller-manager-arm64:v1.3.1-beta.1</span></span><br><span class="line"><span class="comment"># gcr.io/google-containers/federation-controller-manager-arm64:v1.3.1-beta.1</span></span><br><span class="line"><span class="comment">#EOF</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span> $(<span class="built_in">echo</span> <span class="variable">$&#123;images&#125;</span>|</span><br><span class="line">        sed <span class="string">&#x27;s/k8s\.gcr\.io/anjia0532\/google-containers/g;s/gcr\.io/anjia0532/g;s/\//\./g;s/ /\n/g;s/anjia0532\./anjia0532\//g&#x27;</span> |</span><br><span class="line">        <span class="built_in">uniq</span> |</span><br><span class="line">        awk <span class="string">&#x27;&#123;print &quot;docker pull &quot;$1&quot;;&quot;&#125;&#x27;</span></span><br><span class="line">       )</span><br><span class="line"></span><br><span class="line"><span class="comment"># this code will retag all of anjia0532&#x27;s image from local  e.g. anjia0532/google-containers.federation-controller-manager-arm64:v1.3.1-beta.1</span></span><br><span class="line"><span class="comment"># to gcr.io/google-containers/federation-controller-manager-arm64:v1.3.1-beta.1</span></span><br><span class="line"><span class="comment"># k8s.gcr.io/&#123;image&#125;/&#123;tag&#125; &lt;==&gt; gcr.io/google-containers/&#123;image&#125;/&#123;tag&#125; &lt;==&gt; anjia0532/google-containers.&#123;image&#125;/&#123;tag&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> img <span class="keyword">in</span> $(docker images --format <span class="string">&quot;&#123;&#123;.Repository&#125;&#125;:&#123;&#123;.Tag&#125;&#125;&quot;</span>| grep <span class="string">&quot;anjia0532&quot;</span>); <span class="keyword">do</span></span><br><span class="line">    n=$(<span class="built_in">echo</span> <span class="variable">$&#123;img&#125;</span>| awk -F<span class="string">&#x27;[/.:]&#x27;</span> <span class="string">&#x27;&#123;printf &quot;gcr.io/%s&quot;,$2&#125;&#x27;</span>)</span><br><span class="line">    image=$(<span class="built_in">echo</span> <span class="variable">$&#123;img&#125;</span>| awk -F<span class="string">&#x27;[/.:]&#x27;</span> <span class="string">&#x27;&#123;printf &quot;/%s&quot;,$3&#125;&#x27;</span>)</span><br><span class="line">    tag=$(<span class="built_in">echo</span> <span class="variable">$&#123;img&#125;</span>| awk -F<span class="string">&#x27;[:]&#x27;</span> <span class="string">&#x27;&#123;printf &quot;:%s&quot;,$2&#125;&#x27;</span>)</span><br><span class="line">    docker tag <span class="variable">$img</span> <span class="string">&quot;<span class="variable">$&#123;n&#125;</span><span class="variable">$&#123;image&#125;</span><span class="variable">$&#123;tag&#125;</span>&quot;</span></span><br><span class="line">    [[ <span class="variable">$&#123;n&#125;</span> == <span class="string">&quot;gcr.io/google-containers&quot;</span>  ]] &amp;&amp; docker tag <span class="variable">$img</span> <span class="string">&quot;k8s.gcr.io<span class="variable">$&#123;image&#125;</span><span class="variable">$&#123;tag&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>执行如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod u+x batch_get_images.sh</span><br><span class="line">./batch_get_images.sh</span><br></pre></td></tr></table></figure>

<p>会下载<code>img.txt</code>中的镜像，成功后可以看到，<code>kubeadm init</code>需要的镜像已经全部下载并打标签成<code>gcr.io/*</code></p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20180927022744.png"></p>
<h1 id="master-node-组件"><a href="#master-node-组件" class="headerlink" title="master/node 组件"></a>master/node 组件</h1><h2 id="kube-master「控制节点」"><a href="#kube-master「控制节点」" class="headerlink" title="kube-master「控制节点」"></a>kube-master「控制节点」</h2><p>kube master主要包含以下组件</p>
<ul>
<li>api server</li>
<li>scheduler</li>
<li>controller manager</li>
</ul>
<p>各个组件之间的工作配合方式如下</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/kube-master.png"></p>
<ol>
<li>Kubecfg将特定的请求，比如创建Pod，发送给Kubernetes Client。</li>
<li>Kubernetes Client将请求发送给API server。</li>
<li>API Server根据请求的类型，比如创建Pod时storage类型是pods，然后依此选择何种REST Storage API对请求作出处理。</li>
<li>REST Storage API对的请求作相应的处理。</li>
<li>将处理的结果存入高可用键值存储系统Etcd中。</li>
<li>在API Server响应Kubecfg的请求后，Scheduler会根据Kubernetes Client获取集群中运行Pod及Minion/Node信息。</li>
<li>依据从Kubernetes Client获取的信息，Scheduler将未分发的Pod分发到可用的Minion/Node节点上。</li>
</ol>
<h3 id="api-server"><a href="#api-server" class="headerlink" title="api server"></a>api server</h3><p><code>api server</code>是资源操作的唯一入口，所有其他的组件如果相对集群资源进行操作都必须通过<code>api server</code>。</p>
<p>功能：</p>
<ol>
<li>提供了集群管理的REST API接口(包括认证授权、数据校验以及集群状态变更)</li>
<li>提供其他模块之间的数据交互和通信的枢纽(其他模块通过API Server查询或修改数据，只有API Server才直接操作etcd)</li>
<li>资源配额控制的入口</li>
</ol>
<p>工作原理图</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/kube-apiserver.png"></p>
<h3 id="controller-manager"><a href="#controller-manager" class="headerlink" title="controller manager"></a>controller manager</h3><p>Controller Manager作为集群内部的管理控制中心，负责集群内的Node、Pod副本、服务端点（Endpoint）、命名空间（Namespace）、服务账号（ServiceAccount）、资源定额（ResourceQuota）的管理，当某个Node意外宕机时，Controller Manager会及时发现并执行自动化修复流程，确保集群始终处于预期的工作状态。</p>
<p><a href="https://www.huweihuang.com/article/kubernetes/core-principle/kubernetes-core-principle-controller-manager/">Controller Manager详解</a></p>
<h3 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h3><p>Scheduler负责Pod调度。在整个系统中起”承上启下”作用，承上：负责接收Controller Manager创建的新的Pod，为其选择一个合适的Node；启下：Node上的kubelet接管Pod的生命周期。</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/kube-scheduler.png"></p>
<h2 id="kube-node「服务节点」"><a href="#kube-node「服务节点」" class="headerlink" title="kube-node「服务节点」"></a>kube-node「服务节点」</h2><p>结构图</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/kube-node.png"></p>
<h3 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h3><p>在kubernetes集群中，每个Node节点都会启动kubelet进程，用来处理Master节点下发到本节点的任务，管理Pod和其中的容器。kubelet会在API Server上注册节点信息，定期向Master汇报节点资源使用情况，并通过cAdvisor监控容器和节点资源。可以把kubelet理解成【Server-Agent】架构中的agent，是Node上的pod管家。</p>
<p>功能</p>
<ol>
<li>负责Node节点上pod的创建、修改、监控、删除等全生命周期的管理</li>
<li>定时上报本Node的状态信息给API Server</li>
<li>kubelet是Master API Server和Minion/Node之间的桥梁，接收Master API Server分配给它的commands和work，通过kube-apiserver间接与Etcd集群交互，读取配置信息</li>
</ol>
<h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p>Proxy是为了解决外部网络能够访问集群中容器提供的应用服务而设计的，Proxy 运行在每个Node上。</p>
<p>Proxy提供TCP/UDP两种Sockets连接方式。每创建一个Service，Proxy就会从Etcd获取Services和Endpoints的配置信息（也可以从 File 获取），然后根据其配置信息在Node上启动一个Proxy的进程并监听相应的服务端口。当外部请求发生时，Proxy会根据<code>Load Balancer</code>将请求分发到后端正确的容器处理。</p>
<h1 id="启动引导集群"><a href="#启动引导集群" class="headerlink" title="启动引导集群"></a>启动引导集群</h1><p>在第一节，我们准备了运行<code>kubeadm init</code>之前的一些环境、软件，第二节中，介绍了k8s集群的基本组件，帮助我们理解了集群中的基本组件。</p>
<p>下面我们将使用<code>kubeadm</code>来创建并引导一个集群。</p>
<h2 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h2><p>执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo kubeadm init  --kubernetes-version=v1.11.0 --apiserver-advertise-address=your_master_node_ip --pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure>

<p>各个参数的含义:</p>
<ul>
<li>kubernetes-version: 指定k8s版本，必须与之前导入的镜像版本一致，不然又会去谷歌下载需要的镜像</li>
<li>apiserver-advertise-address: 指定api server监听的ip地址，这里笔者填的是ECS的外网地址</li>
<li>pod-network-cidr: 根据<code>https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/</code>，官方提供了很多可以选择的节点网络类型，这里笔者填写<code>10.244.0.0/16</code>表示使用<code>flannel</code>网络，同时需要执行<code>sudo sysctl net.bridge.bridge-nf-call-iptables=1</code>。</li>
</ul>
<p>执行成功结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[init] using Kubernetes version: v1.11.0</span><br><span class="line">[preflight] running pre-flight checks</span><br><span class="line">I0927 23:50:58.769986   27134 kernel_validator.go:81] Validating kernel version</span><br><span class="line">I0927 23:50:58.770090   27134 kernel_validator.go:96] Validating kernel config</span><br><span class="line">        [WARNING SystemVerification]: docker version is greater than the most recently validated version. Docker version: 18.06.1-ce. Max validated version: 17.03</span><br><span class="line">[preflight/images] Pulling images required for setting up a Kubernetes cluster</span><br><span class="line">[preflight/images] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight/images] You can also perform this action in beforehand using &#x27;kubeadm config images pull&#x27;</span><br><span class="line">[kubelet] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[preflight] Activating the kubelet service</span><br><span class="line">[certificates] Generated ca certificate and key.</span><br><span class="line">[certificates] Generated apiserver certificate and key.</span><br><span class="line">[certificates] apiserver serving cert is signed for DNS names [leosocy-ecs1 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 101.xx.xx.124]</span><br><span class="line">[certificates] Generated apiserver-kubelet-client certificate and key.</span><br><span class="line">[certificates] Generated sa key and public key.</span><br><span class="line">[certificates] Generated front-proxy-ca certificate and key.</span><br><span class="line">[certificates] Generated front-proxy-client certificate and key.</span><br><span class="line">[certificates] Generated etcd/ca certificate and key.</span><br><span class="line">[certificates] Generated etcd/server certificate and key.</span><br><span class="line">[certificates] etcd/server serving cert is signed for DNS names [leosocy-ecs1 localhost] and IPs [127.0.0.1 ::1]</span><br><span class="line">[certificates] Generated etcd/peer certificate and key.</span><br><span class="line">[certificates] etcd/peer serving cert is signed for DNS names [leosocy-ecs1 localhost] and IPs [101.xx.xx.124 127.0.0.1 ::1]</span><br><span class="line">[certificates] Generated etcd/healthcheck-client certificate and key.</span><br><span class="line">[certificates] Generated apiserver-etcd-client certificate and key.</span><br><span class="line">[certificates] valid certificates and keys now exist in &quot;/etc/kubernetes/pki&quot;</span><br><span class="line">[kubeconfig] Wrote KubeConfig file to disk: &quot;/etc/kubernetes/admin.conf&quot;</span><br><span class="line">[kubeconfig] Wrote KubeConfig file to disk: &quot;/etc/kubernetes/kubelet.conf&quot;</span><br><span class="line">[kubeconfig] Wrote KubeConfig file to disk: &quot;/etc/kubernetes/controller-manager.conf&quot;</span><br><span class="line">[kubeconfig] Wrote KubeConfig file to disk: &quot;/etc/kubernetes/scheduler.conf&quot;</span><br><span class="line">[controlplane] wrote Static Pod manifest for component kube-apiserver to &quot;/etc/kubernetes/manifests/kube-apiserver.yaml&quot;</span><br><span class="line">[controlplane] wrote Static Pod manifest for component kube-controller-manager to &quot;/etc/kubernetes/manifests/kube-controller-manager.yaml&quot;</span><br><span class="line">[controlplane] wrote Static Pod manifest for component kube-scheduler to &quot;/etc/kubernetes/manifests/kube-scheduler.yaml&quot;</span><br><span class="line">[etcd] Wrote Static Pod manifest for a local etcd instance to &quot;/etc/kubernetes/manifests/etcd.yaml&quot;</span><br><span class="line">[init] waiting for the kubelet to boot up the control plane as Static Pods from directory &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[init] this might take a minute or longer if the control plane images have to be pulled</span><br><span class="line">[apiclient] All control plane components are healthy after 45.005438 seconds</span><br><span class="line">[uploadconfig] storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace</span><br><span class="line">[kubelet] Creating a ConfigMap &quot;kubelet-config-1.11&quot; in namespace kube-system with the configuration for the kubelets in the cluster</span><br><span class="line">[markmaster] Marking the node leosocy-ecs1 as master by adding the label &quot;node-role.kubernetes.io/master=&#x27;&#x27;&quot;</span><br><span class="line">[markmaster] Marking the node leosocy-ecs1 as master by adding the taints [node-role.kubernetes.io/master:NoSchedule]</span><br><span class="line">[patchnode] Uploading the CRI Socket information &quot;/var/run/dockershim.sock&quot; to the Node API object &quot;leosocy-ecs1&quot; as an annotation</span><br><span class="line">[bootstraptoken] using token: 3yl852.cgnsfybbkj01qtbp</span><br><span class="line">[bootstraptoken] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials</span><br><span class="line">[bootstraptoken] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token</span><br><span class="line">[bootstraptoken] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster</span><br><span class="line">[bootstraptoken] creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes master has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of machines by running the following on each node</span><br><span class="line">as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join 101.xx.xx.124:6443 --token 3yl852.cgnsfybbkj01qtbp --discovery-token-ca-cert-hash sha256:7e4636f999545ccd6468d913565341b22e228922acc999dba825726f710e45a5</span><br></pre></td></tr></table></figure>

<p>这里有一个大坑，由于笔者用的是阿里云的ECS，又没有配置入方向的安全组，导致<code>6443端口</code>无法访问，一致卡在<code>[init] this might take a minute or longer if the control plane images have to be pulled</code>这个阶段。解决办法就是去阿里云控制台，配置ECS的6443端口安全组。</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20180927020134.png"></p>
<h2 id="创建kubectl-config"><a href="#创建kubectl-config" class="headerlink" title="创建kubectl config"></a>创建kubectl config</h2><p>如果本机之前没有其他k8s集群的配置，既<code>$HOME/.kube/config</code>不存在，则执行如下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure>

<p>如果本机还有其他集群的配置，则需要合并/etc/kubernetes/admin.conf到现有配置上，执行如下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export KUBECONFIG=$HOME/.kube/config:/etc/kubernetes/admin.conf</span><br><span class="line">sudo chown $(id -u):$(id -g) /etc/kubernetes/admin.conf</span><br><span class="line">kubectl config view --flatten &gt; $HOME/.kube/config_new</span><br><span class="line">mv $HOME/.kube/config_new $HOME/.kube/config    # 覆盖旧的配置</span><br><span class="line">export KUBECONFIG=~/.kube/config        # 恢复配置</span><br></pre></td></tr></table></figure>

<h2 id="配置pod网络"><a href="#配置pod网络" class="headerlink" title="配置pod网络"></a>配置pod网络</h2><p>根据<code>kubeadm init</code>配置选择的网络类型，创建对应的网络pod，笔者选用的是<code>flannel</code>，根据<a href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/">官网</a>配置，执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/c5d10c8/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>

<p>指定<code>k get po -n kube-system</code>，查看运行的pod如下</p>
<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20180928003155.png"></p>
<p>可以看到，master需要的组件都已经启动成功了</p>
<h2 id="集群设置"><a href="#集群设置" class="headerlink" title="集群设置"></a>集群设置</h2><h3 id="设置master为工作节点"><a href="#设置master为工作节点" class="headerlink" title="设置master为工作节点"></a>设置master为工作节点</h3><p>scheduler默认不会将pod调度到master上，可以执行如下操作将master设置成工作节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure>

<h2 id="发布一个应用试一试"><a href="#发布一个应用试一试" class="headerlink" title="发布一个应用试一试"></a>发布一个应用试一试</h2><p>基于yaml文件创建一个发布</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://k8s.io/examples/application/deployment.yaml</span><br></pre></td></tr></table></figure>

<p><img src= "https://cdn.leosocy.top/img/dinosaurloading.gif" data-lazy-src="https://cdn.leosocy.top/img/20180928005347.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇介绍了如何基于单节点搭建一个k8s集群，并介绍了master/node的基本组件。</p>
<p>下一篇，我们将会一起学习一些k8s中的名词解释。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.jianshu.com/p/78a5afd0c597">https://www.jianshu.com/p/78a5afd0c597</a><br><a href="https://www.huweihuang.com/article/kubernetes/kubernetes-architecture/">https://www.huweihuang.com/article/kubernetes/kubernetes-architecture/</a><br><a href="https://juejin.im/post/5b63f4506fb9a04f8856f340">https://juejin.im/post/5b63f4506fb9a04f8856f340</a></p>
]]></content>
      <categories>
        <category>云原生</category>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>零基础学习kubernetes(五): ServiceMesh--微服务的最后一块拼图</title>
    <url>/posts/96ab/</url>
    <content><![CDATA[<p><a href="./%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0kubernetes-%E5%9B%9B-%E5%88%A9%E7%94%A8%E9%97%B2%E7%BD%AE%E4%B8%BB%E6%9C%BA%E6%90%AD%E5%BB%BA%E5%B9%B6%E6%9A%B4%E9%9C%B2%E6%9C%AC%E5%9C%B0k8s%E9%9B%86%E7%BE%A4.md">上一节</a>，笔者介绍了如何通过frp暴露内网的k8s集群，并在公网操作集群。通过frp我们可以将来自公网的请求路由到内网的指定端口，这种方法可以结合service的NodePort部署方式来简单的暴露集群中的服务，甚至可以基于frp的location路由功能，将请求根据不同路径路由到不同的svc上。想想目前的功能可以cover住基本的需求，但是如果仅仅这样我们就无法利用k8s的强大特性了(服务发现/负载均衡/限流等等)。</p>
<p>本篇文章会将Istio引入集群，并通过示例展示如何将https请求路由到内部的服务中去。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>云原生</category>
        <category>Kubernetes</category>
        <category>ServiceMesh</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>ServiceMesh</tag>
      </tags>
  </entry>
  <entry>
    <title>零基础学习kubernetes(四): 利用闲置主机搭建并暴露本地k8s集群</title>
    <url>/posts/d262/</url>
    <content><![CDATA[<p>前三章的学习，笔者经历了从使用ECS的k8s集群到本地的Minikube，说白了，还是穷，买不起高配置的ECS，而当资源(cpu/memory)不足时，要想充分发挥k8s的强大功能可以说是难上加难。</p>
<p>恰巧笔者有一台尘封已久的笔记本，很早之前折腾过一阵<code>archlinux</code>系统，如果我们能用它在内网搭建一个k8s集群，然后通过某种方式暴露在公网上供使用，是不是就很nice了呢？</p>
<p>如果你也有类似的烦恼，想利用闲置的主机搭建一个经济实惠的k8s集群，那么希望本篇文章能带给你一些帮助。下面我们就一步步完成这个伟(diao)大(si)的理想吧！</p>
<span id="more"></span>

<h2 id="内网穿透，”免费“的ECS"><a href="#内网穿透，”免费“的ECS" class="headerlink" title="内网穿透，”免费“的ECS"></a>内网穿透，”免费“的ECS</h2><p>对于没有公网IP的内网用户来说，远程管理或在外网访问内网机器上的服务是一个问题。通常解决方案就是用内网穿透工具将内网的服务穿透到公网中，便于远程管理和在外部访问。</p>
<p><a href="https://github.com/fatedier/frp"><code>FRP</code></a> (Fast Reverse Proxy)，一个使用Go语言开发的高性能反向代理工具，可以通过简单的配置实现内网穿透。<code>FRP</code>支持TCP、UDP、HTTP、HTTPS等协议类型，并且支持Web服务根据域名进行路由转发。</p>
<h3 id="frps"><a href="#frps" class="headerlink" title="frps"></a>frps</h3><p>frp的服务端，即我们的ECS服务器，可以将公网的请求(TCP/HTTP…)转发到内网上。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>首先去frp的release页面查看最新的版本以及ECS处理器架构对应的安装包。</p>
<p>如何知道处理器架构，执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -a</span><br><span class="line">Linux izuf6bp8e6ra9rqb1vneypz 3.10.0-862.11.6.el7.x86_64 #1 SMP Tue Aug 14 21:49:04 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>

<p>如果输出中含有*.x86_64则需要下载带<code>linux_amd64</code>的压缩包。</p>
<p>这里笔者选择的是<code>x86_64</code>架构，本文撰写时frp最新版本是<code>0.22.0</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.22.0/frp_0.22.0_linux_amd64.tar.gz</span><br><span class="line">tar -zxvf frp_0.22.0_linux_amd64.tar.gz</span><br><span class="line">cd frp_0.22.0_linux_amd64/</span><br></pre></td></tr></table></figure>

<p>尝试运行frps</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frps --help</span><br></pre></td></tr></table></figure>

<p>正常情况下会输出一堆帮助信息，说明你下载了正确架构的版本，反之如果输出<code>Exec format error</code>，就说明版本下载错了。</p>
<p>拷贝可执行文件以及配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp frps /usr/bin</span><br><span class="line">mkdir -p ~/.frp</span><br><span class="line">cp frps_full.ini ~/.frp</span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>下面的配置仅为作者使用到的一些基本配置及说明，如需研究完整配置说明请看<code>~/.frp/frps_full.ini</code>，以及参考<a href="https://github.com/fatedier/frp/blob/master/README_zh.md">frp官方文档</a></p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面这句开头必须要有，表示配置的开始</span></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># frp 服务端端口（必须）</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># frp 服务端密码（必须）</span></span><br><span class="line"><span class="attr">token</span> = xxxxxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仪表盘端口，只有设置了才能使用仪表盘（即后台）</span></span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">7500</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 仪表盘访问的用户名密码，如果不设置，则默认都是 admin</span></span><br><span class="line"><span class="attr">dashboard_user</span> = admin</span><br><span class="line"><span class="attr">dashboard_pwd</span> = admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你想要用 frp 穿透访问内网中的网站（例如路由器设置页面）</span></span><br><span class="line"><span class="comment"># 则必须要设置以下两个监听端口，不设置则不会开启这项功能</span></span><br><span class="line"><span class="attr">vhost_http_port</span> = <span class="number">80</span></span><br><span class="line"><span class="attr">vhost_https_port</span> = <span class="number">443</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此设置需要配合客户端设置，仅在穿透到内网中的 http 或 https 时有用（可选）</span></span><br><span class="line"><span class="comment"># 假设此项设置为 example.com，客户端配置 http 时将 subdomain 设置为 test，</span></span><br><span class="line"><span class="comment"># 则你将 test.example.com 解析到服务端后，可以使用此域名来访问客户端对应的 http</span></span><br><span class="line"><span class="attr">subdomain_host</span> = example.com</span><br></pre></td></tr></table></figure>

<p>将上述配置写入<code>~/.frp/frps.ini</code>中，然后执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">frps -c ~/.frp/frps.ini</span><br></pre></td></tr></table></figure>

<p>如果没有出现错误提示就说明配置没有问题，可以正常使用</p>
<p>然后<code>Ctrl + C</code>终止进程</p>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>直接使用前面的命令行来运行是不行的，因为在关掉ssh窗口后程序frps就会停止运行，因此要使用nohup [command] &amp;这种操作来使其在后台运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup frps -c ~/.frp/frps.ini &amp;</span><br></pre></td></tr></table></figure>

<p>如果想停止，可以执行<code>pkill frps</code></p>
<p><em>加入开机自启动</em></p>
<p>编辑<code>/etc/rc.local</code>，将启动那句命令加到<code>exit 0</code>语句之前（如果有）</p>
<h3 id="frpc"><a href="#frpc" class="headerlink" title="frpc"></a>frpc</h3><p>frp的客户端，即为内网机器，接收frpc转发的请求，并作出响应。</p>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>同frps的安装，不过要注意此处需要下载内网机器处理器架构对应的压缩包。</p>
<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>下面的配置仅为作者使用到的一些基本配置及说明，如需研究完整配置说明请看<code>~/.frp/frpc_full.ini</code>，以及参考<a href="https://github.com/fatedier/frp/blob/master/README_zh.md">frp官方文档</a></p>
<p><em>基本配置</em></p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># frp 服务端地址，可以填ip或者域名</span></span><br><span class="line"><span class="attr">server_addr</span> = <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="comment"># frp 服务端端口，即填写服务端配置中的 bind_port</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="comment"># 填写 frp 服务端密码</span></span><br><span class="line"><span class="attr">token</span> = <span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p><em>TCP/UDP</em></p>
<p>以转发ssh为例</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义一个配置名称，格式为“[名称]”，放在开头</span></span><br><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="comment"># 连接类型，填 tcp 或 udp</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地ip，填你需要转发到的目的ip</span></span><br><span class="line"><span class="comment"># 如果是转发到frp客户端所在本机（比如路由器）则填 127.0.0.1</span></span><br><span class="line"><span class="comment"># 否则填对应机器的内网ip</span></span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># 需要转发到的端口，比如 ssh 端口是 22</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br></pre></td></tr></table></figure>

<p><em>HTTP/HTTPS</em></p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义一个配置名称，格式为“[名称]”，放在开头</span></span><br><span class="line"><span class="section">[router-web]</span></span><br><span class="line"><span class="comment"># 连接类型，填 http 或 https</span></span><br><span class="line"><span class="attr">type</span> = http</span><br><span class="line"></span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># http 可以考虑加密和压缩一下</span></span><br><span class="line"><span class="attr">use_encryption</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">use_compression</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义访问网站的用户名和密码，如果不定义的话谁都可以访问，会不安全</span></span><br><span class="line"><span class="comment"># 有些路由器如果从内部访问web是不需要用户名密码的，因此需要在这里加一层密码保护</span></span><br><span class="line"><span class="comment"># 如果你发现不加这个密码保护，路由器配置页面原本的用户认证能正常生效的话，可以不加</span></span><br><span class="line"><span class="attr">http_user</span> = admin</span><br><span class="line"><span class="attr">http_pwd</span> = admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还记得我们在服务端配置的 subdomain_host = example.com 吗</span></span><br><span class="line"><span class="comment"># 假设这里我们填 web01，那么你将 web01.example.com 解析到服务端ip后</span></span><br><span class="line"><span class="comment"># 你就可以使用 域名:端口 来访问你的 http 了</span></span><br><span class="line"><span class="comment"># 这个域名的作用是用来区分不同的 http，因为你可以配置多个这样的配置</span></span><br><span class="line"><span class="attr">subdomain</span> = web01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义域名，这个不同于 subdomain，你可以设置与 subdomain_host 无关的其他域名</span></span><br><span class="line"><span class="comment"># subdomain 与 custom_domains 中至少有一个必须要设置</span></span><br><span class="line"><span class="attr">custom_domains</span> = web02.yourdomain.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配路径，可以设置多个，用逗号分隔，比如你设置 locations 为以下这个，</span></span><br><span class="line"><span class="comment"># 那么所有 http://xxx/abc 和 http://xxx/def 都会被转发到 http://xxx/</span></span><br><span class="line"><span class="comment"># 如果不需要这个功能可以不写这项，就直接该怎么访问就怎么访问</span></span><br><span class="line"><span class="attr">locations</span> = /abc,/def</span><br></pre></td></tr></table></figure>

<h4 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h4><p>根据你的需求，将配置写入<code>~/.frp/frpc.ini</code>中，并执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup frpc -c ~/.frp/frpc.ini &amp;</span><br></pre></td></tr></table></figure>

<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>这是笔者frpc部分配置</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">10022</span></span><br><span class="line"><span class="section">[k8s-router]</span></span><br><span class="line"><span class="attr">type</span> = https</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">6443</span></span><br><span class="line"><span class="attr">subdomain</span> = k8s-pro</span><br></pre></td></tr></table></figure>

<p>此时随意找一台机器试一试能不能通过ECS的ip地址+<code>10022</code>这个端口ssh到内网的机器上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh xxx@xx.xx.xx -p 10022</span><br></pre></td></tr></table></figure>

<p>如果提示需要输入密码，则表示配置生效，可以通过公网地址链接到内网机器上。</p>
<blockquote>
<p>PS: k8s的https路由我们会在下面使用到。</p>
</blockquote>
<h2 id="使用kubeadm在本地搭建cluster"><a href="#使用kubeadm在本地搭建cluster" class="headerlink" title="使用kubeadm在本地搭建cluster"></a>使用kubeadm在本地搭建cluster</h2><p><em>基本配置</em></p>
<ul>
<li>安装docker</li>
<li>关闭swap</li>
<li>关闭SELinux</li>
<li>确认cgroup drive</li>
</ul>
<p>以上具体配置可以参考<a href="./%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0kubernetes-%E4%BA%8C-ECS%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%9B%86%E7%BE%A4.md">零基础学习 kubernetes(二): 在 ECS 上部署集群</a></p>
<h3 id="安装kubelet、kubeadm、kubectl"><a href="#安装kubelet、kubeadm、kubectl" class="headerlink" title="安装kubelet、kubeadm、kubectl"></a>安装kubelet、kubeadm、kubectl</h3><p>您需要在每台机器上都安装以下的软件包：</p>
<ul>
<li><code>kubeadm</code>: 用来初始化集群的指令</li>
<li><code>kubelet</code>: 在集群中的每个节点上用来启动pod和container等</li>
<li><code>kubectl</code>: 用来与集群通信的命令行工具</li>
</ul>
<p><em>安装CNI插件</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CNI_VERSION=&quot;v0.6.0&quot;</span><br><span class="line">mkdir -p /opt/cni/bin</span><br><span class="line">curl -L &quot;https://github.com/containernetworking/plugins/releases/download/$&#123;CNI_VERSION&#125;/cni-plugins-amd64-$&#123;CNI_VERSION&#125;.tgz&quot; | tar -C /opt/cni/bin -xz</span><br></pre></td></tr></table></figure>

<p><em>安装crictl(kubeadm/Kubelet的容器运行时接口(CRI)要求)</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CRICTL_VERSION=&quot;v1.11.1&quot;</span><br><span class="line">mkdir -p /opt/bin</span><br><span class="line">curl -L &quot;https://github.com/kubernetes-incubator/cri-tools/releases/download/$&#123;CRICTL_VERSION&#125;/crictl-$&#123;CRICTL_VERSION&#125;-linux-amd64.tar.gz&quot; | tar -C /opt/bin -xz</span><br></pre></td></tr></table></figure>

<p><em>安装<code>kubeadm</code>,<code>kubelet</code>,<code>kubectl</code>并且添加一个<code>kubelet</code>systemd服务</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RELEASE=&quot;$(curl -sSL https://dl.k8s.io/release/stable.txt)&quot;</span><br><span class="line"></span><br><span class="line">mkdir -p /opt/bin</span><br><span class="line">cd /opt/bin</span><br><span class="line">curl -L --remote-name-all https://storage.googleapis.com/kubernetes-release/release/$&#123;RELEASE&#125;/bin/linux/amd64/&#123;kubeadm,kubelet,kubectl&#125;</span><br><span class="line">chmod +x &#123;kubeadm,kubelet,kubectl&#125;</span><br><span class="line"></span><br><span class="line">curl -sSL &quot;https://raw.githubusercontent.com/kubernetes/kubernetes/$&#123;RELEASE&#125;/build/debs/kubelet.service&quot; | sed &quot;s:/usr/bin:/opt/bin:g&quot; &gt; /etc/systemd/system/kubelet.service</span><br><span class="line">mkdir -p /etc/systemd/system/kubelet.service.d</span><br><span class="line">curl -sSL &quot;https://raw.githubusercontent.com/kubernetes/kubernetes/$&#123;RELEASE&#125;/build/debs/10-kubeadm.conf&quot; | sed &quot;s:/usr/bin:/opt/bin:g&quot; &gt; /etc/systemd/system/kubelet.service.d/10-kubeadm.conf</span><br></pre></td></tr></table></figure>

<p><em>启用并启动<code>kubelet</code></em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure>

<p>kubelet 现在每隔几秒就会重启，因为它陷入了一个等待 kubeadm 指令的死循环。</p>
<h3 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm init --kubernetes-version=v1.13.1 --image-repository=bluenet13 --apiserver-advertise-address=0.0.0.0 --pod-network-cidr=10.244.0.0/16 --apiserver-cert-extra-sans=k8s-pro.leosocy.top</span><br></pre></td></tr></table></figure>

<p><em>Options</em></p>
<ul>
<li><code>--kubernetes-version</code>: 截止笔者撰写此博客时，最新的stable版本为1.13.1</li>
<li><code>--image-repository</code>: 配置指定的docker registry，避免默认的<code>k8s.gcr.io</code>由于被墙导致的镜像拉取失败</li>
<li><code>--apiserver-advertise-address</code>: 指定“0.0.0.0”来使用默认网络接口的地址</li>
<li><code>--apiserver-cert-extra-sans</code>: 用于apiserver服务证书的可选额外SANs，可以是IP地址和DNS名称。还记得我们在上面配置的frpc的<code>k8s-router</code>的https路由规则，以笔者的配置为例，当外网用户配置好了<code>kubectl</code>的cluster、签名用户、以及context后，请求操作apiserver <code>https://k8s-pro.leosocy.top</code>时，阿里云DNS解析首先将请求根据域名解析到配置的ECS公网IP上，然后frps根据客户端配置，将请求路由到指定的内网端口上(即内网k8s apiserver)，apiserver根据Host判断是否在证书的SANs中，如果在则执行响应操作并响应。所以外界根本感知不到是在操作一个内网的k8s集群</li>
<li><code>--pod-network-cidr</code>: 选择pod网络对应的cidr(笔者这里选择的是flannel)</li>
</ul>
<p>稍等几分钟之后，cluster master就安装成功了，启动成功之后还要创建pod网络、设置工作节点等等，具体可以参考<a href="./%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0kubernetes-%E4%BA%8C-ECS%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%9B%86%E7%BE%A4.md">零基础学习kubernetes(二): 在ECS上部署集群</a></p>
<h3 id="使用kubectl在公网上操作内网cluster"><a href="#使用kubectl在公网上操作内网cluster" class="headerlink" title="使用kubectl在公网上操作内网cluster"></a>使用kubectl在公网上操作内网cluster</h3><p>上面我们已经成功的在内网搭建了一个k8s集群(虽然只有一个master节点)，现在如果我们想通过公网的ip/域名操作这个集群该怎么办呢？</p>
<h4 id="创建用户凭证"><a href="#创建用户凭证" class="headerlink" title="创建用户凭证"></a>创建用户凭证</h4><p>集群启动后，k8s帮我们创建了一个master账号，拥有操作集群的超级权限，很显然如果想在外部网络操作集群，是不可能配置这个账号的。所以，我们要按需创建用户账号(即RBAC)，并赋予相关权限。</p>
<ol>
<li>为用户创建私钥。在这个例子中，我们将命名文件<code>employee.key</code>: <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out employee.key 2048</span><br></pre></td></tr></table></figure></li>
<li>创建证书签名请求<code>employee.csr</code>使用刚刚创建的私钥<code>employee.key</code>。确保在<code>-subj</code>部分中指定了用户名(CN是用户名) <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl req -new -key employee.key -out employee.csr -subj &quot;/CN=employee&quot;</span><br></pre></td></tr></table></figure></li>
<li>使用集群证书颁发机构(CA)给employee.csr签发证书，ca根证书一般在集群master的<code>/etc/kubernetes/pki/</code>下 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -in employee.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out employee.crt -days 3650</span><br></pre></td></tr></table></figure></li>
<li>将<code>ca.crt</code>, <code>employee.key</code>, <code>employee.crt</code>保存到需要操作集群的机器上(例如你的ECS)的一个目录下，例如<code>~/.kube/crts</code></li>
<li>设置cluster、credentials以及context <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">k config set-cluster `your-cluster-name` --server=`your-cluster-domain` --certificate-authority=~/.kube/crts/cluster/ca.key</span><br><span class="line">k config set-credentials employee --client-certificate=~/.kube/crts/user/employee.crt --client-key=~/.kube/crts/user/employee.key</span><br><span class="line">k config set-context employee-context --cluster=`your-cluster-name` --user=employee</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>现在，在使用带有此配置文件的kubectl CLI时，应该会出现访问拒绝错误。这是预期的，因为我们还没有为该用户定义任何允许的操作。</p>
<h4 id="根据需求创建RoleBinding-ClusterRoleBinding"><a href="#根据需求创建RoleBinding-ClusterRoleBinding" class="headerlink" title="根据需求创建RoleBinding/ClusterRoleBinding"></a>根据需求创建RoleBinding/ClusterRoleBinding</h4><ol>
<li><p>创建一个名为<code>office</code>的命名空间</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">k create ns office</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个<code>role-deployment-manager.yml</code>文件包含以下内容。在这个yaml文件中，我们创建了一个规则，允许用户在<code>Deployment</code>、<code>Pod</code>和<code>ReplicaSets</code>(创建Deployment所必需的)上执行一些操作，这些操作属于核心(在yaml文件中以“”表示)、应用程序和扩展API组:</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">namespace:</span> <span class="string">office</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">deployment-manager</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>, <span class="string">&quot;extensions&quot;</span>, <span class="string">&quot;apps&quot;</span>]</span><br><span class="line"><span class="attr">resources:</span> [<span class="string">&quot;deployments&quot;</span>, <span class="string">&quot;replicasets&quot;</span>, <span class="string">&quot;pods&quot;</span>]</span><br><span class="line"><span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;patch&quot;</span>, <span class="string">&quot;delete&quot;</span>] <span class="comment"># You can also use [&quot;*&quot;]</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">k apply -f role-deployment-manager.yml</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定角色到employee用户，创建一个<code>rolebinding-deployment-manager.yml</code>文件包含以下内容。在这个文件中，我们将<code>deployment-manager</code>角色绑定到office名称空间中的用户帐户employee:</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">deployment-manager-binding</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">office</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">employee</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">deployment-manager</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">k apply -f rolebinding-deployment-manager.yaml</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试RBAC角色，可以看到employee用户已经有了相应的操作资源的权限了</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">k config use-context employee-context   # 切换context</span><br><span class="line">k run --image nginx mynginx</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3><p>搭建一个nginx service试试</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">office</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.14</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">office</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br></pre></td></tr></table></figure>

<p>然后<code>port-forward</code>将服务的端口映射到本地端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">k port-forward svc/nginx-service 8080:80</span><br></pre></td></tr></table></figure>

<p>curl下看看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl localhost:8080</span><br></pre></td></tr></table></figure>

<p>可以看到如下输出</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Welcome to nginx!</span><br><span class="line">If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h2><p>通过上面的一顿操作，我们在内网的机器上部署了k8s集群，然后通过<code>frp</code>工具，将来自外网的请求通过具有公网ip的ECS转发到了内网，从而实现了调用内网k8s apiserver。</p>
<p>现在你就可以丢掉资源受限的ECS k8s了，将家里闲置的笔记本电脑(例如笔者已经服役五年依旧坚挺的Dell)重新利用起来，搭建一个真正意义上的k8s集群，并在其上部署/监控你的应用吧！</p>
<h2 id="What’s-next"><a href="#What’s-next" class="headerlink" title="What’s next?"></a>What’s next?</h2><p>在集群中部署Istio，让外部请求(HTTP/HTTPS)通过ECS上的frps转发到内网集群的指定端口，进而将请求路由进入mesh，并根据路由策略，路由到对应的svc。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://lolico.moe/tutorial/frp.html">https://lolico.moe/tutorial/frp.html</a><br><a href="https://docs.bitnami.com/kubernetes/how-to/configure-rbac-in-your-kubernetes-cluster/">https://docs.bitnami.com/kubernetes/how-to/configure-rbac-in-your-kubernetes-cluster/</a></p>
]]></content>
      <categories>
        <category>云原生</category>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>NAT</tag>
      </tags>
  </entry>
</search>
